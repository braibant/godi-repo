From c81ff0c5522b1c84a1b6a13b7525f065ebe816f9 Mon Sep 17 00:00:00 2001
From: Ralf Vogler <ralf.vogler@gmail.com>
Date: Mon, 14 Jul 2014 16:12:34 +0200
Subject: [PATCH 1/4] remove CamlinternalPr for compilation with OCaml 4.02.0

---
 src/batPrintf.ml  |  2 --
 src/batPrintf.mli | 68 -------------------------------------------------------
 2 files changed, 70 deletions(-)

diff --git a/src/batPrintf.ml b/src/batPrintf.ml
index f0dabc5..622a708 100644
--- src/batPrintf.ml
+++ src/batPrintf.ml
@@ -520,5 +520,3 @@ let sprintf         = Printf.sprintf
 let ksprintf        = Printf.ksprintf
 let kbprintf        = Printf.kbprintf
 let kprintf         = Printf.kprintf
-
-module CamlinternalPr = Printf.CamlinternalPr
diff --git a/src/batPrintf.mli b/src/batPrintf.mli
index bcfb257..67d2d4a 100644
--- src/batPrintf.mli
+++ src/batPrintf.mli
@@ -329,71 +329,3 @@ val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b
 *)
 
 (**/**)
-
-(* For OCaml system internal use only. Don't call directly. *)
-
-module CamlinternalPr : sig
-
-  module Sformat : sig
-    type index;;
-
-    val index_of_int : int -> index;;
-    external int_of_index : index -> int = "%identity";;
-    external unsafe_index_of_int : int -> index = "%identity";;
-
-    val succ_index : index -> index;;
-
-    val sub : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> index -> int -> string;;
-    val to_string : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string;;
-    external length : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int
-      = "%string_length";;
-    external get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
-      = "%string_safe_get";;
-    external unsafe_to_string : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
-      = "%identity";;
-    external unsafe_get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
-      = "%string_unsafe_get";;
-
-  end;;
-
-  module Tformat : sig
-
-    type ac = {
-      mutable ac_rglr : int;
-      mutable ac_skip : int;
-      mutable ac_rdrs : int;
-    };;
-
-    val ac_of_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ac;;
-
-    val sub_format :
-      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> int) ->
-      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char -> int) ->
-      char ->
-      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
-      int ->
-      int
-
-    val summarize_format_type : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
-
-    val scan_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
-      'g array ->
-      Sformat.index ->
-      int ->
-      (Sformat.index -> string -> int -> 'h) ->
-      (Sformat.index -> 'i -> 'j -> int -> 'h) ->
-      (Sformat.index -> 'k -> int -> 'h) ->
-      (Sformat.index -> int -> 'h) ->
-      (Sformat.index -> ('l, 'm, 'n, 'o, 'p, 'q) format6 -> int -> 'h) ->
-      'h
-
-    val kapr :
-      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> Obj.t array -> 'g) ->
-      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
-      'g
-
-  end;;
-
-end;;
-
-(**/**)

From a27c7ac1390df9056bf69f625757f3ae11c323ee Mon Sep 17 00:00:00 2001
From: Ralf Vogler <ralf.vogler@gmail.com>
Date: Tue, 15 Jul 2014 13:14:36 +0200
Subject: [PATCH 2/4] Revert "remove CamlinternalPr for compilation with OCaml
 4.02.0"

This reverts commit c81ff0c5522b1c84a1b6a13b7525f065ebe816f9.
---
 src/batPrintf.ml  |  2 ++
 src/batPrintf.mli | 68 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+)

diff --git a/src/batPrintf.ml b/src/batPrintf.ml
index 622a708..f0dabc5 100644
--- src/batPrintf.ml
+++ src/batPrintf.ml
@@ -520,3 +520,5 @@ let sprintf         = Printf.sprintf
 let ksprintf        = Printf.ksprintf
 let kbprintf        = Printf.kbprintf
 let kprintf         = Printf.kprintf
+
+module CamlinternalPr = Printf.CamlinternalPr
diff --git a/src/batPrintf.mli b/src/batPrintf.mli
index 67d2d4a..bcfb257 100644
--- src/batPrintf.mli
+++ src/batPrintf.mli
@@ -329,3 +329,71 @@ val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b
 *)
 
 (**/**)
+
+(* For OCaml system internal use only. Don't call directly. *)
+
+module CamlinternalPr : sig
+
+  module Sformat : sig
+    type index;;
+
+    val index_of_int : int -> index;;
+    external int_of_index : index -> int = "%identity";;
+    external unsafe_index_of_int : int -> index = "%identity";;
+
+    val succ_index : index -> index;;
+
+    val sub : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> index -> int -> string;;
+    val to_string : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string;;
+    external length : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int
+      = "%string_length";;
+    external get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
+      = "%string_safe_get";;
+    external unsafe_to_string : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
+      = "%identity";;
+    external unsafe_get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
+      = "%string_unsafe_get";;
+
+  end;;
+
+  module Tformat : sig
+
+    type ac = {
+      mutable ac_rglr : int;
+      mutable ac_skip : int;
+      mutable ac_rdrs : int;
+    };;
+
+    val ac_of_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ac;;
+
+    val sub_format :
+      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> int) ->
+      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char -> int) ->
+      char ->
+      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+      int ->
+      int
+
+    val summarize_format_type : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
+
+    val scan_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+      'g array ->
+      Sformat.index ->
+      int ->
+      (Sformat.index -> string -> int -> 'h) ->
+      (Sformat.index -> 'i -> 'j -> int -> 'h) ->
+      (Sformat.index -> 'k -> int -> 'h) ->
+      (Sformat.index -> int -> 'h) ->
+      (Sformat.index -> ('l, 'm, 'n, 'o, 'p, 'q) format6 -> int -> 'h) ->
+      'h
+
+    val kapr :
+      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> Obj.t array -> 'g) ->
+      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+      'g
+
+  end;;
+
+end;;
+
+(**/**)

From 9bc2559789fb46c6b94cbd77b411990d0176ae9b Mon Sep 17 00:00:00 2001
From: Ralf Vogler <ralf.vogler@gmail.com>
Date: Tue, 15 Jul 2014 14:05:01 +0200
Subject: [PATCH 3/4] support comparison operator for prefilter on version

---
 build/prefilter.ml | 18 ++++++++----------
 1 file changed, 8 insertions(+), 10 deletions(-)

diff --git a/build/prefilter.ml b/build/prefilter.ml
index 1688d1f..8e1c0b7 100644
--- build/prefilter.ml
+++ build/prefilter.ml
@@ -3,23 +3,21 @@ let (major, minor) =
     "%d.%d." (fun j n -> (j, n))
 
 let filter_cookie_re =
-  Str.regexp "^##V\\([^#]+\\)##"
+  Str.regexp "^##V\\([<>]?=?\\)\\([^#]+\\)##"
 let version_re =
   Str.regexp "\\([0-9]+\\)\\(\\.\\([0-9]+\\)\\)?"
 
-let maybe f x = try Some (f x) with _ -> None
-
 let process_line line =
   if Str.string_match filter_cookie_re line 0 then begin
-    let ver_string = Str.matched_group 1 line in
+    let cmp = match Str.matched_group 1 line with
+    | "<" -> (<) | ">" -> (>) | "=" -> (=)
+    | "<=" -> (<=) | ">=" -> (>=) | _ -> (>=)
+    in
+    let ver_string = Str.matched_group 2 line in
     assert (Str.string_match version_re ver_string 0) ;
     let ver_maj = int_of_string (Str.matched_group 1 ver_string) in
-    let pass = match maybe (Str.matched_group 3) ver_string with
-    | None -> ver_maj <= major
-    | Some ver_min ->
-      let ver_min = int_of_string ver_min in
-      ver_maj <= major && ver_min <= minor
-    in
+    let ver_min = try int_of_string (Str.matched_group 3 ver_string) with _ -> 0 in
+    let pass = cmp (major*100+minor) (ver_maj*100+ver_min) in
     if pass then Str.replace_first filter_cookie_re "" line
     else ""
   end else line

From 06bd85da32bdda3d39d5f99aa727257668448112 Mon Sep 17 00:00:00 2001
From: Ralf Vogler <ralf.vogler@gmail.com>
Date: Tue, 15 Jul 2014 14:05:52 +0200
Subject: [PATCH 4/4] remove BatPrintf.CamlinternalPr for OCaml versions >=
 4.02

---
 Makefile           |   3 +-
 src/batPrintf.mliv | 399 ++++++++++++++++++++++++++++++++++++++++
 src/batPrintf.mlv  | 524 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 925 insertions(+), 1 deletion(-)
 create mode 100644 src/batPrintf.mliv
 create mode 100644 src/batPrintf.mlv

diff --git a/Makefile b/Makefile
index adcab0b..0f6da7f 100644
--- Makefile
+++ Makefile
@@ -67,7 +67,8 @@ endif
 
 PREPROCESSED_FILES = src/batMarshal.mli src/batUnix.mli src/batPervasives.mli \
 		     src/batInnerPervasives.ml src/batHashtbl.ml \
-		     src/batPrintexc.mli src/batSys.mli src/batBigarray.mli
+		     src/batPrintexc.mli src/batPrintf.ml src/batPrintf.mli \
+			 src/batSys.mli src/batBigarray.mli
 
 .PHONY: all clean doc install uninstall reinstall test qtest qtest-clean camfail camfailunk coverage man
 
diff --git a/src/batPrintf.mliv b/src/batPrintf.mliv
new file mode 100644
index 0000000..b2c684c
--- dev/null
+++ src/batPrintf.mliv
@@ -0,0 +1,399 @@
+(*
+ * BatPrintf - Extended Printf module
+ * Copyright (C) 2008 David Teller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version,
+ * with the special exception on linking described in file LICENSE.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *)
+
+open BatInnerIO
+
+(** Formatted output functions (also known as unparsing).
+
+    @author Xavier Leroy
+    @author Pierre Weiss
+    @author David Teller
+*)
+
+(**
+   {6 General overview}
+
+   The functions of this module produce output according to a
+   {!Pervasives.format}, as described below. Some functions write to
+   the standard output (i.e. the screen), some to error channels,
+   some to strings or to buffers, or some to abstract outputs.
+
+   {b Note} The types used in this module are confusing at first.
+   If you are a beginner, you should probably ignore them in a
+   first time and concentrate on formats.
+
+   For a first explanation, we will concentrate on function {!printf}.
+   As all the functions in this module, the behavior of {!printf} is
+   dictated by a {!format}. This format is a string, composed of
+   regular text and directives, and which dictates how to interpret
+   the other arguments passed to the function. Every directive starts
+   with character [%].  The most common directive is [%s], which
+   serves to display a string, something quite useful for
+   pretty-printing or translation.  Anther common directive is [%i],
+   which serves to display an integer.
+
+   For instance, ["foobar"] is a format with no directive. Calling
+   [printf "foobar"] prints ["foobar"] on the screen and returns
+   [()]. On the other hand, ["%s"] is a format with one directive for
+   printing strings. [printf "%s"] does nothing yet but returns a
+   function with type [string -> unit]. In turn, [printf "%s"
+   "foobar"] prints ["foobar"] on the screen and returns [()]. The
+   main interest of this module is that directives may be combined
+   together and with text, to allow more complex printing. For instance
+   [printf "(%s)\n"] is a function with type [string -> unit] which,
+   when passed string ["foobar"] prints ["(foobar)"] and ends the
+   line. Similarly, [printf "Here's the result: %s.\n\tComputation
+   took %i seconds.\n" "foobar" 5] prints
+   {[Here's the result: foobar
+         Computation took 5 seconds.]}
+
+   Note that [\n] (the newline character) and [\t] (the tabulation)
+   are not specific to this module but rather part of the conventions
+   on characters strings in OCaml.
+
+   Other directives and functions make this module extremely useful
+   for printing, pretty-printing and translation of messages to
+   the user's language. For more information, see the documentation
+   of {!format} and the various functions.*)
+
+
+
+(**
+   {6 Formats}
+*)
+
+type ('a, 'b, 'c) t = ('a, 'b, 'c) Pervasives.format
+(**
+   The format to use for displaying the various arguments passed to the function.
+
+   Syntactically, the format is a character string which contains two types
+   of objects: plain characters, which are simply copied, and directives,
+   each of which causes the conversion and printing of arguments.
+
+   {7 Simple directives}
+
+   All directives start with the [%] character. In their simplest form,
+   a directive is [%] followed by exactly one character:
+
+   - [%d], [%i], [%n], [%l], [%L], or [%N]: convert an integer argument to
+     signed decimal.
+   - [%u]: convert an integer argument to unsigned decimal.
+   - [%x]: convert an integer argument to unsigned hexadecimal,
+     using lowercase letters.
+   - [%X]: convert an integer argument to unsigned hexadecimal,
+     using uppercase letters.
+   - [%o]: convert an integer argument to unsigned octal.
+   - [%s]: insert a string argument.
+   - [%S]: insert a string argument in OCaml syntax (double quotes, escapes).
+   - [%c]: insert a character argument.
+   - [%C]: insert a character argument in OCaml syntax (single quotes, escapes).
+   - [%f]: convert a floating-point argument to decimal notation,
+     in the style [dddd.ddd].
+   - [%F]: convert a floating-point argument to OCaml syntax ([dddd.]
+     or [dddd.ddd] or [d.ddd e+-dd]).
+   - [%e] or [%E]: convert a floating-point argument to decimal notation,
+     in the style [d.ddd e+-dd] (mantissa and exponent).
+   - [%g] or [%G]: convert a floating-point argument to decimal notation,
+     in style [%f] or [%e], [E] (whichever is more compact).
+   - [%B]: convert a boolean argument to the string [true] or [false]
+   - [%b]: convert a boolean argument (for backward compatibility; do not
+     use in new programs).
+   - [%ld], [%li], [%lu], [%lx], [%lX], [%lo]: convert an [int32] argument to
+     the format specified by the second letter (decimal, hexadecimal, etc).
+   - [%nd], [%ni], [%nu], [%nx], [%nX], [%no]: convert a [nativeint] argument to
+     the format specified by the second letter.
+   - [%Ld], [%Li], [%Lu], [%Lx], [%LX], [%Lo]: convert an [int64] argument to
+     the format specified by the second letter.
+   - [!]: take no argument and flush the output.
+   - [%]: take no argument and output one [%] character.
+   - [,]: the no-op delimiter for conversion specifications
+
+
+   {7 Unparsers}
+
+   - [%a]: user-defined printer. Typically, this printer corresponds to two
+     arguments: a printing function [f], with type ['a output -> 'c -> unit]
+     and the item [x] you want to print, with type ['c]. Item [x] will
+     be printing by calling [f out x], where [out] is the output you are
+     currently using -- if you are calling {!printf}, this output is
+     the standard output (i.e. the screen), if you are calling {!eprintf},
+     this will be the error channel, if you are calling {!fprintf}, this
+     will be the output you provided yourself, etc. More generally, if your
+     {!format} has type [('a, 'b, 'd) format] or [('a, 'b, 'd, 'e) format4],
+     the printing function [f] must have type ['b -> 'c -> 'd], where
+     [x] has type ['d].
+   - [%t]: same as [%a] but takes only a printing function [f],
+     without an item. If your {!format} has type [('a, 'b, 'd) format]
+     or [('a, 'b, 'd, 'e) format4], function [f] must have type
+     ['b -> 'd].
+
+   {7 Formatting formats}
+   - [%\{ fmt %\}]: convert a {!format} to a string. The format argument
+     must have the same type as the internal format string [fmt].
+     In other words, [printf "%\{ %s %\}"] accepts an argument
+     whose type must be the same as that of format ["%s"], and
+     prints that format argument as if it were a character string.
+   - [%( fmt %)]: format string substitution. Takes a format string
+     argument and substitutes it to the internal format string [fmt]
+     to print following arguments. The argument must have the same
+     type as [fmt]. [printf "%\{ %s %\}"] accepts an argument
+     whose type must be the same as that of format ["%s"], and
+     uses that argument to print the following arguments.
+
+   {7 Additional options}
+   The general format of directives is
+
+   [% \[flags\] \[width\] \[.precision\] type]
+
+   [type] is one of [d], [i], [n], [l], [L], [N], [u], [x] ...,
+   [( fmt %)] and behaves as explained above.
+
+   The optional [flags] are:
+   - [-]: left-justify the output (default is right justification).
+   - [0]: for numerical conversions, pad with zeroes instead of spaces.
+   - [+]: for numerical conversions, prefix number with a [+] sign if positive.
+   - space: for numerical conversions, prefix number with a space if positive.
+   - [#]: request an alternate formatting style for numbers.
+
+   The optional [width] is an integer indicating the minimal
+   width of the result. For instance, [%6d] prints an integer,
+   prefixing it with spaces to fill at least 6 characters.
+
+   The optional [precision] is a dot [.] followed by an integer
+   indicating how many digits follow the decimal point in the [%f],
+   [%e], and [%E] conversions. For instance, [%.4f] prints a [float] with
+   4 fractional digits.
+
+   The integer in a [width] or [precision] can also be specified as
+   [*], in which case an extra integer argument is taken to specify
+   the corresponding [width] or [precision]. This integer argument
+   precedes immediately the argument to print.
+   For instance, [%.*f] prints a [float] with as many fractional
+   digits as the value of the argument given before the float.
+*)
+
+
+(** {6 Common functions}*)
+
+val printf: ('b, 'a output, unit) t -> 'b
+(**The usual [printf] function, prints to the standard output {!stdout}, i.e. normally
+   to the screen. If you are lost, this is probably the function you're looking for.*)
+
+val eprintf: ('b, 'a output, unit) t -> 'b
+(**The usual [eprintf] function, prints to the standard error output {!stderr}, used
+   to display warnings and errors. Otherwise identical to {!printf}.*)
+
+val sprintf:  ('a, unit, string) t -> 'a
+(** A function which doesn't print its result but returns it as a string. Useful
+    for building messages, for translation purposes or for display in a window,
+    for instance.
+
+    While this function is quite convenient, don't abuse it to create very large
+    strings such as files, that's not its role. For this kind of usage, prefer
+    the more modular and usually faster {!fprintf}.
+
+    Note that any function called with [%a] should return strings, i.e.
+    should have type [unit -> string].*)
+
+val sprintf2: ('a, 'b output, unit, string) format4 -> 'a
+(** A function which doesn't print its result but returns it as a string. Useful
+    for building messages, for translation purposes or for display in a window,
+    for instance.
+
+    While this function is quite convenient, don't abuse it to create very large
+    strings such as files, that's not its role. For this kind of usage, prefer
+    the more modular and usually faster {!fprintf}.
+    Note that any function called with [%a] should be able to print its result,
+    i.e. should have type ['b output -> unit].
+
+    Warning: a partial application of this function can only be used once,
+    because the {!BatInnerIO.output} that it uses is closed afterwards.
+    Example: [let f = sprintf2 "%a" Int.print in [f 1; f 2]] will fail. *)
+
+
+(** {6 General functions}*)
+
+val fprintf: 'a output -> ('b, 'a output, unit) t -> 'b
+(**General function. This function prints to any output. Typically,
+   if you are attempting to build a large output such as a file,
+   this is probably the function you are looking for. If you are
+   writing a pretty-printer, this is probably the function you are
+   looking for. If you are you are looking for a function to use for
+   argument [%a] with {!printf}, {!eprintf}, {!sprintf2},
+   {!ifprintf}, {!bprintf2}, {!kfprintf}, {!ksprintf2}, {!kbprintf2}
+   or any other function with type [(_, _ output, unit) format] or
+   [(_, _ output, unit, _) format4], this is also probably the
+   function you are looking for.*)
+
+
+val ifprintf: _        -> ('b, 'a output, unit) t -> 'b
+(**As {!fprintf} but doesn't actually print anything.
+   Sometimes useful for debugging.*)
+
+val bprintf: Buffer.t  -> ('a, Buffer.t, unit) t -> 'a
+(**As {!fprintf}, but with buffers instead of outputs.
+   In particular, any unparser called with [%a] should
+   write to a buffer rather than to an output*)
+
+val bprintf2: Buffer.t  -> ('b, 'a output, unit) t -> 'b
+(**As {!printf} but writes to a buffer instead
+   of printing to the output. By opposition to
+   {!bprintf}, only the result is changed with
+   respect to {!printf}, not the inner workings.*)
+
+(**{6 Functions with continuations}*)
+
+val kfprintf : ('a output -> 'b) -> 'a output -> ('c, 'a output, unit, 'b) format4 -> 'c
+(**Same as [fprintf], but instead of returning immediately, passes the [output] to its first
+   argument at the end of printing.*)
+
+val ksprintf: (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b
+(** Same as [sprintf] above, but instead of returning the string,
+    passes it to the first argument. *)
+val ksprintf2: (string -> 'b) -> ('c, 'a output, unit, 'b) format4 -> 'c
+(** Same as [sprintf2] above, but instead of returning the string,
+    passes it to the first argument. *)
+
+val kbprintf : (Buffer.t -> 'a) ->
+  Buffer.t -> ('b, Buffer.t, unit, 'a) format4 -> 'b
+(** Same as [bprintf], but instead of returning immediately,
+    passes the buffer to its first argument at the end of printing. *)
+
+val kbprintf2 : (Buffer.t -> 'b) ->  Buffer.t -> ('c, 'a output, unit, 'b) format4 -> 'c
+(** Same as [bprintf2], but instead of returning immediately,
+    passes the buffer to its first argument at the end of printing.*)
+
+val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b
+(** @deprecated This is a deprecated synonym for [ksprintf]. *)
+
+
+(**
+   {6 About formats}
+
+   You only need to read this if you intend to create your new printf-like functions,
+   which happens generally by toying with {!mkprintf}.
+
+
+   {7 Format4}
+
+   [('a, 'b, 'c, 'd) format4] is the type of arguments for
+   [printf]-style functions such that
+   - ['a] is the type of arguments, with a return type of ['d]
+   {ul
+   {- if your format looks like ["%s"], ['a] is [string -> 'd]}
+   {- if your format looks like ["%s%s"], ['a] is [string -> string -> 'd]}
+   {- ...}
+   }
+   - ['b] is the type of the first argument given to unparsers
+   (i.e. functions introduced with [%a] or [%t])
+   {ul
+   {- if your unparsers take a [unit] argument, ['b] should be
+   [unit]}
+   {- if your unparsers take a [string output], ['b] should be
+   [string output]}
+   {- ...}
+   }
+   - ['c] is the {b final} return type of unparsers
+   {ul
+   {- if you have an unparser introduced with [%t] and its result
+   has type [unit], ['c] should be [unit]}
+   {- if you have an unparser introduced with [%a] and its type is
+   [string output -> string -> unit], ['c] should be [unit]}
+   {- ...}
+   }
+   - ['d] is the final return value of the function once all
+   arguments have been printed
+
+   {7 Format}
+   [('a, 'b, 'c) format] or [('a, 'b, 'c) t] is just a shortcut for [('a, 'b, 'c, 'c) format4].
+
+   {7 Important}
+   Note that {!Obj.magic} is involved behind this, so be careful.
+*)
+
+(**/**)
+
+(* For OCaml system internal use only. Don't call directly. *)
+
+##V<4.2##module CamlinternalPr : sig
+##V<4.2##
+##V<4.2##  module Sformat : sig
+##V<4.2##    type index;;
+##V<4.2##
+##V<4.2##    val index_of_int : int -> index;;
+##V<4.2##    external int_of_index : index -> int = "%identity";;
+##V<4.2##    external unsafe_index_of_int : int -> index = "%identity";;
+##V<4.2##
+##V<4.2##    val succ_index : index -> index;;
+##V<4.2##
+##V<4.2##    val sub : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> index -> int -> string;;
+##V<4.2##    val to_string : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string;;
+##V<4.2##    external length : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int
+##V<4.2##      = "%string_length";;
+##V<4.2##    external get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
+##V<4.2##      = "%string_safe_get";;
+##V<4.2##    external unsafe_to_string : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
+##V<4.2##      = "%identity";;
+##V<4.2##    external unsafe_get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
+##V<4.2##      = "%string_unsafe_get";;
+##V<4.2##
+##V<4.2##  end;;
+##V<4.2##
+##V<4.2##  module Tformat : sig
+##V<4.2##
+##V<4.2##    type ac = {
+##V<4.2##      mutable ac_rglr : int;
+##V<4.2##      mutable ac_skip : int;
+##V<4.2##      mutable ac_rdrs : int;
+##V<4.2##    };;
+##V<4.2##
+##V<4.2##    val ac_of_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ac;;
+##V<4.2##
+##V<4.2##    val sub_format :
+##V<4.2##      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> int) ->
+##V<4.2##      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char -> int) ->
+##V<4.2##      char ->
+##V<4.2##      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+##V<4.2##      int ->
+##V<4.2##      int
+##V<4.2##
+##V<4.2##    val summarize_format_type : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
+##V<4.2##
+##V<4.2##    val scan_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+##V<4.2##      'g array ->
+##V<4.2##      Sformat.index ->
+##V<4.2##      int ->
+##V<4.2##      (Sformat.index -> string -> int -> 'h) ->
+##V<4.2##      (Sformat.index -> 'i -> 'j -> int -> 'h) ->
+##V<4.2##      (Sformat.index -> 'k -> int -> 'h) ->
+##V<4.2##      (Sformat.index -> int -> 'h) ->
+##V<4.2##      (Sformat.index -> ('l, 'm, 'n, 'o, 'p, 'q) format6 -> int -> 'h) ->
+##V<4.2##      'h
+##V<4.2##
+##V<4.2##    val kapr :
+##V<4.2##      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> Obj.t array -> 'g) ->
+##V<4.2##      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+##V<4.2##      'g
+##V<4.2##
+##V<4.2##  end;;
+##V<4.2##
+##V<4.2##end;;
+
+(**/**)
diff --git a/src/batPrintf.mlv b/src/batPrintf.mlv
new file mode 100644
index 0000000..bf91423
--- dev/null
+++ src/batPrintf.mlv
@@ -0,0 +1,524 @@
+(*
+ * BatPrintf - Extended Printf module
+ * Copyright (C) 2008 David Teller (contributor)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version,
+ * with the special exception on linking described in file LICENSE.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *)
+
+
+(**
+   {6 Printf}
+
+   A reimplementation of Printf (with a few additional functions) based
+   on [output].    We provide an internal signature to limit the dangers
+   of {!Obj.magic}.
+
+   {b Note} this module is inlined because of circular dependencies (themselves
+   caused by the legacy definition of a function {!printf} in module {!BatIO}).
+*)
+
+open BatInnerIO
+
+external format_float: string -> float -> string
+  = "caml_format_float"
+external format_int: string -> int -> string
+  = "caml_format_int"
+external format_int32: string -> int32 -> string
+  = "caml_int32_format"
+external format_nativeint: string -> nativeint -> string
+  = "caml_nativeint_format"
+external format_int64: string -> int64 -> string
+  = "caml_int64_format"
+
+module Sformat = struct
+
+  type index;;
+
+  external unsafe_index_of_int : int -> index = "%identity";;
+  let index_of_int i =
+    if i >= 0 then unsafe_index_of_int i
+    else failwith ("index_of_int: negative argument " ^ string_of_int i);;
+  external int_of_index : index -> int = "%identity";;
+
+  let add_int_index i idx = index_of_int (i + int_of_index idx);;
+  let succ_index = add_int_index 1;;
+
+  external length : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int
+    = "%string_length";;
+  external get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
+    = "%string_safe_get";;
+  external unsafe_get : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> int -> char
+    = "%string_unsafe_get";;
+  external unsafe_to_string : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
+    = "%identity";;
+  let sub fmt idx len =
+    String.sub (unsafe_to_string fmt) (int_of_index idx) len;;
+  let to_string fmt = sub fmt (unsafe_index_of_int 0) (length fmt);;
+
+end;;
+
+let bad_conversion sfmt i c =
+  invalid_arg
+    ("printf: bad conversion %" ^ String.make 1 c ^ ", at char number " ^
+     string_of_int i ^ " in format string ``" ^ sfmt ^ "''");;
+
+let bad_conversion_format fmt i c =
+  bad_conversion (Sformat.to_string fmt) i c;;
+
+let incomplete_format fmt =
+  invalid_arg
+    ("printf: premature end of format string ``" ^
+     Sformat.to_string fmt ^ "''");;
+
+(* Parses a string conversion to return the specified length and the padding direction. *)
+let parse_string_conversion sfmt =
+  let rec parse neg i =
+    if i >= String.length sfmt then (0, neg) else
+      match String.unsafe_get sfmt i with
+      | '1'..'9' ->
+        (int_of_string
+           (String.sub sfmt i (String.length sfmt - i - 1)),
+         neg)
+      | '-' -> parse true (succ i)
+      | _   -> parse neg  (succ i) in
+  try parse false 1 with Failure _ -> bad_conversion sfmt 0 's'
+
+(* Pad a (sub) string into a blank string of length [p],
+   on the right if [neg] is true, on the left otherwise. *)
+let pad_string pad_char p neg s i len =
+  if p = len && i = 0 then s else
+  if p <= len then String.sub s i len else
+    let res = String.make p pad_char in
+    if neg
+    then String.blit s i res 0 len
+    else String.blit s i res (p - len) len;
+    res
+
+(* Format a string given a %s format, e.g. %40s or %-20s.
+   To do: ignore other flags (#, +, etc)? *)
+let format_string sfmt s =
+  let (p, neg) = parse_string_conversion sfmt in
+  pad_string ' ' p neg s 0 (String.length s);;
+
+(* Extract a format string out of [fmt] between [start] and [stop] inclusive.
+   '*' in the format are replaced by integers taken from the [widths] list.
+   extract_format returns a string. *)
+let extract_format fmt start stop widths =
+  let start = succ start in
+  let b = Buffer.create (stop - start + 10) in
+  Buffer.add_char b '%';
+  let rec fill_format i widths =
+    if i <= stop then
+      match (Sformat.unsafe_get fmt i, widths) with
+      | ('*', h :: t) ->
+        Buffer.add_string b (string_of_int h);
+        let i = succ i in
+        fill_format i t
+      | ('*', []) ->
+        assert false (* should not happen *)
+      | (c, _) ->
+        Buffer.add_char b c; fill_format (succ i) widths in
+  fill_format start (List.rev widths);
+  Buffer.contents b;;
+
+let extract_format_int conv fmt start stop widths =
+  let sfmt = extract_format fmt start stop widths in
+  match conv with
+  | 'n' | 'N' ->
+    sfmt.[String.length sfmt - 1] <- 'u';
+    sfmt
+  | _ -> sfmt;;
+
+(* Returns the position of the next character following the meta format
+   string, starting from position [i], inside a given format [fmt].
+   According to the character [conv], the meta format string is
+   enclosed by the delimitors %{ and %} (when [conv = '{']) or %( and
+   %) (when [conv = '(']). Hence, [sub_format] returns the index of
+   the character following the [')'] or ['}'] that ends the meta format,
+   according to the character [conv]. *)
+let sub_format incomplete_format bad_conversion_format conv fmt i =
+  let len = Sformat.length fmt in
+  let rec sub_fmt c i =
+    let close = if c = '(' then ')' else (* '{' *) '}' in
+    let rec sub j =
+      if j >= len then incomplete_format fmt else
+        match Sformat.get fmt j with
+        | '%' -> sub_sub (succ j)
+        | _ -> sub (succ j)
+    and sub_sub j =
+      if j >= len then incomplete_format fmt else
+        match Sformat.get fmt j with
+        | '(' | '{' as c ->
+          let j = sub_fmt c (succ j) in sub (succ j)
+        | '}' | ')' as c ->
+          if c = close then succ j else bad_conversion_format fmt i c
+        | _ -> sub (succ j) in
+    sub i in
+  sub_fmt conv i;;
+
+let sub_format_for_printf conv =
+  sub_format incomplete_format bad_conversion_format conv;;
+
+let iter_on_format_args fmt add_conv add_char =
+
+  let lim = Sformat.length fmt - 1 in
+
+  let rec scan_flags skip i =
+    if i > lim then incomplete_format fmt else
+      match Sformat.unsafe_get fmt i with
+      | '*' -> scan_flags skip (add_conv skip i 'i')
+      | '#' | '-' | ' ' | '+' -> scan_flags skip (succ i)
+      | '_' -> scan_flags true (succ i)
+      | '0'..'9'
+      | '.' -> scan_flags skip (succ i)
+      | _ -> scan_conv skip i
+  and scan_conv skip i =
+    if i > lim then incomplete_format fmt else
+      match Sformat.unsafe_get fmt i with
+      | '%' | '!' | ',' -> succ i
+      | 's' | 'S' | '[' -> add_conv skip i 's'
+      | 'c' | 'C' -> add_conv skip i 'c'
+      | 'd' | 'i' |'o' | 'u' | 'x' | 'X' | 'N' -> add_conv skip i 'i'
+      | 'f' | 'e' | 'E' | 'g' | 'G' | 'F' -> add_conv skip i 'f'
+      | 'B' | 'b' -> add_conv skip i 'B'
+      | 'a' | 'r' | 't' as conv -> add_conv skip i conv
+      | 'l' | 'n' | 'L' as conv ->
+        let j = succ i in
+        if j > lim then add_conv skip i 'i' else begin
+          match Sformat.get fmt j with
+          | 'd' | 'i' | 'o' | 'u' | 'x' | 'X' ->
+            add_char (add_conv skip i conv) 'i'
+          | _c -> add_conv skip i 'i' end
+      | '{' as conv ->
+        (* Just get a regular argument, skipping the specification. *)
+        let i = add_conv skip i conv in
+        (* To go on, find the index of the next char after the meta format. *)
+        let j = sub_format_for_printf conv fmt i in
+        (* Add the meta specification to the summary anyway. *)
+        let rec loop i =
+          if i < j - 2 then loop (add_char i (Sformat.get fmt i)) in
+        loop i;
+        (* Go on, starting at the closing brace to properly close the meta
+           specification in the summary. *)
+        scan_conv skip (j - 1)
+      | '(' as conv ->
+        (* Use the static format argument specification instead of
+           the runtime format argument value: they must have the same type
+           anyway. *)
+        scan_fmt (add_conv skip i conv)
+      | '}' | ')' as conv -> add_conv skip i conv
+      | conv -> bad_conversion_format fmt i conv
+
+  and scan_fmt i =
+    if i < lim then
+      if Sformat.get fmt i = '%'
+      then scan_fmt (scan_flags false (succ i))
+      else scan_fmt (succ i)
+    else i in
+
+  ignore (scan_fmt 0);;
+
+(* Returns a string that summarizes the typing information that a given
+   format string contains.
+   For instance, [summarize_format_type "A number %d\n"] is "%i".
+   It also checks the well-formedness of the format string. *)
+let summarize_format_type fmt =
+  let len = Sformat.length fmt in
+  let b = Buffer.create len in
+  let add_char i c = Buffer.add_char b c; succ i in
+  let add_conv skip i c =
+    if skip then Buffer.add_string b "%_" else Buffer.add_char b '%';
+    add_char i c in
+  iter_on_format_args fmt add_conv add_char;
+  Buffer.contents b;;
+
+module Ac = struct
+  type ac = {
+    mutable ac_rglr : int;
+    mutable ac_skip : int;
+    mutable ac_rdrs : int;
+  }
+end;;
+
+open Ac;;
+
+(* Computes the number of arguments of a format (including flag
+   arguments if any). *)
+let ac_of_format fmt =
+  let ac = { ac_rglr = 0; ac_skip = 0; ac_rdrs = 0; } in
+  let incr_ac skip c =
+    let inc = if c = 'a' then 2 else 1 in
+    if c = 'r' then ac.ac_rdrs <- ac.ac_rdrs + 1;
+    if skip
+    then ac.ac_skip <- ac.ac_skip + inc
+    else ac.ac_rglr <- ac.ac_rglr + inc in
+  let add_conv skip i c =
+    (* Just finishing a meta format: no additional argument to record. *)
+    if c <> ')' && c <> '}' then incr_ac skip c;
+    succ i
+  and add_char i _c = succ i in
+
+  iter_on_format_args fmt add_conv add_char;
+  ac;;
+
+let count_arguments_of_format fmt =
+  let ac = ac_of_format fmt in
+  ac.ac_rglr + ac.ac_skip + ac.ac_rdrs;;
+
+let list_iter_i f l =
+  let rec loop i = function
+    | [] -> ()
+    | [x] -> f i x (* Tail calling [f] *)
+    | x :: xs -> f i x; loop (succ i) xs in
+  loop 0 l;;
+
+(* ``Abstracting'' version of kprintf: returns a (curried) function that
+   will print when totally applied.
+   Note: in the following, we are careful not to be badly caught
+   by the compiler optimizations on the representation of arrays. *)
+let kapr kpr fmt =
+  match count_arguments_of_format fmt with
+  | 0 -> kpr fmt [||]
+  | 1 -> Obj.magic (fun x ->
+           let a = Array.make 1 (Obj.repr 0) in
+           a.(0) <- x;
+           kpr fmt a)
+  | 2 -> Obj.magic (fun x y ->
+           let a = Array.make 2 (Obj.repr 0) in
+           a.(0) <- x; a.(1) <- y;
+           kpr fmt a)
+  | 3 -> Obj.magic (fun x y z ->
+           let a = Array.make 3 (Obj.repr 0) in
+           a.(0) <- x; a.(1) <- y; a.(2) <- z;
+           kpr fmt a)
+  | 4 -> Obj.magic (fun x y z t ->
+           let a = Array.make 4 (Obj.repr 0) in
+           a.(0) <- x; a.(1) <- y; a.(2) <- z;
+           a.(3) <- t;
+           kpr fmt a)
+  | 5 -> Obj.magic (fun x y z t u ->
+           let a = Array.make 5 (Obj.repr 0) in
+           a.(0) <- x; a.(1) <- y; a.(2) <- z;
+           a.(3) <- t; a.(4) <- u;
+           kpr fmt a)
+  | 6 -> Obj.magic (fun x y z t u v ->
+           let a = Array.make 6 (Obj.repr 0) in
+           a.(0) <- x; a.(1) <- y; a.(2) <- z;
+           a.(3) <- t; a.(4) <- u; a.(5) <- v;
+           kpr fmt a)
+  | nargs ->
+    let rec loop i args =
+      if i >= nargs then
+        let a = Array.make nargs (Obj.repr 0) in
+        list_iter_i (fun i arg -> a.(nargs - i - 1) <- arg) args;
+        kpr fmt a
+      else Obj.magic (fun x -> loop (succ i) (x :: args)) in
+    loop 0 [];;
+
+(* Get the index of the next argument to printf. *)
+let next_index n = Sformat.succ_index n;;
+
+(* Decode a format string and act on it.
+   [fmt] is the printf format string, and [pos] points to a [%] character.
+   After consuming the appropriate number of arguments and formatting
+   them, one of the five continuations is called:
+   [cont_s] for outputting a string (args: arg num, string, next pos)
+   [cont_a] for performing a %a action (args: arg num, fn, arg, next pos)
+   [cont_t] for performing a %t action (args: arg num, fn, next pos)
+   [cont_f] for performing a flush action (args: arg num, next pos)
+   [cont_m] for performing a %( action (args: arg num, sfmt, next pos)
+
+   "arg num" is the index in array args of the next argument to printf.
+   "next pos" is the position in [fmt] of the first character following
+   the %conversion specification in [fmt]. *)
+
+(* Note: here, rather than test explicitly against [Sformat.length fmt]
+   to detect the end of the format, we use [Sformat.unsafe_get] and
+   rely on the fact that we'll get a "nul" character if we access
+   one past the end of the string.  These "nul" characters are then
+   caught by the [_ -> bad_conversion] clauses below.
+   Don't do this at home, kids. *)
+let scan_format fmt args n pos cont_s cont_a cont_t cont_f cont_m =
+
+  let get_arg n =
+    Obj.magic (args.(Sformat.int_of_index n)) in
+
+  let rec scan_flags n widths i =
+    match Sformat.unsafe_get fmt i with
+    | '*' ->
+      let (width : int) = get_arg n in
+      scan_flags (next_index n) (width :: widths) (succ i)
+    | '0'..'9'
+    | '.' | '#' | '-' | ' ' | '+' -> scan_flags n widths (succ i)
+    | _ -> scan_conv n widths i
+
+  and scan_conv n widths i =
+    match Sformat.unsafe_get fmt i with
+    | '%' ->
+      cont_s n "%" (succ i)
+    | 's' | 'S' as conv ->
+      let (x : string) = get_arg n in
+      let x = if conv = 's' then x else "\"" ^ String.escaped x ^ "\"" in
+      let s =
+        (* optimize for common case %s *)
+        if i = succ pos then x else
+          format_string (extract_format fmt pos i widths) x in
+      cont_s (next_index n) s (succ i)
+    | 'c' | 'C' as conv ->
+      let (x : char) = get_arg n in
+      let s =
+        if conv = 'c' then String.make 1 x else "'" ^ Char.escaped x ^ "'" in
+      cont_s (next_index n) s (succ i)
+    | 'd' | 'i' | 'o' | 'u' | 'x' | 'X' | 'N' as conv ->
+      let (x : int) = get_arg n in
+      let s =
+        format_int (extract_format_int conv fmt pos i widths) x in
+      cont_s (next_index n) s (succ i)
+    | 'f' | 'e' | 'E' | 'g' | 'G' ->
+      let (x : float) = get_arg n in
+      let s = format_float (extract_format fmt pos i widths) x in
+      cont_s (next_index n) s (succ i)
+    | 'F' ->
+      let (x : float) = get_arg n in
+      cont_s (next_index n) (string_of_float x) (succ i)
+    | 'B' | 'b' ->
+      let (x : bool) = get_arg n in
+      cont_s (next_index n) (string_of_bool x) (succ i)
+    | 'a' ->
+      let printer = get_arg n in
+      let n = Sformat.succ_index n in
+      let arg = get_arg n in
+      cont_a (next_index n) printer arg (succ i)
+    | 't' ->
+      let printer = get_arg n in
+      cont_t (next_index n) printer (succ i)
+    | 'l' | 'n' | 'L' as conv ->
+      begin match Sformat.unsafe_get fmt (succ i) with
+        | 'd' | 'i' | 'o' | 'u' | 'x' | 'X' ->
+          let i = succ i in
+          let s =
+            match conv with
+            | 'l' ->
+              let (x : int32) = get_arg n in
+              format_int32 (extract_format fmt pos i widths) x
+            | 'n' ->
+              let (x : nativeint) = get_arg n in
+              format_nativeint (extract_format fmt pos i widths) x
+            | _ ->
+              let (x : int64) = get_arg n in
+              format_int64 (extract_format fmt pos i widths) x in
+          cont_s (next_index n) s (succ i)
+        | _ ->
+          let (x : int) = get_arg n in
+          let s = format_int (extract_format_int 'n' fmt pos i widths) x in
+          cont_s (next_index n) s (succ i)
+      end
+    | ',' -> cont_s n "" (succ i)
+    | '!' -> cont_f n (succ i)
+    | '{' | '(' as conv (* ')' '}' *) ->
+      let (xf : ('a, 'b, 'c, 'd, 'e, 'f) format6) = get_arg n in
+      let i = succ i in
+      let j = sub_format_for_printf conv fmt i in
+      if conv = '{' (* '}' *) then
+        (* Just print the format argument as a specification. *)
+        cont_s
+          (next_index n)
+          (summarize_format_type xf)
+          j else
+        (* Use the format argument instead of the format specification. *)
+        cont_m (next_index n) xf j
+    | (* '(' *) ')' ->
+      cont_s n "" (succ i)
+    | conv ->
+      bad_conversion_format fmt i conv in
+
+  scan_flags n [] (succ pos);;
+
+(*Trimmed-down version of the legacy lib's [mkprintf]. Most of the generality
+  is lifted to [output] rather than [mkprintf] itself.*)
+let mkprintf k out fmt =
+
+  let rec pr k n fmt v =
+
+    let len = Sformat.length fmt in
+
+    let rec doprn n i =
+      if i >= len then Obj.magic (k out)
+      else             match Sformat.unsafe_get fmt i with
+        | '%' -> scan_format fmt v n i cont_s cont_a cont_t cont_f cont_m
+        |  c  -> write out c; doprn n (succ i)
+    and cont_s n s i =
+      nwrite out s;
+      doprn n i
+    and cont_a n printer arg i =
+      printer out arg;
+      doprn n i
+    and cont_t n printer i =
+      printer out;
+      doprn n i
+    and cont_f n i =
+      flush out;
+      doprn n i
+    and cont_m n xf i =
+      let m = Sformat.add_int_index (count_arguments_of_format xf) n in
+      pr (Obj.magic (fun _ -> doprn m i)) n xf v
+
+    in doprn n 0
+  in let kpr = pr k (Sformat.index_of_int 0) in
+  kapr kpr fmt;;
+
+external identity : 'a -> 'a = "%identity"(*Inlined from [Std] to avoid cyclic dependencies*)
+let fprintf out fmt = mkprintf ignore out fmt
+let printf      fmt = fprintf stdout fmt
+let eprintf     fmt = fprintf stderr fmt
+let ifprintf _  fmt = fprintf stdnull fmt
+let ksprintf2 k fmt =
+  let out = output_string () in
+  mkprintf (fun out -> k (close_out out)) out fmt
+let kbprintf2 k buf fmt =
+  let out = BatBuffer.output_buffer buf in
+  mkprintf (fun _out -> k buf) out fmt
+let sprintf2 fmt = ksprintf2 (identity) fmt
+let bprintf2 buf fmt = kbprintf2 ignore buf fmt
+(**
+   Other possible implementation of [sprintf2],
+   left as example:
+
+   [
+   let sprintf2    fmt =
+   let out = output_string () in
+    mkprintf (fun out -> close_out out) out fmt
+   ]
+*)
+(**
+   Other possible implementation of [bprintf2],
+   left as example:
+   [
+   let bprintf2 buf fmt =
+   let out = output_buffer buf in
+    mkprintf ignore out fmt
+   ]*)
+
+type ('a, 'b, 'c) t = ('a, 'b, 'c) Pervasives.format
+
+let kfprintf        = mkprintf
+let bprintf         = Printf.bprintf
+let sprintf         = Printf.sprintf
+let ksprintf        = Printf.ksprintf
+let kbprintf        = Printf.kbprintf
+let kprintf         = Printf.kprintf
+
+##V<4.2##module CamlinternalPr = Printf.CamlinternalPr

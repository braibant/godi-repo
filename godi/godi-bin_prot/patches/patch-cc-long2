--- lib/common_stubs.h.orig	2013-06-18 22:09:23.000000000 +0000
+++ lib/common_stubs.h	2013-08-06 14:29:24.425400000 +0000
@@ -7,7 +7,14 @@
 #include <sys/types.h>
 
 #include <string.h>
+#ifndef _WIN32
 #include <arpa/inet.h>
+#else
+#ifndef __BYTE_ORDER
+#define __LITTLE_ENDIAN 123
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#endif
+#endif
 #include <stdint.h>
 
 #include <caml/config.h>
@@ -24,6 +31,13 @@
 #include "int64_emul.h"
 #endif
 
+#ifdef ARCH_SIXTYFOUR
+#define NATIVEINT_C INT64_C
+#define UNATIVEINT_C UINT64_C
+#else
+#define NATIVEINT_C INT32_C
+#define UNATIVEINT_C UINT32_C
+#endif
 
 /* Endianness- and alignment-independent integer marshalling functions */
 
@@ -68,15 +82,24 @@
 #endif
 
 #ifndef bswap_32
+#ifdef __MINGW32_
+#define bswap_32 __builtin_bswap32
+#else
 #define bswap_32(value) \
   (((uint32_t) bswap_16(((value) & 0xffff)) << 16) | \
     (uint32_t) bswap_16(((value) >> 16)))
 #endif
+#endif
 
 #ifndef bswap_64
+#ifdef __MINGW32_
+#define bswap_64 __builtin_bswap64
+#else
 #define bswap_64(value) \
   (((uint64_t) bswap_32(((value) & 0xffffffff)) << 32) | \
     (uint64_t) bswap_32(((value) >> 32)))
+
+#endif
 #endif
 
 #if __BYTE_ORDER == __LITTLE_ENDIAN
@@ -221,4 +244,8 @@
 # endif
 #endif
 
+#ifdef _WIN64
+#define long __int64
+#endif
+
 #endif /* COMMON_STUBS_H */
--- lib/read_stubs.c.orig	2013-06-18 22:09:23.000000000 +0000
+++ lib/read_stubs.c	2013-08-06 14:17:21.396600000 +0000
@@ -113,7 +113,7 @@
   MK_SAFE_READ(32, int, 4, {})
 #else
   MK_GEN_SAFE_READ(int, 32, int, 4,
-    if (unlikely(n < -0x40000000l || n > 0x3FFFFFFFl)) {
+    if (unlikely(n < (NATIVEINT_C(-0x40000000)) || n > (NATIVEINT_C(0x3FFFFFFF)))) {
       *sptr_ptr = sptr - 1;
       raise_Error(READ_ERROR_INT_OVERFLOW);
     })
@@ -122,7 +122,7 @@
 
 #ifdef ARCH_SIXTYFOUR
   MK_SAFE_READ(64, long, 8,
-    if (unlikely(n < -0x4000000000000000L || n > 0x3FFFFFFFFFFFFFFFL)) {
+    if (unlikely(n < (NATIVEINT_C(-0x4000000000000000)) || n > (NATIVEINT_C(0x3FFFFFFFFFFFFFFF)))) {
       *sptr_ptr = sptr - 1;
       raise_Error(READ_ERROR_INT_OVERFLOW);
     })
@@ -161,7 +161,7 @@
   MK_SAFE_NAT0_READ(32, int, 4, {})
 #else
   MK_SAFE_NAT0_READ(32, int, 4,
-    if (unlikely(n > 0x3FFFFFFFl)) {
+    if (unlikely(n > (NATIVEINT_C(0x3FFFFFFF)))) {
       *sptr_ptr = sptr - 1;
       raise_Error(READ_ERROR_NAT0_OVERFLOW);
     })
@@ -170,7 +170,7 @@
 
 #ifdef ARCH_SIXTYFOUR
   MK_SAFE_NAT0_READ(64, long, 8,
-    if (unlikely(n > 0x3FFFFFFFFFFFFFFFL)) {
+    if (unlikely(n > (NATIVEINT_C(0x3FFFFFFFFFFFFFFF)))) {
       *sptr_ptr = sptr - 1;
       raise_Error(READ_ERROR_NAT0_OVERFLOW);
     })
@@ -582,15 +582,15 @@
   if (unlikely(next > eptr)) caml_raise_constant(*v_bin_prot_exc_Buffer_short);
 #ifdef ARCH_SIXTYFOUR
   n = le64dec(sptr);
-  if (unlikely(n < -0x4000000000000000L || n > 0x3FFFFFFFFFFFFFFFL))
+  if (unlikely(n < (NATIVEINT_C(-0x4000000000000000)) || n > (NATIVEINT_C(0x3FFFFFFFFFFFFFFF))))
     raise_Error(READ_ERROR_INT_OVERFLOW);
 #else
   n = le32dec(sptr);
   memcpy(&upper, sptr + 4, 4);
-  if (upper == 0l) {
-    if ((unsigned long) n > 0x3FFFFFFFl) raise_Error(READ_ERROR_INT_OVERFLOW);
+  if (upper == (NATIVEINT_C(0))) {
+    if ((unsigned long) n > (NATIVEINT_C(0x3FFFFFFF))) raise_Error(READ_ERROR_INT_OVERFLOW);
   } else if (upper == -1) {
-    if (n < -0x40000000l) raise_Error(READ_ERROR_INT_OVERFLOW);
+    if (n < (NATIVEINT_C(-0x40000000))) raise_Error(READ_ERROR_INT_OVERFLOW);
   }
   else raise_Error(READ_ERROR_INT_OVERFLOW);
 #endif
@@ -638,7 +638,7 @@
   *sptr_ptr = next;
   return (value) Val_int((uint32_t) n);
 #else
-  if (unlikely(n < -0x40000000l || n > 0x3FFFFFFFl))
+  if (unlikely(n < (NATIVEINT_C(-0x40000000)) || n > (NATIVEINT_C(0x3FFFFFFF))))
     raise_Error(READ_ERROR_INT_OVERFLOW);
   *sptr_ptr = next;
   return (value) Val_int(n);
@@ -664,7 +664,7 @@
   if (unlikely(next > eptr)) caml_raise_constant(*v_bin_prot_exc_Buffer_short);
 #ifdef ARCH_SIXTYFOUR
   n = (long) be64dec(sptr);
-  if (unlikely(n < -0x4000000000000000L || n > 0x3FFFFFFFFFFFFFFFL))
+  if (unlikely(n < (NATIVEINT_C(-0x4000000000000000)) || n > (NATIVEINT_C(0x3FFFFFFFFFFFFFFF))))
     raise_Error(READ_ERROR_INT_OVERFLOW);
 #else /* 32bit */
   /* Read the upper 32 bits first.  They must all be zero, otherwise we
@@ -673,7 +673,7 @@
   memcpy(&n, sptr, 4);
   if (n != 0) raise_Error(READ_ERROR_INT_OVERFLOW);
   n = be32dec(sptr + 4);
-  if (unlikely(n < -0x40000000l || n > 0x3FFFFFFFl))
+  if (unlikely(n < (NATIVEINT_C(-0x40000000)) || n > (NATIVEINT_C(0x3FFFFFFF))))
     raise_Error(READ_ERROR_INT_OVERFLOW);
 #endif
   *sptr_ptr = next;
--- lib/write_stubs.c.orig	2013-06-18 22:09:23.000000000 +0000
+++ lib/write_stubs.c	2013-08-06 14:22:52.085400000 +0000
@@ -92,20 +92,20 @@
 
 static inline value write_int_nat0(char *sptr, char *eptr, unsigned long n)
 {
-  if (likely(n < 0x00000080ul)) return write_small_int(sptr, eptr, (char) n);
-  if (likely(n < 0x00008000ul)) return write_int16(sptr, eptr, (short) n);
+  if (likely(n < (UNATIVEINT_C(0x00000080)))) return write_small_int(sptr, eptr, (char) n);
+  if (likely(n < (UNATIVEINT_C(0x00008000)))) return write_int16(sptr, eptr, (short) n);
 #ifdef ARCH_SIXTYFOUR
-  if (unlikely(n >= 0x80000000ul)) return write_int64(sptr, eptr, (long) n);
+  if (unlikely(n >= (UNATIVEINT_C(0x80000000)))) return write_int64(sptr, eptr, (long) n);
 #endif
   return write_int32(sptr, eptr, (int) n);
 }
 
 static inline value write_int_negative(char *sptr, char *eptr, long n)
 {
-  if (likely(n >= -0x00000080l)) return write_neg_int8(sptr, eptr, (char) n);
-  if (likely(n >= -0x00008000l)) return write_int16(sptr, eptr, (short) n);
+  if (likely(n >= (NATIVEINT_C(-0x00000080)))) return write_neg_int8(sptr, eptr, (char) n);
+  if (likely(n >= (NATIVEINT_C(-0x00008000)))) return write_int16(sptr, eptr, (short) n);
 #ifdef ARCH_SIXTYFOUR
-  if (unlikely(n < -0x80000000l)) return write_int64(sptr, eptr, (long) n);
+  if (unlikely(n < (NATIVEINT_C(-0x80000000)))) return write_int64(sptr, eptr, (long) n);
 #endif
   return write_int32(sptr, eptr, (int) n);
 }
@@ -128,10 +128,10 @@
 
 static inline value write_nat0(char *sptr, char *eptr, unsigned long n)
 {
-  if (likely(n < 0x00000080ul)) return write_small_int(sptr, eptr, (char) n);
-  if (likely(n < 0x00010000ul)) return write_int16(sptr, eptr, (short) n);
+  if (likely(n < (UNATIVEINT_C(0x00000080)))) return write_small_int(sptr, eptr, (char) n);
+  if (likely(n < (UNATIVEINT_C(0x00010000)))) return write_int16(sptr, eptr, (short) n);
 #ifdef ARCH_SIXTYFOUR
-  if (unlikely(n >= 0x100000000UL)) return write_int64(sptr, eptr, (long) n);
+  if (unlikely(n >= (UNATIVEINT_C(0x100000000)))) return write_int64(sptr, eptr, (long) n);
 #endif
   return write_int32(sptr, eptr, (int) n);
 }
@@ -167,22 +167,22 @@
 
 static inline value write_int64_type_nat0(char *sptr, char *eptr, int64 n)
 {
-  if (likely((I64_compare(n, I64_literal(0, 0x00000080l)) < 0)))
+  if (likely((I64_compare(n, I64_literal(0, (NATIVEINT_C(0x00000080)))) < 0)))
     return write_small_int(sptr, eptr, (char) I64_to_int32(n));
-  if (likely(I64_compare(n, I64_literal(0, 0x00008000l)) < 0))
+  if (likely(I64_compare(n, I64_literal(0, (NATIVEINT_C(0x00008000)))) < 0))
     return write_int16(sptr, eptr, (short) I64_to_int32(n));
-  if (unlikely(I64_compare(n, I64_literal(0, 0x80000000l)) >= 0))
+  if (unlikely(I64_compare(n, I64_literal(0,(NATIVEINT_C(0x80000000)))) >= 0))
     return write_int64_type(sptr, eptr, n);
   return write_int32(sptr, eptr, (int) I64_to_int32(n));
 }
 
 static inline value write_int64_type_negative(char *sptr, char *eptr, int64 n)
 {
-  if (likely(I64_compare(n, I64_literal(0xFFFFFFFF, -0x00000080l)) >= 0))
+  if (likely(I64_compare(n, I64_literal(0xFFFFFFFF, (NATIVEINT_C(-0x00000080)))) >= 0))
     return write_neg_int8(sptr, eptr, (char) I64_to_int32(n));
-  if (likely(I64_compare(n, I64_literal(0xFFFFFFFF, -0x00008000l)) >= 0))
+  if (likely(I64_compare(n, I64_literal(0xFFFFFFFF, (NATIVEINT_C(-0x00008000)))) >= 0))
     return write_int16(sptr, eptr, (short) I64_to_int32(n));
-  if (unlikely(I64_compare(n, I64_literal(0xFFFFFFFF, -0x80000000l)) < 0))
+  if (unlikely(I64_compare(n, I64_literal(0xFFFFFFFF, (NATIVEINT_C(-0x80000000)))) < 0))
     return write_int64_type(sptr, eptr, n);
   return write_int32(sptr, eptr, I64_to_int32(n));
 }
@@ -224,7 +224,7 @@
   char *str = String_val(v_str);
   unsigned long len = caml_string_length(v_str);
   char *next, *dst;
-  if (likely(len < 0x00000014ul)) {
+  if (likely(len < (UNATIVEINT_C(0x00000014)))) {
     /* Speedup for copying small strings */
     dst = sptr + 1;
     next = dst + len;
@@ -235,7 +235,7 @@
       do dst[len] = str[len]; while (likely(len-- != 0));
     return (value) next;
   }
-  if (likely(len < 0x00000080ul)) {
+  if (likely(len < (UNATIVEINT_C(0x00000080)))) {
     dst = sptr + 1;
     next = dst + len;
     if (unlikely(next > eptr))
@@ -244,7 +244,7 @@
     memcpy(dst, str, (size_t) len);
     return (value) next;
   }
-  if (likely(len < 0x00010000ul)) {
+  if (likely(len < (UNATIVEINT_C(0x00010000)))) {
     dst = sptr + 3;
     next = dst + len;
     if (unlikely(next > eptr))
@@ -254,7 +254,7 @@
     return (value) next;
   }
 #ifdef ARCH_SIXTYFOUR
-  if (unlikely(len >= 0x100000000UL)) {
+  if (unlikely(len >= (UNATIVEINT_C(0x100000000)))) {
     dst = sptr + 9;
     next = dst + len;
     if (unlikely(next > eptr))
@@ -296,7 +296,7 @@
   unsigned long len = wlen / Double_wosize;
   unsigned long tot_size = len * sizeof(double);
   char *next, *dst;
-  if (likely(len < 0x00000080ul)) {
+  if (likely(len < (UNATIVEINT_C(0x00000080)))) {
     dst = (char *) sptr + 1;
     next = dst + tot_size;
     if (unlikely(next > eptr))
@@ -305,7 +305,7 @@
     memcpy(dst, src, (size_t) tot_size);
     return (value) next;
   }
-  if (likely(len < 0x00010000ul)) {
+  if (likely(len < (UNATIVEINT_C(0x00010000)))) {
     dst = (char *) sptr + 3;
     next = dst + tot_size;
     if (unlikely(next > eptr))
@@ -315,7 +315,7 @@
     return (value) next;
   }
 #ifdef ARCH_SIXTYFOUR
-  if (likely(len >= 0x100000000UL)) {
+  if (likely(len >= (UNATIVEINT_C(0x100000000)))) {
     dst = (char *) sptr + 9;
     next = dst + tot_size;
     if (unlikely(next > eptr))
@@ -375,7 +375,7 @@
   void *sptr, char *eptr, void *src, unsigned long len, size_t tot_size)
 {
   char *next, *dst;
-  if (likely(len < 0x00000080ul)) {
+  if (likely(len < (UNATIVEINT_C(0x00000080)))) {
     dst = ((char *) sptr) + 1;
     next = dst + tot_size;
     if (unlikely(next > eptr))
@@ -384,7 +384,7 @@
     memcpy(dst, src, tot_size);
     return (value) next;
   }
-  if (likely(len < 0x00010000ul)) {
+  if (likely(len < (UNATIVEINT_C(0x00010000)))) {
     dst = (char *) sptr + 3;
     next = dst + tot_size;
     if (unlikely(next > eptr))
@@ -394,7 +394,7 @@
     return (value) next;
   }
 #ifdef ARCH_SIXTYFOUR
-  if (unlikely(len >= 0x100000000UL)) {
+  if (unlikely(len >= (UNATIVEINT_C(0x100000000)))) {
     dst = (char *) sptr + 9;
     next = dst + tot_size;
     if (unlikely(next > eptr))
@@ -497,7 +497,7 @@
 #else
   {
     long n = Long_val(v_n);
-    long tmp = (n < 0) ? 0xFFFFFFFFl : 0l;
+    long tmp = (n < 0) ? (UNATIVEINT_C(0xFFFFFFFF)) : (NATIVEINT_C(0));
     le32enc(sptr, n);
     memcpy(sptr + 4, &tmp, sizeof(long));
   }

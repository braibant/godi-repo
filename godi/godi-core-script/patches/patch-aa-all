diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/console/cmd.ml ./console-src/console/cmd.ml
--- ../godi-tools-3.0.18.orig/console-src/console/cmd.ml	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/console/cmd.ml	2012-11-01 12:29:39.000000000 +0100
@@ -17,7 +17,7 @@
 
 exception Exit_code of int
 
-
+let () = Init.init_netdb () 
 
 let usage() =
   prerr_endline ("usage: godi_console [<command> [<options>]]\n" ^
@@ -27,7 +27,7 @@
 		 "  wish - Manipulate the list of user's wishes\n" ^
 		 "  perform - Install or remove packages\n" ^
 		 "  list - List packages by criterion\n" ^
-		 "  info - Show details about installed package or tgz file\n" ^
+		 "  info - Show details about installed package or txz file\n" ^
                  "  dep - Check dependency on installed package\n" ^ 
 		 "  delete - Remove packages (godi_delete backend)\n" ^
 		 "  add - Install binary packages (godi_add backend)\n" ^ 
@@ -555,7 +555,7 @@
 	"-remove", Arg.String (word_by_word add_remove_wish),
 	        "<pkg>                Remove <pkg>";
 	"-add", Arg.String add_package,
-	     "<tgzfile>               Add binary package <tgzfile> (may be a URL)";
+	     "<txzfile>               Add binary package <txzfile> (may be a URL)";
 	"-option", Arg.String add_option,
 	        "<pkg>:<name>=<val>   Set option <name>=<val> for <pkg>";
 	"-wishes", Arg.Unit add_wishes,
@@ -1509,7 +1509,7 @@
   let parse_selector s =
     if ( Filename.is_implicit s &&
            not(Godi_file_handler.is_url s) &&
-           not (Filename.check_suffix s ".tgz")
+           not (Filename.check_suffix s ".txz")
        )
     then
       `Dep(Godi_versions.parse_dependency ~sloppy:true s)
@@ -1539,7 +1539,7 @@
       (fun s -> 
 	 package_selectors := 
            !package_selectors @ [parse_selector s])
-    (helptext "[<options>] <pkgfile.tgz> or <URL> or <dep>...");
+    (helptext "[<options>] <pkgfile.txz> or <URL> or <dep>...");
 
   let message = printmsg con in
   let inst_pkgs = get_installed_packages ~verbose:!verbose con in
@@ -1732,7 +1732,7 @@
 
         "-in-binary",
         Arg.String (fun s -> only_one_input(); input := Some(`Binary s)),
-        "<file.tgz>  Process this binary package";
+        "<file.txz>  Process this binary package";
 
 	"-fixup-symlinks",
 	Arg.Set fixup_symlinks,
@@ -1894,7 +1894,7 @@
 	"<file>   Set the deinstall script from a file";
 
       ]
-    (fun s -> raise(Arg.Bad "Unexpected argument"))
+    (fun s -> raise(Arg.Bad ("Unexpected argument(" ^ s ^ ")" )))
     (helptext "<option>...");
 
   if !input = None then
@@ -1987,7 +1987,7 @@
 	       (Godi_file.filename dir)
                (Godi_query.binary_file_base in_pkg)
 	    )
-	    ".tgz" in
+	    ".txz" in
 	let out_pkg =
 	  Godi_ptool.binary_of_dispersed_package con out_file_name in_pkg in
         let n = Godi_file.slashname (binary_pkg out_pkg)#binary_archive in
@@ -2294,13 +2294,6 @@
 
   let makefile = ref None in
 
-  (* This is portable *)
-  if Sys.file_exists "makefile" then
-    makefile := Some "makefile"
-  else
-    if Sys.file_exists "Makefile" then
-      makefile := Some "Makefile";
-
   let inc_dirs = ref [ Godi_file.filename "." ] in
   let sys_inc_dirs = ref [] in
   let global_ignore_flag = ref false in
@@ -2402,6 +2395,30 @@
 	 Godi_file.chdir (Godi_file.filename d)
   );
 
+
+  (* I moved it below chdir and argument parsing
+     - it's unneccessary to call Sys.file_exist if
+        -f ... is specified
+     - it's consistent with how gnu make and
+       freebsd-make locate the Makefile to use
+     - godi_make's solution was inconsistent anyway
+       because the new directory wasn't appended to 
+       the reference makefile
+   *)
+  (match !makefile with
+   | Some _ -> ()
+   | None ->
+    (* This is portable *)
+     if Sys.file_exists "makefile" then
+       makefile := Some "makefile"
+     else
+       if Sys.file_exists "Makefile" then
+        makefile := Some "Makefile";
+  );
+
+
+
+
   let ctx =
     Godi_make.create_context
       ~override:!override
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/console/Makefile.code ./console-src/console/Makefile.code
--- ../godi-tools-3.0.18.orig/console-src/console/Makefile.code	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/console/Makefile.code	2012-11-01 12:29:51.000000000 +0100
@@ -7,9 +7,11 @@
 
 REQUIRES = unix str shell netstring $(WTOOL_REQUIRES)
 
-BOOT_OBJ = cmd.cmo boot_main.cmo
-OBJ = cmd.cmo main.cmo
+BOOT_OBJ = init.cmo cmd.cmo boot_main.cmo
+OBJ = init.cmo cmd.cmo main.cmo
 XOBJ = $(OBJ:.cmo=.cmx)
+XBOOT_OBJ = $(BOOT_OBJ:.cmo=.cmx)
+
 
 # Note: the -custom flag for godi_console is very important, because this
 # avoids any run-time dependencies!
@@ -37,13 +39,13 @@
        zip.cmxa load_gzip.cmx
 
 godi_console: $(OBJ) $(LIBS) $(UILIBS) ../godi-gzip/load_gzip.cmo
-	$(OCAMLC) -package netstring,str -o godi_console \
+	$(OCAMLC) -package netstring,str -o godi_console_byte$(EXE) \
 		-custom -linkpkg $(THREAD) $(LIBS) $(UILIBS) $(GZIP) $(OBJ)
 	rm -f godi_console_dev
 	ln -s godi_console godi_console_dev
 
 godi_console.opt: $(XOBJ) $(XLIBS) $(XUILIBS) ../godi-gzip/load_gzip.cmx
-	$(OCAMLOPT) -package netstring,str -o godi_console.opt \
+	$(OCAMLOPT) -package netstring,str -o godi_console$(EXE) \
 		-linkpkg $(THREAD) $(XLIBS) $(XUILIBS) $(XGZIP) $(XOBJ)
 
 .PHONE: generate
@@ -61,6 +63,14 @@
 	$(OCAMLC) -o boot_console.runtime -make-runtime -linkpkg \
 		-package "$(REQUIRES)" -predicates nonetaccel digest.cma
 
+win_boot_console: $(BOOT_OBJ) $(LIBS) ../godi-gzip/load_gzip.cmo
+	$(OCAMLC) -package netstring,str -o boot_console$(EXE) \
+		-custom -linkpkg $(THREAD) $(LIBS) $(GZIP) $(BOOT_OBJ)
+
+win_boot_console.opt: $(XBOOT_OBJ) $(XLIBS) ../godi-gzip/load_gzip.cmx
+	$(OCAMLOPT) -package netstring,str -o boot_console$(EXE) \
+		        -linkpkg $(THREAD) $(XLIBS) $(XGZIP) $(XBOOT_OBJ)
+
 #----------------------------------------------------------------------
 # general rules:
 
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-pax/pax_cmd.ml ./console-src/godi-pax/pax_cmd.ml
--- ../godi-tools-3.0.18.orig/console-src/godi-pax/pax_cmd.ml	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-pax/pax_cmd.ml	2012-11-01 12:21:44.000000000 +0100
@@ -206,6 +206,9 @@
       "-j", `Unit(fun () -> compression := `Bzip2),
       "Process bzip2-compressed archives";
 
+      "-J", `Unit(fun () -> compression := `Xz),
+      "Process xz-compressed archives";
+
       "-k", `Set noreplace_flag,
       "Do not overwrite files";
 
@@ -307,6 +310,10 @@
 			`Tar, `Bzip2
 		      else if Filename.check_suffix name ".tbz2" then
 			`Tar, `Bzip2
+		      else if Filename.check_suffix name ".tar.xz" then
+			`Tar, `Xz
+		      else if Filename.check_suffix name ".txz" then
+			`Tar, `Xz
 		      else
 			failwith("Cannot determine format. Specify -x")
 		    in
@@ -473,8 +480,68 @@
 		Pax.file_iterator_of_list
 		  ~nodescent:!nodescent_flag
 		  file_args in
-	    let cp = Pax.create_copier() in
+            begin match overwrite with
+            | `Always ->
+              let tmpfile1 =
+                Filename.temp_file
+                  "files"
+                  ".txt"
+              in
+              Pax.try_finally ( fun tmpfile1 ->
+                let och = Pervasives.open_out_gen
+                  [Open_wronly; Open_creat; Open_binary]
+                  0o0600
+                  tmpfile1
+                in
+                Pax.try_finally ( fun ch ->
+                  let cont = ref true in
+                  while !cont do
+ 	            match Pax.next_file iter with
+                    | None -> cont:=false;
+ 		    | Some filename ->
+                      Pervasives.output_string ch filename;
+                      Pervasives.output_char ch '\000';
+                  done;
+                ) och ( fun ch -> Pervasives.close_out ch ) och ;
 
+                let tmpfile =
+                  Filename.temp_file
+                    ~temp_dir:(Godi_file.nativename (Godi_file.filename "/tmp"))
+                    "copy"
+                    ".sh"
+                in
+                Pax.try_finally ( fun tmpfile ->
+                  let ch_closed = ref false
+                  and ch = Godi_file.open_out_gen
+                    [Open_wronly; Open_creat; Open_binary]
+                    0o0600
+                    (Godi_file.filename tmpfile)
+                  in
+                  Pax.try_finally ( fun ch ->
+                    let cpio = Pax.filename_quote_shell
+                      (Godi_file.filename Godi_conf.cmd_cpio)
+                    and bsdtar = Pax.filename_quote_shell
+                      (Godi_file.filename Godi_conf.cmd_bsdtar)
+                    in
+                    Pervasives.output_string ch "#!/bin/bash\n" ;
+                    Pervasives.output_string ch cpio ;
+ 	            Pervasives.output_string ch " -o -L --null --quiet --format=ustar | " ;
+                    Pervasives.output_string ch bsdtar;
+                    Pervasives.output_string ch " -C ";
+                    Pervasives.output_string ch (Pax.filename_quote_shell ~native:true dir_arg);
+                    Pervasives.output_string ch " -x --no-same-owner --no-same-permissions -f- \n exit $?";
+                    ch_closed:=true;
+                    Pervasives.close_out ch;
+                    let tmpfile_cygwin = "/tmp/" ^ (Filename.basename tmpfile ) in
+                    Godi_exec.call_cmd
+                      ~stdin:(`File (Godi_file.filename tmpfile1) )
+                      ((Godi_file.nativename (Godi_file.filename Godi_conf.cmd_shell)),
+                       [| tmpfile_cygwin |]) ;
+                  ) ch ( fun ch -> if not !ch_closed then Pervasives.close_out ch ) ch
+                ) tmpfile ( fun tmpfile -> Sys.remove tmpfile ) tmpfile
+              ) tmpfile1 ( fun tmpfile1 -> Sys.remove tmpfile1 ) tmpfile1
+            | _ ->
+	      let cp = Pax.create_copier() in
 	    let cont = ref true in
 	    while !cont do
 	      match Pax.next_file iter with
@@ -496,6 +563,7 @@
 		    cont := false
 	    done;
 	    Pax.postprocess_copying cp
+            end;
     with
       | Failure msg ->
 	  prerr_endline msg;
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-pax/pax.ml ./console-src/godi-pax/pax.ml
--- ../godi-tools-3.0.18.orig/console-src/godi-pax/pax.ml	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-pax/pax.ml	2012-11-01 12:28:45.000000000 +0100
@@ -36,6 +36,7 @@
     [ `None
     | `Gzip
     | `Bzip2
+    | `Xz
     ]
 
 type format =
@@ -73,67 +74,36 @@
   Godi_file.filename path
 )
 
+let xz_cmd = lazy (
+  let path =
+    Godi_conf.cmd_xz in
+  Godi_file.filename path
+)
+
 
 let mk_gzip_cmd filename_opt  =
   let cmd_path = Godi_file.nativename (Lazy.force gzip_cmd) in
-  sprintf "%s -c >%s"
-    cmd_path
-    (match filename_opt with
-       | None -> ""
-       | Some fn -> 
-	   let name' = Filename.quote fn in
-	   if fn <> "" && fn.[0] = '-' then
-	     "-- "  ^ name'
-	   else
-	     name'
-    )
-
-
+  cmd_path,["-c"],filename_opt
 
 let mk_gunzip_cmd filename_opt =
   let cmd_path = Godi_file.nativename (Lazy.force gzip_cmd) in
-  sprintf "%s -cd %s"
-    cmd_path
-    (match filename_opt with
-       | None -> ""
-       | Some fn -> 
-	   let name' = Filename.quote fn in
-	   if fn <> "" && fn.[0] = '-' then
-	     "-- "  ^ name'
-	   else
-	     name'
-    )
+  cmd_path,["-c";"-d"],filename_opt
 
+let mk_xz_cmd filename_opt  =
+  let cmd_path = Godi_file.nativename (Lazy.force xz_cmd) in
+  cmd_path,["-c"],filename_opt
+
+let mk_unxz_cmd filename_opt =
+  let cmd_path = Godi_file.nativename (Lazy.force xz_cmd) in
+  cmd_path,["-c";"-d"],filename_opt
 
 let mk_bzip2_cmd filename_opt  =
   let cmd_path = Godi_file.nativename (Lazy.force bzip2_cmd) in
-  sprintf "%s -c >%s"
-    cmd_path
-    (match filename_opt with
-       | None -> ""
-       | Some fn -> 
-	   let name' = Filename.quote fn in
-	   if fn <> "" && fn.[0] = '-' then
-	     "-- "  ^ name'
-	   else
-	     name'
-    )
-
-
+  cmd_path,["-c"],filename_opt
 
 let mk_bunzip2_cmd filename_opt =
   let cmd_path = Godi_file.nativename (Lazy.force bzip2_cmd) in
-  sprintf "%s -cd %s"
-    cmd_path
-    (match filename_opt with
-       | None -> ""
-       | Some fn -> 
-	   let name' = Filename.quote fn in
-	   if fn <> "" && fn.[0] = '-' then
-	     "-- "  ^ name'
-	   else
-	     name'
-    )
+  cmd_path,["-c";"-d"],filename_opt
 
 
 let string_of_exit_code =
@@ -143,8 +113,19 @@
     | Unix.WSTOPPED n -> "WSTOPPED " ^ string_of_int n
 
 
-class input_command cmd =
-  let ch = Unix.open_process_in cmd in
+class input_command (prog,args,file) =
+  let pid,ch =
+    let stdin = match file with
+    | None -> Unix.stdin
+    | Some x -> Unix.openfile x [ Unix.O_RDONLY ] 0o666
+    in
+    let (out_read, out_write) = Unix.pipe() in
+    Unix.set_close_on_exec out_read;
+    let pid = Unix.create_process prog (Array.of_list args) stdin out_write Unix.stderr in
+    Unix.close out_write;
+    if file <> None then Unix.close stdin;
+    pid,(Unix.in_channel_of_descr out_read)
+  in
 object (self)
   inherit Netchannels.input_channel ch as super
 
@@ -154,13 +135,15 @@
     if not closed then (
       Pax_tar.skip (self :> Netchannels.in_obj_channel);
         (* skip over all remaining data *)
-      let p = Unix.close_process_in ch in
+      close_in ch;
+      let pid',p = Unix.waitpid [] pid in
+      assert (pid = pid');
       closed <- true;
       if p <> Unix.WEXITED 0 then
         let msg =
-          sprintf "Command returns abnormally (%s): %s"
+          Printf.sprintf "Command returns abnormally (%s): %s %s"
             (string_of_exit_code p)
-            cmd in
+            prog (String.concat " " args) in
         let ign =
           try Sys.getenv "GODI_IGNORE_GZIP_ERROR" = "true"
           with _ -> false in
@@ -173,9 +156,18 @@
 end
 ;;
 
-
-class output_command cmd =
-  let ch = Unix.open_process_out cmd in
+class output_command (prog,args,outfile) =
+  let pid,ch =
+    let fd = match outfile with
+    | Some outfile -> Unix.openfile outfile [ Unix.O_WRONLY ; Unix.O_CREAT ] 0o666
+    | None -> Unix.stdout
+    and (out_read, out_write) = Unix.pipe() in
+    Unix.set_close_on_exec out_write;
+    let pid = Unix.create_process prog (Array.of_list args) out_read fd Unix.stderr in
+    if outfile <> None then Unix.close fd;
+    Unix.close out_read;
+    pid,(Unix.out_channel_of_descr out_write)
+  in
 object (self)
   inherit Netchannels.output_channel ch as super
 
@@ -183,13 +175,16 @@
 
   method close_out() =
     if not closed then (
-      let p = Unix.close_process_out ch in
+      flush ch;
+      close_out ch;
+      let pid',p = Unix.waitpid [] pid in
+      assert (pid = pid');
       closed <- true;
       if p <> Unix.WEXITED 0 then
         raise (Sys_error(
-                 sprintf "Command returns abnormally (%s): %s"
+          Printf.sprintf "Command returns abnormally (%s): %s %s"
                    (string_of_exit_code p)
-                   cmd))
+            prog (String.concat " " args)))
     )
 end
 ;;
@@ -254,7 +249,15 @@
       | `Stdin,`Bzip2 ->
 	  let ch = new input_command (mk_bunzip2_cmd None) in
 	  (ch, (fun () -> ch#close_in()))
-      | (`Obj_channel _), (`Gzip | `Bzip2) ->
+      | (`File name), `Xz ->
+	let ch =
+	  new input_command
+            (mk_unxz_cmd (Some (Godi_file.nativename name))) in
+	(ch, (fun () -> ch#close_in()))
+      | `Stdin,`Xz ->
+	let ch = new input_command (mk_unxz_cmd None) in
+	(ch, (fun () -> Pax_tar.skip ch; ch#close_in()))
+      | (`Obj_channel _), (`Gzip | `Bzip2 | `Xz) ->
 	  failwith 
 	    "Pax.read: object channels are incompatible with compression"
   in
@@ -633,7 +636,15 @@
       | `Stdout,`Bzip2 ->
 	  let ch = new output_command (mk_bzip2_cmd None) in
 	  (ch, ch#close_out)
-      | (`Obj_channel _), (`Gzip | `Bzip2) ->
+      | (`File name), `Xz ->
+	  let ch =
+	    new output_command
+              (mk_xz_cmd (Some (Godi_file.nativename name))) in
+	  (ch, ch#close_out)
+      | `Stdout,`Xz ->
+	  let ch = new output_command (mk_xz_cmd None) in
+	  (ch, ch#close_out)
+      | (`Obj_channel _), (`Gzip | `Bzip2 | `Xz) ->
 	  failwith 
 	    "Pax.create: object channels are incompatible with compression"
   in
@@ -878,3 +889,70 @@
 
 let postprocess_copying cp =
   postprocess_ht cp.cp_postprocess
+
+
+let try_finally f p g o =
+  let module T = struct
+    type 'a t =
+    | Ok of 'a
+    | Err of exn
+  end in
+  let erg = try T.Ok ( f p ) with x -> T.Err x in
+  g o;
+  match erg with
+  | T.Ok x -> x
+  | T.Err x -> raise x
+
+
+let filename_quote_shell ?(native=true) fln =
+  let str = match native with
+  | false -> Godi_file.slashname fln
+  | true ->  Godi_file.nativename fln
+  in
+  let len = String.length str in
+  let buf = Buffer.create (len + 5) in
+  Buffer.add_char buf '\"';
+  for i = 0 to len - 1 do
+    let cur = str.[i] in
+    (match cur with
+    | '\"' | '\\' -> Buffer.add_char buf '\\';
+    | _ -> ());
+    Buffer.add_char buf cur;
+  done;
+  Buffer.add_char buf '\"';
+  Buffer.contents buf
+;;
+
+
+type copier_fast = {
+  ch: out_channel ;
+  fln: string ;
+  src_prefix: Godi_file.filename;
+  dst_prefix: string;
+}
+
+let create_copier_fast ~src_prefix ~dst_prefix =
+  let () = Godi_file.create_dir ~recurse:true dst_prefix in
+  let fln = Filename.temp_file "list" ".txt"
+  and dst_prefix = Godi_file.nativename dst_prefix
+  in
+  let ch = Pervasives.open_out_gen
+    [Open_wronly; Open_creat; Open_binary]
+    0o0600
+    fln
+  in
+  { ch; fln; src_prefix ; dst_prefix }
+
+let copy_file_fast (x:copier_fast) src =
+  Pervasives.output_string x.ch src ;
+  Pervasives.output_char x.ch '\000'
+
+let postprocess_copying_fast x =
+  try_finally ( fun x ->
+    Pervasives.close_out x.ch;
+    Godi_exec.call_cmd
+      ~cd:x.src_prefix
+      ~stdin:(`File (Godi_file.filename x.fln))
+      ((Godi_file.nativename (Godi_file.filename Godi_conf.cmd_bsdcpio)),
+       [| "--quiet" ; "-pmud0" ; x.dst_prefix |]) ;
+  ) x ( fun x -> Sys.remove x.fln ) x
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-pax/pax.mli ./console-src/godi-pax/pax.mli
--- ../godi-tools-3.0.18.orig/console-src/godi-pax/pax.mli	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-pax/pax.mli	2012-11-01 12:28:51.000000000 +0100
@@ -36,6 +36,7 @@
     [ `None
     | `Gzip
     | `Bzip2
+    | `Xz
     ]
 
 type format =
@@ -221,3 +222,13 @@
 
 val read_gzip : (string option -> Netchannels.in_obj_channel) ref
 val write_gzip : (string option -> Netchannels.out_obj_channel) ref
+
+
+type copier_fast
+
+val copy_file_fast: copier_fast ->  string -> unit
+val create_copier_fast : src_prefix:Godi_file.filename -> dst_prefix:Godi_file.filename -> copier_fast
+val postprocess_copying_fast : copier_fast -> unit
+
+val try_finally: ('a -> 'b) -> 'a -> ('c -> 'd) -> 'c -> 'b
+val filename_quote_shell: ?native:bool -> Godi_file.filename -> string
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-pkg/godi_perform.ml ./console-src/godi-pkg/godi_perform.ml
--- ../godi-tools-3.0.18.orig/console-src/godi-pkg/godi_perform.ml	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-pkg/godi_perform.ml	2012-11-01 12:28:53.000000000 +0100
@@ -457,12 +457,13 @@
 ;;
 
 
+(*
 let extract_binary_archive con bin_arch =
   (* Extract the archive file, and put the contents into a temporary
    * directory. Returns the handle of this directory.
    *)
   let bin_stage = Godi_file.allocate_tmpdir() in
-  let ar = Pax.read (`File bin_arch) `Gzip `Tar in
+  let ar = Pax.read (`File bin_arch) `Xz `Tar in
   let cont = ref true in
   while !cont do
     match Pax.read_element ar with
@@ -477,6 +478,20 @@
   Pax.close_in ar;
   bin_stage
 ;;
+*)
+
+(* use real tar for faster results *)
+let extract_binary_archive con bin_arch =
+  let bin_stage = Godi_file.allocate_tmpdir() in
+  let fn = Godi_file.nativename bin_arch
+  and dir = Godi_file.nativename (Godi_file.tmpdir_path bin_stage ) in
+  Godi_exec.call_cmd
+    ~stdout:con.protocol
+    ~stderr:`Like_stdout
+    ((Godi_file.nativename (Godi_file.filename Godi_conf.cmd_bsdtar)),
+     [| "-C"; dir ; "-x" ; "--no-same-owner" ; "--no-same-permissions";  "-f"; fn |]) ;
+  bin_stage
+;;
 
 
 let delete_installed_files prefix l =
@@ -556,7 +571,8 @@
 	  Not_found ->
 	    file_list_map := StrMap.add prefix (ref [line]) !file_list_map
     in
-
+    (* This is too slow for big binary archives *)
+    (*
     (* Iterate over the plist in a first pass, and check the integrity: *)
     List.iter
       (function
@@ -595,6 +611,7 @@
 	     ()
       )
       plist;
+    *)
 
     (* Further variables for PLIST interpretation: *)
     let prefix = ref "" in
@@ -730,23 +747,21 @@
 		   !file_list_map) :: !onerror;
 	    StrMap.iter
 	      (fun list_prefix rev_list ->
-		 let cp = Pax.create_copier() in
-		 let iter =
-		   Pax.file_iterator_of_list (List.rev !rev_list) in
+		let cp = Pax.create_copier_fast
+                  ~src_prefix:bin_stage_path
+                  ~dst_prefix:(Godi_file.filename list_prefix)
+                in
+		let iter = Pax.file_iterator_of_list
+                  (List.rev !rev_list)
+                in
 		 let cont = ref true in
 		 while !cont do
 		   match Pax.next_file iter with
 		     | None -> cont := false
 		     | Some n ->
-			 Pax.copy_file
-			   ~prefer_link:true
-			   ~src_prefix:bin_stage_path
-			   ~preserve_mtime:true
-			   cp
-			   n
-			   (Godi_file.filename list_prefix)
+                    Pax.copy_file_fast cp n
 		 done;
-		 Pax.postprocess_copying cp
+	        Pax.postprocess_copying_fast cp
 	      )
 	      !file_list_map;
 
@@ -839,6 +854,11 @@
   (installed_pkg inst_pkg) # update_successor_file con
 ;;
 
+let release_tmpdir_fast dir =
+  Godi_exec.call_cmd
+    ((Godi_file.nativename (Godi_file.filename Godi_conf.cmd_rm)),
+     [| "-rf"; Godi_file.slashname (Godi_file.tmpdir_path dir) |]) ;;
+
 
 let add_pkg ?(mode = `Normal)
             con pkg =
@@ -869,7 +889,7 @@
     onerror := (fun () -> bin_pkg # release_binary_archive()) :: !onerror;
 
     let bin_stage = extract_binary_archive con bin_arch in
-    onerror := (fun () -> Godi_file.release_tmpdir bin_stage) :: !onerror;
+    onerror := (fun () -> release_tmpdir_fast bin_stage) :: !onerror;
 
     let plist = get_binary_plist bin_stage in
 
@@ -941,7 +961,7 @@
     );
 
     (* Cleanup: *)
-    Godi_file.release_tmpdir bin_stage;
+    release_tmpdir_fast bin_stage;
     bin_pkg # release_binary_archive();
     onerror := [];
 
@@ -1177,7 +1197,7 @@
 		       let cmd2 = sprintf "%s add %s\n"
 			 (Godi_file.slashname self_copy)
 			 (Godi_file.uquote (Godi_file.slashname sup)) in
-		       let sh_cmd = cmd1 ^ cmd2 in
+		       let sh_cmd = "export GODI_TOOL_SELF_UPDATE=1\n" ^ cmd1 ^ cmd2 in
 		       raise (Restart_recommended sh_cmd)
 	       )
 	       else (
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-pkg/godi_ptool.ml ./console-src/godi-pkg/godi_ptool.ml
--- ../godi-tools-3.0.18.orig/console-src/godi-pkg/godi_ptool.ml	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-pkg/godi_ptool.ml	2012-11-01 12:28:55.000000000 +0100
@@ -531,32 +531,71 @@
     | None ->
 	failwith "Godi_ptool.binary_of_dispersed_package"
     | Some root ->
-	let ar = Pax.create (`File out_file) `Gzip `Tar in
-	let now = Int64.of_float(Unix.time()) in
-
-	(* Append the meta data first. *)
-	List.iter
-	  (fun (n,v) ->
-	     Pax.add_element_from_string
-	       ~name:n
-	       ~mode:0o444
-	       ~mtime:now
-	       ~filetype:`Regular
-	       ar
-	       v
-	  )
-	  dpkg#meta_data;
-
-	(* Append package contents *)
-	List.iter
-	  (fun file ->
-	     Pax.add_element_from_file
-	       ~prefix:root
-	       ar
-	       file
-	  )
-	  dpkg # dispersion # files;
-
-	Pax.close_out ar;
+      let tmp_dir = Godi_file.allocate_tmpdir () in
+      Pax.try_finally ( fun tmp_dir ->
+        let p_tmp_dir = Godi_file.tmpdir_path tmp_dir in
+        let file_list = Godi_file.addname p_tmp_dir "files"
+        and file_list_meta = Godi_file.addname p_tmp_dir "meta_files" in
+        let fch_closed = ref false in
+        let fch = Godi_file.open_out_gen
+          [Open_wronly; Open_creat; Open_binary]
+          0o444
+          file_list
+        in
+        Pax.try_finally ( fun fch ->
+          let fchm_closed = ref false in
+          let fchm = Godi_file.open_out_gen
+            [Open_wronly; Open_creat; Open_binary]
+            0o444
+            file_list_meta
+          in
+          Pax.try_finally ( fun fchm ->
+            let to_file (n,v) =
+              let n' = Godi_file.addname p_tmp_dir n in
+              let och = Godi_file.open_out_gen
+                [Open_wronly; Open_creat; Open_binary]
+                0o444
+                n'
+              in
+              Pax.try_finally ( fun och ->
+                Pervasives.output_string och v;
+                Pervasives.output_string fchm n;
+                Pervasives.output_char fchm '\000';
+              ) och ( fun och -> Pervasives.close_out och ) och
+            in
+            List.iter to_file dpkg#meta_data;
+            let f file =
+              Pervasives.output_string fch file;
+              Pervasives.output_char fch '\000';
+            in
+	    List.iter f dpkg#dispersion#files;
+            fchm_closed := true;
+            Pervasives.close_out fchm ;
+            fch_closed := true;
+            Pervasives.close_out fch ;
+            (* default fast *)
+            (try ignore (Sys.getenv "XZ_OPT") with | _ -> Unix.putenv "XZ_OPT" "-1" );
+            Godi_exec.call_cmd
+              ~stdout:con.protocol
+              ~stderr:`Like_stdout
+              ((Godi_file.nativename (Godi_file.filename Godi_conf.cmd_tar)),
+               [| "--format=ustar";
+                  "--numeric-owner";
+                  "-chJf" ;
+                  (Godi_file.slashname out_file);
+                  "-C";
+                  (Godi_file.slashname p_tmp_dir) ;
+                  "--null";
+                  "-T";
+                  (Godi_file.slashname file_list_meta);
+                  "-C";
+                  (Godi_file.slashname root) ;
+                  "--null" ;
+                  "-T";
+                  (Godi_file.slashname file_list);
+               |] ) ;
 	Godi_query.get_binary_package out_file
+          ) fchm ( fun fchm -> if !fchm_closed <> false then Pervasives.close_out fchm ) fchm
+        ) fch ( fun fch -> if !fch_closed <> false then Pervasives.close_out fch ) fch
+      ) tmp_dir ( fun tmp_dir -> Godi_file.release_tmpdir tmp_dir ) tmp_dir
 ;;
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-pkg/godi_query.ml ./console-src/godi-pkg/godi_query.ml
--- ../godi-tools-3.0.18.orig/console-src/godi-pkg/godi_query.ml	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-pkg/godi_query.ml	2012-11-01 12:28:56.000000000 +0100
@@ -594,8 +594,8 @@
 
 let from_tgz tgz =
   let components = Hashtbl.create 10 in
-  ( try
-      let ar = Pax.read (`File tgz) `Gzip `Tar in
+  (try
+    let ar = Pax.read (`File tgz) `Xz `Tar in
       let cont = ref true in
       while !cont do
 	match Pax.read_element ar with
@@ -609,11 +609,11 @@
 		  name
 		  (Pax.extract_element_to_memory el)
 	      else
-		cont := false
+          cont:=false
       done;
       Pax.close_in ar;
-    with _ -> ()
-  );
+  with
+  | e -> prerr_endline (Printexc.to_string e));
   ( object
       method filename = tgz
       method get name =
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-sys-win32/godi_file.ml ./console-src/godi-sys-win32/godi_file.ml
--- ../godi-tools-3.0.18.orig/console-src/godi-sys-win32/godi_file.ml	2012-10-22 03:00:49.000000000 +0200
+++ ./console-src/godi-sys-win32/godi_file.ml	2012-11-01 12:29:12.000000000 +0100
@@ -493,6 +493,15 @@
     | Some _, _ ->
         not is_regular && not is_dir && not is_symlink
     | None, _ ->
+		let nn = nativename fn in
+	    (* the following command won't work without this change:
+		   godi_console.exe pax -rw -pp . /cygdrive/c/xyz
+		 Unix.(l)stat fails with "C:" as argument. 
+		 However, this is probably not the right place to fix it.
+	    *)
+        if String.length nn = 2 && nn.[1] = ':' && nn.[0] >= 'A' && nn.[0] <= 'Z' then 
+		  not is_regular && not is_symlink && Sys.file_exists (nn ^ "\\")
+	    else
         not is_regular && not is_dir && not is_existing && not is_symlink
 ;;
 
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-util/godi_conf.mlp ./console-src/godi-util/godi_conf.mlp
--- ../godi-tools-3.0.18.orig/console-src/godi-util/godi_conf.mlp	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-util/godi_conf.mlp	2012-11-01 12:28:58.000000000 +0100
@@ -24,3 +24,56 @@
 
 let cmd_bzip2 = "@CMD_BZIP2@";;
   (* The bzip2 utility *)
+
+module Helpf = struct
+  let is_windows = Sys.os_type = "Win32" ;;
+
+  let add_exe str = match is_windows with
+  | false -> str
+  | true  -> str ^ ".exe" ;;
+
+  (* for bsdtar and bsdcpio.
+     During self update we us the copy in the stage dir,
+     This way, it's possible to overwrite the old ones *)
+  let localbase = "@LOCALBASE@" ;;
+
+  (* try relocatable location *)
+  let localbase =
+    try
+      let self_dir = Filename.dirname (Filename.dirname Sys.executable_name) in
+      if self_dir = "" || not (Sys.file_exists Sys.executable_name) || not (Sys.is_directory self_dir) then
+        localbase
+      else (
+        if is_windows = true && self_dir.[0] = '\\' then (
+          (* enforce forward slashes *)
+          for i = 0 to String.length self_dir - 1 do
+            match self_dir.[i] with
+            | '\\' -> self_dir.[i] <- '/';
+            | _ -> ()
+          done;
+        );
+        self_dir
+      )
+    with
+    | Sys_error _  -> localbase
+
+  (* temporary solution for self update *)
+  let localbase =
+    try
+      if Sys.getenv "GODI_TOOL_SELF_UPDATE" = "1" then
+        localbase ^ "/build/godi/godi-tools/work/stage"
+      else
+        localbase
+    with
+    | Not_found -> localbase
+end
+
+open Helpf
+
+let cmd_xz = add_exe "/bin/xz" ;;
+let cmd_tar = add_exe "/bin/tar" ;;
+let cmd_cpio = add_exe "/bin/cpio" ;;
+let cmd_bsdtar = add_exe (localbase ^ "/sbin/bsdtar") ;;
+let cmd_bsdcpio = add_exe (localbase ^ "/sbin/bsdcpio") ;;
+let cmd_shell = add_exe "/bin/bash" ;;
+let cmd_rm = add_exe "/bin/rm" ;;
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/godi-util/Makefile.code ./console-src/godi-util/Makefile.code
--- ../godi-tools-3.0.18.orig/console-src/godi-util/Makefile.code	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/godi-util/Makefile.code	2012-11-01 12:29:00.000000000 +0100
@@ -23,6 +23,7 @@
 	sed -e 's|@SYS_MK_PATH@|$(SYS_MK_PATH)|' \
 	    -e 's|@CMD_GZIP@|$(CMD_GZIP)|' \
 	    -e 's|@CMD_BZIP2@|$(CMD_BZIP2)|' \
+	    -e 's|@LOCALBASE@|$(LOCALBASE)|' \
 	     godi_conf.mlp >godi_conf.ml
 
 
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/Makefile ./console-src/Makefile
--- ../godi-tools-3.0.18.orig/console-src/Makefile	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/Makefile	2012-11-01 12:29:43.000000000 +0100
@@ -10,17 +10,23 @@
 	cd godi-ui && $(MAKE) all
 	cd console && $(MAKE) all
 
+
+DEBUG_EXPORT= \
+	export CFLAGS="-g $(CFLAGS)" ; \
+	export OCAMLOPT_OPTIONS="-g" ; \
+	export OPT_OPTIONS="-g" ;
+
 opt:
-	test $(HAVE_GODITERM) -eq 0 || { cd godi-term && $(MAKE) opt; }
-	cd godi-digest && $(MAKE) opt
-	cd godi-sys-$(SYSTEM_TYPE) && $(MAKE) opt
-	cd godi-util && $(MAKE) opt
-	cd godi-pax && $(MAKE) opt
-	cd godi-gzip && $(MAKE) opt
-	cd godi-wtool-$(WTOOL) && $(MAKE) opt
-	cd godi-pkg && $(MAKE) opt
-	cd godi-ui && $(MAKE) opt
-	cd console && $(MAKE) opt
+	@test $(HAVE_GODITERM) -eq 0 || ( $(DEBUG_EXPORT) cd godi-term && $(MAKE) opt )
+	@$(DEBUG_EXPORT) cd godi-digest && $(MAKE) opt
+	@$(DEBUG_EXPORT) cd godi-sys-$(SYSTEM_TYPE) && $(MAKE) opt
+	@$(DEBUG_EXPORT) cd godi-util && $(MAKE) opt
+	@$(DEBUG_EXPORT) cd godi-pax && $(MAKE) opt
+	@$(DEBUG_EXPORT) cd godi-gzip && $(MAKE) opt
+	@$(DEBUG_EXPORT) cd godi-wtool-$(WTOOL) &&  $(MAKE) opt
+	@$(DEBUG_EXPORT) cd godi-pkg && $(MAKE) opt
+	@$(DEBUG_EXPORT) cd godi-ui && $(MAKE) opt
+	@$(DEBUG_EXPORT) cd console && $(MAKE) opt
 
 optp:
 	test $(HAVE_GODITERM) -eq 0 || { cd godi-term && OCAMLOPT_OPTIONS=-p $(MAKE) opt; }
@@ -52,13 +58,16 @@
 	mkdir -p "$(prefix)/man/man1"
 	rm -f "$(prefix)/sbin/godi_console$(EXE)"
 	cp console/godi_console$(EXE) "$(prefix)/sbin"
+	if [ -f console/godi_console_byte$(EXE) ]; then \
+		cp console/godi_console_byte$(EXE) "$(prefix)/sbin" ; \
+	fi
 	for f in update wish list info perform dep delete add ptool; do \
             rm -f "$(prefix)/sbin/godi_$$f$(EXE)"; \
             if [ -z "$(W32PORT)" ]; then \
 	        ln -s godi_console$(EXE) "$(prefix)/sbin/godi_$$f$(EXE)"; \
             else \
                 W32PORT="$(W32PORT)" \
-                   ./symlink "$(LOCALBASE_NATIVE)/sbin/godi_console.exe" \
+                   ./symlink "godi_console.exe" \
 			     "$(prefix)/sbin/godi_$$f$(EXE)"; \
             fi; \
 	done
@@ -68,7 +77,7 @@
 	        ln -s ../sbin/godi_console$(EXE) "$(prefix)/bin/godi_$$f$(EXE)"; \
             else \
                 W32PORT="$(W32PORT)" \
-                    ./symlink "$(LOCALBASE_NATIVE)/sbin/godi_console.exe" \
+                    ./symlink "../sbin/godi_console.exe" \
 	 	              "$(prefix)/bin/godi_$$f$(EXE)"; \
             fi; \
 	done
diff -r -b -B -u ../godi-tools-3.0.18.orig/console-src/symlink ./console-src/symlink
--- ../godi-tools-3.0.18.orig/console-src/symlink	2012-10-22 03:00:48.000000000 +0200
+++ ./console-src/symlink	2012-11-01 12:29:47.000000000 +0100
@@ -1,51 +1,38 @@
 #! /bin/sh
 
-# On POSIX create a symlink from one executable to another, e.g.
-# godi_add -> godi_console
-
-# On Win32 emulate that by creating a small wrapper program.
-# Needs env var W32PORT. $symto must be an absolute Win32 path.
-
 set -e
 
+if [ -z "$W32PORT" ]; then
+    echo "Only call me on w32" >&2
+    exit 1
+fi
+
 if [ -z "$CC" ]; then
     echo "Variable CC not set!" >&2
     exit 1
 fi
 
+# sample call
+#./symlink "../sbin/godi_console.exe" "$(prefix)/bin/godi_$$f$(EXE)"; 
 
-symto="$1"
-symfrom="$2"
+symlink_c="$(dirname "$0")/symlink.c"
 
-if [ -z "$W32PORT" ]; then
-    ln -s "$symto" "$symfrom"
-else
-    bfrom=`basename "$symfrom" .exe`
-    bfrom="${bfrom#godi_*}"
-    mkdir -p tmp
-
-    cat >tmp/wrapper.c <<EOF 
-#include <process.h>
-#include <errno.h>
-#include <stdlib.h>
-main(int argc, char **argv) {
-    char **new_argv;
-    int k, code;
-    new_argv = malloc( (argc+2) * sizeof (char *) );
-    new_argv[0] = "$1";
-    new_argv[1] = "$bfrom";
-    for (k=1; k < argc; k++) new_argv[k+1] = argv[k];
-    new_argv[argc+1] = NULL;
-    code = _spawnv(_P_WAIT, "$1", (const char **) new_argv);
-    if (code == -1) {
-        perror("$bfrom: Cannot exec $1");
-        exit(127);
-    }
-    else exit(code);
+argv1="$(basename "$2" .exe)"
+argv1="${argv1#godi_*}"
+prog="$(echo "$1" | sed 's|/|\\\\\\\\|g')"
+
+cfile="$(mktemp --suffix '.c')"
+exefile="$(mktemp --suffix '.exe')"
+
+clean(){
+    rm -f "$cfile"
+    rm -f "$exefile"
 }
-EOF
+trap clean EXIT
 
-    $CC -o tmp/wrapper tmp/wrapper.c
-    cp tmp/wrapper "$symfrom"
-fi
+sed -e "s|@PROG@|$prog|g" \
+    -e "s|@ARGV1@|$argv1|g" \
+    "$symlink_c"  >"$cfile"
 
+$CC -o "$exefile" "$cfile"
+cp "$exefile" "$2"
diff -r -b -B -u ../godi-tools-3.0.18.orig/mk/configure ./mk/configure
--- ../godi-tools-3.0.18.orig/mk/configure	2012-10-22 03:00:48.000000000 +0200
+++ ./mk/configure	2012-11-01 12:29:27.000000000 +0100
@@ -13,6 +13,8 @@
 outsystype="build/mk/systype.mk"
 path_mode="append"
 print=0
+#toolchain prefix
+toolchain=''
 
 while [ $# -gt 0 ]; do
     case "$1" in
@@ -30,6 +32,9 @@
 	    shift; shift ;;
 	-print-path)
 	    print=1 ; shift ;;
+	-toolchain-prefix)
+	    toolchain=$2
+	    shift ; shift ;;
 	*)
 	    echo "Bad argument" >&2
 	    exit 1
@@ -567,15 +572,15 @@
 
     ### Toolchain
 
-    find_prog_for_defs_mk "GCC_EXE" "gcc" $std_path
-    echo 'GCC=gcc'
+    find_prog_for_defs_mk "GCC_EXE" "${toolchain}gcc" $std_path
+    echo "GCC=${toolchain}gcc"
     # GCC=/path does not work
 
-    find_prog_for_defs_mk "AR_EXE" "ar" $std_path
-    find_prog_for_defs_mk "RANLIB_EXE" "ranlib true" $std_path
-    find_prog_for_defs_mk -warn "NM_EXE" "nm" $std_path
-    find_prog_for_defs_mk -warn "CPP_EXE" "cpp" $std_path
-    find_prog_for_defs_mk "STRIP_EXE" "strip" $std_path
+    find_prog_for_defs_mk "AR_EXE" "${toolchain}ar" $std_path
+    find_prog_for_defs_mk "RANLIB_EXE" "${toolchain}ranlib true" $std_path
+    find_prog_for_defs_mk -warn "NM_EXE" "${toolchain}nm" $std_path
+    find_prog_for_defs_mk -warn "CPP_EXE" "${toolchain}cpp" $std_path
+    find_prog_for_defs_mk "STRIP_EXE" "${toolchain}strip" $std_path
     stripprog="$prog"
 
     ### Output SEARCH_CMDS:

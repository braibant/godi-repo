diff --git a/.depend b/.depend
index 53b76ce..fdc729e 100644
--- .depend
+++ .depend
@@ -1,86 +1,64 @@
-_build/src/ctypes-foreign-base/ffi.cmo : _build/src/ctypes-foreign-base/weakRef.cmi \
-    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory.cmo \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes-foreign-base/ffi.cmi
-_build/src/ctypes-foreign-base/ffi.cmx : _build/src/ctypes-foreign-base/weakRef.cmx \
-    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes-foreign-base/libffi_abi.cmx \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes/ctypes_raw.cmx \
-    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes-foreign-base/ffi.cmi
-_build/src/ctypes-foreign-base/libffi_abi.cmo : _build/src/ctypes/ctypes.cmi \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi
-_build/src/ctypes-foreign-base/libffi_abi.cmx : _build/src/ctypes/ctypes.cmx \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi
-_build/src/ctypes-foreign-base/ffi.cmi : _build/src/ctypes/static.cmi \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi
-_build/src/ctypes-foreign-base/libffi_abi.cmi :
-_build/src/ctypes-foreign-base/dl.cmo : _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes-foreign-base/dl.cmi
-_build/src/ctypes-foreign-base/dl.cmx : _build/src/ctypes/ctypes_raw.cmx \
-    _build/src/ctypes-foreign-base/dl.cmi
-_build/src/ctypes-foreign-base/closure_properties.cmo : \
-    _build/src/ctypes-foreign-base/closure_properties.cmi
-_build/src/ctypes-foreign-base/closure_properties.cmx : \
-    _build/src/ctypes-foreign-base/closure_properties.cmi
-_build/src/ctypes-foreign-base/weakRef.cmi :
-_build/src/ctypes-foreign-base/dl.cmi : _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes-foreign-base/foreign_basis.cmo : _build/src/ctypes/type_printing.cmi \
-    _build/src/ctypes/std_views.cmo _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes-foreign-base/ffi.cmi \
-    _build/src/ctypes-foreign-base/dl.cmi _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes/ctypes.cmi _build/src/ctypes/coerce.cmi
-_build/src/ctypes-foreign-base/foreign_basis.cmx : _build/src/ctypes/type_printing.cmx \
-    _build/src/ctypes/std_views.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes-foreign-base/libffi_abi.cmx \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes-foreign-base/ffi.cmx \
-    _build/src/ctypes-foreign-base/dl.cmx _build/src/ctypes/ctypes_raw.cmx \
-    _build/src/ctypes/ctypes.cmx _build/src/ctypes/coerce.cmx
-_build/src/ctypes-foreign-base/ffi_stubs.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes-foreign-base/ffi_stubs.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes-foreign-base/weakRef.cmo : _build/src/ctypes-foreign-base/weakRef.cmi
-_build/src/ctypes-foreign-base/weakRef.cmx : _build/src/ctypes-foreign-base/weakRef.cmi
-_build/src/ctypes-foreign-base/closure_properties.cmi :
-_build/src/discover/discover.cmo :
-_build/src/discover/discover.cmx :
-_build/src/cstubs/cstubs_public_name.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_path.cmi \
-    _build/src/cstubs/cstubs_public_name.cmi
-_build/src/cstubs/cstubs_public_name.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_path.cmx \
-    _build/src/cstubs/cstubs_public_name.cmi
-_build/src/cstubs/cstubs_generate_c.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes.cmi \
-    _build/src/cstubs/cstubs_errors.cmi _build/src/cstubs/cstubs_generate_c.cmi
-_build/src/cstubs/cstubs_generate_c.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes.cmx \
-    _build/src/cstubs/cstubs_errors.cmx _build/src/cstubs/cstubs_generate_c.cmi
+_build/src/cstubs/cstubs_emit_c.cmo : _build/src/ctypes/type_printing.cmi \
+    _build/src/ctypes/static.cmi _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_c_language.cmo
+_build/src/cstubs/cstubs_emit_c.cmx : _build/src/ctypes/type_printing.cmx \
+    _build/src/ctypes/static.cmx _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_c_language.cmx
+_build/src/cstubs/cstubs.cmi : _build/src/ctypes/ctypes.cmi
 _build/src/cstubs/cstubs_analysis.cmo : _build/src/ctypes/unsigned.cmi \
     _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/primitives.cmi \
     _build/src/ctypes/ctypes_bigarray.cmi _build/src/cstubs/cstubs_analysis.cmi
 _build/src/cstubs/cstubs_analysis.cmx : _build/src/ctypes/unsigned.cmx \
     _build/src/ctypes/static.cmx _build/src/ctypes/signed.cmx _build/src/ctypes/primitives.cmx \
     _build/src/ctypes/ctypes_bigarray.cmx _build/src/cstubs/cstubs_analysis.cmi
+_build/src/cstubs/cstubs_internals.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory_stubs.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_internals.cmi
+_build/src/cstubs/cstubs_internals.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory_stubs.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_internals.cmi
+_build/src/cstubs/cstubs_internals.cmi : _build/src/ctypes/unsigned.cmi \
+    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/primitives.cmi \
+    _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes/ctypes_bigarray.cmi _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_generate_c.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_emit_c.cmo _build/src/cstubs/cstubs_c_language.cmo \
+    _build/src/cstubs/cstubs_generate_c.cmi
+_build/src/cstubs/cstubs_generate_c.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_emit_c.cmx _build/src/cstubs/cstubs_c_language.cmx \
+    _build/src/cstubs/cstubs_generate_c.cmi
+_build/src/cstubs/cstubs_generate_c.cmi : _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_generate_ml.cmi : _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_errors.cmi :
+_build/src/cstubs/cstubs_c_language.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_errors.cmi
+_build/src/cstubs/cstubs_c_language.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_errors.cmx
+_build/src/cstubs/cstubs_inverted.cmi : _build/src/ctypes/ctypes.cmi
 _build/src/cstubs/cstubs.cmo : _build/src/ctypes/ctypes.cmi \
     _build/src/cstubs/cstubs_generate_ml.cmi _build/src/cstubs/cstubs_generate_c.cmi \
     _build/src/cstubs/cstubs.cmi
 _build/src/cstubs/cstubs.cmx : _build/src/ctypes/ctypes.cmx \
     _build/src/cstubs/cstubs_generate_ml.cmx _build/src/cstubs/cstubs_generate_c.cmx \
     _build/src/cstubs/cstubs.cmi
-_build/src/cstubs/cstubs_generate_ml.cmi : _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_errors.cmi :
-_build/src/cstubs/cstubs.cmi : _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_internals.cmi : _build/src/ctypes/unsigned.cmi \
-    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes/ctypes_bigarray.cmi _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_inverted.cmi : _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_generate_c.cmi : _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_public_name.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_path.cmi \
+    _build/src/cstubs/cstubs_public_name.cmi
+_build/src/cstubs/cstubs_public_name.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_path.cmx \
+    _build/src/cstubs/cstubs_public_name.cmi
+_build/src/cstubs/cstubs_errors.cmo : _build/src/cstubs/cstubs_errors.cmi
+_build/src/cstubs/cstubs_errors.cmx : _build/src/cstubs/cstubs_errors.cmi
+_build/src/cstubs/cstubs_inverted.cmo : _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_generate_ml.cmi _build/src/cstubs/cstubs_generate_c.cmi \
+    _build/src/cstubs/cstubs_inverted.cmi
+_build/src/cstubs/cstubs_inverted.cmx : _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_generate_ml.cmx _build/src/cstubs/cstubs_generate_c.cmx \
+    _build/src/cstubs/cstubs_inverted.cmi
 _build/src/cstubs/cstubs_generate_ml.cmo : _build/src/ctypes/static.cmi \
     _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_path.cmi \
     _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_public_name.cmi \
@@ -91,128 +69,95 @@ _build/src/cstubs/cstubs_generate_ml.cmx : _build/src/ctypes/static.cmx \
     _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_public_name.cmx \
     _build/src/cstubs/cstubs_errors.cmx _build/src/cstubs/cstubs_analysis.cmx \
     _build/src/cstubs/cstubs_generate_ml.cmi
+_build/src/cstubs/cstubs_analysis.cmi : _build/src/ctypes/static.cmi
 _build/src/cstubs/cstubs_public_name.cmi : _build/src/ctypes/primitives.cmi \
     _build/src/ctypes/ctypes_path.cmi
-_build/src/cstubs/cstubs_inverted.cmo : _build/src/ctypes/ctypes.cmi \
-    _build/src/cstubs/cstubs_inverted.cmi
-_build/src/cstubs/cstubs_inverted.cmx : _build/src/ctypes/ctypes.cmx \
-    _build/src/cstubs/cstubs_inverted.cmi
-_build/src/cstubs/cstubs_internals.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory_stubs.cmo \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/cstubs/cstubs_internals.cmi
-_build/src/cstubs/cstubs_internals.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory_stubs.cmx \
-    _build/src/ctypes/ctypes_raw.cmx _build/src/cstubs/cstubs_internals.cmi
-_build/src/cstubs/cstubs_analysis.cmi : _build/src/ctypes/static.cmi
-_build/src/cstubs/cstubs_errors.cmo : _build/src/cstubs/cstubs_errors.cmi
-_build/src/cstubs/cstubs_errors.cmx : _build/src/cstubs/cstubs_errors.cmi
-_build/src/configure/make_primitive_details.cmo :
-_build/src/configure/make_primitive_details.cmx :
 _build/src/libffi-abigen/libffi_abigen.cmo :
 _build/src/libffi-abigen/libffi_abigen.cmx :
-_build/src/ctypes-top/ctypes_printers.cmi : _build/src/ctypes/unsigned.cmi \
-    _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
-_build/src/ctypes-top/install_printers.cmo :
-_build/src/ctypes-top/install_printers.cmx :
-_build/src/ctypes-top/ctypes_printers.cmo : _build/src/ctypes/unsigned.cmi \
-    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes/ctypes.cmi _build/src/ctypes-top/ctypes_printers.cmi
-_build/src/ctypes-top/ctypes_printers.cmx : _build/src/ctypes/unsigned.cmx \
-    _build/src/ctypes/static.cmx _build/src/ctypes/signed.cmx _build/src/ctypes/posixTypes.cmx \
-    _build/src/ctypes/ctypes.cmx _build/src/ctypes-top/ctypes_printers.cmi
-_build/src/ctypes/primitives.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi \
-    _build/src/ctypes/primitives.cmi
-_build/src/ctypes/primitives.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/signed.cmx \
-    _build/src/ctypes/primitives.cmi
-_build/src/ctypes/type_printing.cmi : _build/src/ctypes/static.cmi
+_build/src/discover/discover.cmo :
+_build/src/discover/discover.cmx :
+_build/src/ctypes_config.cmo :
+_build/src/ctypes_config.cmx :
+_build/src/ctypes/std_views.cmo : _build/src/ctypes/std_view_stubs.cmo \
+    _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/memory.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/coerce.cmi
+_build/src/ctypes/std_views.cmx : _build/src/ctypes/std_view_stubs.cmx \
+    _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/coerce.cmx
 _build/src/ctypes/signed.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi
 _build/src/ctypes/signed.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/signed.cmi
-_build/src/ctypes/unsigned.cmi :
-_build/src/ctypes/ctypes_path.cmi :
-_build/src/ctypes/type_printing.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes/ctypes_bigarray.cmi \
-    _build/src/ctypes/common.cmo _build/src/ctypes/type_printing.cmi
-_build/src/ctypes/type_printing.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes/ctypes_bigarray.cmx \
-    _build/src/ctypes/common.cmx _build/src/ctypes/type_printing.cmi
-_build/src/ctypes/ctypes_bigarray.cmi : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/ctypes/ctypes_path.cmi
-_build/src/ctypes/posixTypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/ctypes.cmi
-_build/src/ctypes/value_printing.cmo : _build/src/ctypes/value_printing_stubs.cmo \
-    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
-    _build/src/ctypes/common.cmo
-_build/src/ctypes/value_printing.cmx : _build/src/ctypes/value_printing_stubs.cmx \
-    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes/common.cmx
-_build/src/ctypes/primitives.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi
-_build/src/ctypes/ctypes_path.cmo : _build/src/ctypes/ctypes_path.cmi
-_build/src/ctypes/ctypes_path.cmx : _build/src/ctypes/ctypes_path.cmi
-_build/src/ctypes/ctypes_primitives.cmo : _build/src/ctypes/primitives.cmi
-_build/src/ctypes/ctypes_primitives.cmx : _build/src/ctypes/primitives.cmx
-_build/src/ctypes/structs_computed.cmi : _build/src/ctypes/structs.cmi \
-    _build/src/ctypes/static.cmi
-_build/src/ctypes/structs.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/structs.cmi
-_build/src/ctypes/structs.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/structs.cmi
 _build/src/ctypes/value_printing_stubs.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo
+    _build/src/ctypes/ctypes_ptr.cmo
 _build/src/ctypes/value_printing_stubs.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes/structs_computed.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/structs_computed.cmi
-_build/src/ctypes/structs_computed.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/structs_computed.cmi
+    _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/common.cmo :
+_build/src/ctypes/common.cmx :
+_build/src/ctypes/structs.cmi : _build/src/ctypes/static.cmi
+_build/src/ctypes/ctypes_path.cmi :
 _build/src/ctypes/memory_stubs.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo
+    _build/src/ctypes/ctypes_ptr.cmo
 _build/src/ctypes/memory_stubs.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes/signed.cmi : _build/src/ctypes/unsigned.cmi
-_build/src/ctypes/ctypes_raw.cmo : _build/src/ctypes/signed.cmi \
-    _build/src/ctypes/ctypes_primitives.cmo
-_build/src/ctypes/ctypes_raw.cmx : _build/src/ctypes/signed.cmx \
-    _build/src/ctypes/ctypes_primitives.cmx
-_build/src/ctypes/std_views.cmo : _build/src/ctypes/std_view_stubs.cmo \
-    _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/memory.cmo \
-    _build/src/ctypes/coerce.cmi
-_build/src/ctypes/std_views.cmx : _build/src/ctypes/std_view_stubs.cmx \
-    _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes/coerce.cmx
-_build/src/ctypes/structs.cmi : _build/src/ctypes/static.cmi
-_build/src/ctypes/static.cmo : _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_raw.cmo \
+    _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/primitives.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi
+_build/src/ctypes/static.cmo : _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_ptr.cmo \
     _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes/ctypes_bigarray.cmi \
     _build/src/ctypes/static.cmi
-_build/src/ctypes/static.cmx : _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_raw.cmx \
+_build/src/ctypes/static.cmx : _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_ptr.cmx \
     _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes/ctypes_bigarray.cmx \
     _build/src/ctypes/static.cmi
+_build/src/ctypes/primitives.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi \
+    _build/src/ctypes/primitives.cmi
+_build/src/ctypes/primitives.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/signed.cmx \
+    _build/src/ctypes/primitives.cmi
+_build/src/ctypes/ctypes_ptr.cmo : _build/src/ctypes/signed.cmi \
+    _build/src/ctypes/ctypes_primitives.cmo
+_build/src/ctypes/ctypes_ptr.cmx : _build/src/ctypes/signed.cmx \
+    _build/src/ctypes/ctypes_primitives.cmx
+_build/src/ctypes/ctypes_primitives.cmo : _build/src/ctypes/primitives.cmi
+_build/src/ctypes/ctypes_primitives.cmx : _build/src/ctypes/primitives.cmx
+_build/src/ctypes/posixTypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/ctypes.cmi
 _build/src/ctypes/static.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_raw.cmo \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_ptr.cmo \
     _build/src/ctypes/ctypes_bigarray.cmi
+_build/src/ctypes/bigarray_stubs.cmo : _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes/bigarray_stubs.cmx : _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/structs.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/structs.cmi
+_build/src/ctypes/structs.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/structs.cmi
+_build/src/ctypes/coerce.cmi : _build/src/ctypes/static.cmi
+_build/src/ctypes/value_printing.cmo : _build/src/ctypes/value_printing_stubs.cmo \
+    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/common.cmo
+_build/src/ctypes/value_printing.cmx : _build/src/ctypes/value_printing_stubs.cmx \
+    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/common.cmx
+_build/src/ctypes/ctypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/static.cmi \
+    _build/src/ctypes/signed.cmi
+_build/src/ctypes/ctypes_path.cmo : _build/src/ctypes/ctypes_path.cmi
+_build/src/ctypes/ctypes_path.cmx : _build/src/ctypes/ctypes_path.cmi
+_build/src/ctypes/unsigned.cmo : _build/src/ctypes/unsigned.cmi
+_build/src/ctypes/unsigned.cmx : _build/src/ctypes/unsigned.cmi
 _build/src/ctypes/ctypes_bigarray.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/ctypes/ctypes_primitives.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes_primitives.cmo \
     _build/src/ctypes/ctypes_path.cmi _build/src/ctypes/bigarray_stubs.cmo \
     _build/src/ctypes/ctypes_bigarray.cmi
 _build/src/ctypes/ctypes_bigarray.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx _build/src/ctypes/ctypes_primitives.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/ctypes_primitives.cmx \
     _build/src/ctypes/ctypes_path.cmx _build/src/ctypes/bigarray_stubs.cmx \
     _build/src/ctypes/ctypes_bigarray.cmi
-_build/src/ctypes/bigarray_stubs.cmo : _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes/bigarray_stubs.cmx : _build/src/ctypes/ctypes_raw.cmx
+_build/src/ctypes/unsigned.cmi :
+_build/src/ctypes/signed.cmi : _build/src/ctypes/unsigned.cmi
 _build/src/ctypes/coerce.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/coerce.cmi
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/coerce.cmi
 _build/src/ctypes/coerce.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/coerce.cmi
-_build/src/ctypes/std_view_stubs.cmo : _build/src/ctypes/memory_stubs.cmo \
-    _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes/std_view_stubs.cmx : _build/src/ctypes/memory_stubs.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes/unsigned.cmo : _build/src/ctypes/unsigned.cmi
-_build/src/ctypes/unsigned.cmx : _build/src/ctypes/unsigned.cmi
-_build/src/ctypes/common.cmo :
-_build/src/ctypes/common.cmx :
-_build/src/ctypes/memory.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/ctypes/ctypes_bigarray.cmi
-_build/src/ctypes/memory.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx \
-    _build/src/ctypes/ctypes_raw.cmx _build/src/ctypes/ctypes_bigarray.cmx
-_build/src/ctypes/coerce.cmi : _build/src/ctypes/static.cmi
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/coerce.cmi
+_build/src/ctypes/structs_computed.cmi : _build/src/ctypes/structs.cmi \
+    _build/src/ctypes/static.cmi
+_build/src/ctypes/ctypes_bigarray.cmi : _build/src/ctypes/primitives.cmi \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes_path.cmi
+_build/src/ctypes/structs_computed.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/structs_computed.cmi
+_build/src/ctypes/structs_computed.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/structs_computed.cmi
 _build/src/ctypes/posixTypes.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/ctypes.cmi \
     _build/src/ctypes/posixTypes.cmi
 _build/src/ctypes/posixTypes.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/ctypes.cmx \
@@ -225,13 +170,97 @@ _build/src/ctypes/ctypes.cmx : _build/src/ctypes/value_printing.cmx \
     _build/src/ctypes/type_printing.cmx _build/src/ctypes/structs_computed.cmx \
     _build/src/ctypes/std_views.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
     _build/src/ctypes/coerce.cmx _build/src/ctypes/ctypes.cmi
-_build/src/ctypes/ctypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/static.cmi \
-    _build/src/ctypes/signed.cmi
-_build/src/ctypes-foreign-unthreaded/foreign.cmi : \
+_build/src/ctypes/std_view_stubs.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes/std_view_stubs.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/memory_stubs.cmx _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/memory.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes_bigarray.cmi
+_build/src/ctypes/memory.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/ctypes_bigarray.cmx
+_build/src/ctypes/type_printing.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes/ctypes_bigarray.cmi \
+    _build/src/ctypes/common.cmo _build/src/ctypes/type_printing.cmi
+_build/src/ctypes/type_printing.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes/ctypes_bigarray.cmx \
+    _build/src/ctypes/common.cmx _build/src/ctypes/type_printing.cmi
+_build/src/ctypes/type_printing.cmi : _build/src/ctypes/static.cmi
+_build/src/ctypes-top/install_printers.cmo :
+_build/src/ctypes-top/install_printers.cmx :
+_build/src/ctypes-top/ctypes_printers.cmi : _build/src/ctypes/unsigned.cmi \
+    _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
+_build/src/ctypes-top/ctypes_printers.cmo : _build/src/ctypes/unsigned.cmi \
+    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes/ctypes.cmi _build/src/ctypes-top/ctypes_printers.cmi
+_build/src/ctypes-top/ctypes_printers.cmx : _build/src/ctypes/unsigned.cmx \
+    _build/src/ctypes/static.cmx _build/src/ctypes/signed.cmx _build/src/ctypes/posixTypes.cmx \
+    _build/src/ctypes/ctypes.cmx _build/src/ctypes-top/ctypes_printers.cmi
+_build/src/ctypes-foreign-threaded/foreign.cmi : \
     _build/src/ctypes-foreign-base/libffi_abi.cmi _build/src/ctypes-foreign-base/dl.cmi \
     _build/src/ctypes/ctypes.cmi
+_build/src/ctypes-foreign-threaded/foreign.cmo : \
+    _build/src/ctypes-foreign-base/foreign_basis.cmo \
+    _build/src/ctypes-foreign-base/closure_properties.cmi \
+    _build/src/ctypes-foreign-threaded/foreign.cmi
+_build/src/ctypes-foreign-threaded/foreign.cmx : \
+    _build/src/ctypes-foreign-base/foreign_basis.cmx \
+    _build/src/ctypes-foreign-base/closure_properties.cmx \
+    _build/src/ctypes-foreign-threaded/foreign.cmi
+_build/src/configure/make_primitive_details.cmo :
+_build/src/configure/make_primitive_details.cmx :
+_build/src/ctypes-foreign-base/dl.cmi : _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes-foreign-base/libffi_abi.cmo : _build/src/ctypes/ctypes.cmi \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi
+_build/src/ctypes-foreign-base/libffi_abi.cmx : _build/src/ctypes/ctypes.cmx \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi
+_build/src/ctypes-foreign-base/ffi.cmo : _build/src/ctypes-foreign-base/weakRef.cmi \
+    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory.cmo \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes-foreign-base/ffi.cmi
+_build/src/ctypes-foreign-base/ffi.cmx : _build/src/ctypes-foreign-base/weakRef.cmx \
+    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes-foreign-base/libffi_abi.cmx \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes/ctypes_ptr.cmx \
+    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes-foreign-base/ffi.cmi
+_build/src/ctypes-foreign-base/closure_properties.cmi :
+_build/src/ctypes-foreign-base/ffi_stubs.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes-foreign-base/ffi_stubs.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes-foreign-base/dl.cmo : _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes-foreign-base/dl.cmi
+_build/src/ctypes-foreign-base/dl.cmx : _build/src/ctypes/ctypes_ptr.cmx \
+    _build/src/ctypes-foreign-base/dl.cmi
+_build/src/ctypes-foreign-base/foreign_basis.cmo : _build/src/ctypes/type_printing.cmi \
+    _build/src/ctypes/std_views.cmo _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes-foreign-base/ffi.cmi \
+    _build/src/ctypes-foreign-base/dl.cmi _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes/ctypes.cmi _build/src/ctypes/coerce.cmi
+_build/src/ctypes-foreign-base/foreign_basis.cmx : _build/src/ctypes/type_printing.cmx \
+    _build/src/ctypes/std_views.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes-foreign-base/libffi_abi.cmx \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes-foreign-base/ffi.cmx \
+    _build/src/ctypes-foreign-base/dl.cmx _build/src/ctypes/ctypes_ptr.cmx \
+    _build/src/ctypes/ctypes.cmx _build/src/ctypes/coerce.cmx
+_build/src/ctypes-foreign-base/weakRef.cmo : _build/src/ctypes-foreign-base/weakRef.cmi
+_build/src/ctypes-foreign-base/weakRef.cmx : _build/src/ctypes-foreign-base/weakRef.cmi
+_build/src/ctypes-foreign-base/weakRef.cmi :
+_build/src/ctypes-foreign-base/libffi_abi.cmi :
+_build/src/ctypes-foreign-base/closure_properties.cmo : \
+    _build/src/ctypes-foreign-base/closure_properties.cmi
+_build/src/ctypes-foreign-base/closure_properties.cmx : \
+    _build/src/ctypes-foreign-base/closure_properties.cmi
+_build/src/ctypes-foreign-base/ffi.cmi : _build/src/ctypes/static.cmi \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi
 _build/src/ctypes-foreign-unthreaded/gc_mutex.cmo :
 _build/src/ctypes-foreign-unthreaded/gc_mutex.cmx :
+_build/src/ctypes-foreign-unthreaded/foreign.cmi : \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi _build/src/ctypes-foreign-base/dl.cmi \
+    _build/src/ctypes/ctypes.cmi
 _build/src/ctypes-foreign-unthreaded/foreign.cmo : \
     _build/src/ctypes-foreign-unthreaded/gc_mutex.cmo \
     _build/src/ctypes-foreign-base/foreign_basis.cmo \
@@ -242,33 +271,34 @@ _build/src/ctypes-foreign-unthreaded/foreign.cmx : \
     _build/src/ctypes-foreign-base/foreign_basis.cmx \
     _build/src/ctypes-foreign-base/closure_properties.cmx \
     _build/src/ctypes-foreign-unthreaded/foreign.cmi
-_build/src/ctypes-foreign-threaded/foreign.cmi : \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi _build/src/ctypes-foreign-base/dl.cmi \
-    _build/src/ctypes/ctypes.cmi
-_build/src/ctypes-foreign-threaded/foreign.cmo : \
-    _build/src/ctypes-foreign-base/foreign_basis.cmo \
-    _build/src/ctypes-foreign-base/closure_properties.cmi \
-    _build/src/ctypes-foreign-threaded/foreign.cmi
-_build/src/ctypes-foreign-threaded/foreign.cmx : \
-    _build/src/ctypes-foreign-base/foreign_basis.cmx \
-    _build/src/ctypes-foreign-base/closure_properties.cmx \
-    _build/src/ctypes-foreign-threaded/foreign.cmi
-_build/src/ctypes_config.cmo :
-_build/src/ctypes_config.cmx :
-_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmo : \
-    _build/examples/fts/stub-generation/bindings/fts_bindings.cmo \
+_build/examples/date/stub-generation/date_cmd.cmo : _build/src/ctypes/posixTypes.cmi \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
+    _build/examples/date/stub-generation/date_generated.cmo _build/src/ctypes/ctypes.cmi
+_build/examples/date/stub-generation/date_cmd.cmx : _build/src/ctypes/posixTypes.cmx \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
+    _build/examples/date/stub-generation/date_generated.cmx _build/src/ctypes/ctypes.cmx
+_build/examples/date/stub-generation/bindings/date_stubs.cmo : \
+    _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
+_build/examples/date/stub-generation/bindings/date_stubs.cmx : \
+    _build/src/ctypes/posixTypes.cmx _build/src/ctypes/ctypes.cmx
+_build/examples/date/stub-generation/date_generated.cmo : _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_internals.cmi
+_build/examples/date/stub-generation/date_generated.cmx : _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_internals.cmx
+_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmo : \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
     _build/src/cstubs/cstubs.cmi
-_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmx : \
-    _build/examples/fts/stub-generation/bindings/fts_bindings.cmx \
+_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmx : \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
     _build/src/cstubs/cstubs.cmx
-_build/examples/fts/stub-generation/fts_cmd.cmo : \
-    _build/examples/fts/stub-generation/bindings/fts_types.cmo \
-    _build/examples/fts/stub-generation/fts_if.cmo _build/src/ctypes/ctypes.cmi
-_build/examples/fts/stub-generation/fts_cmd.cmx : \
-    _build/examples/fts/stub-generation/bindings/fts_types.cmx \
-    _build/examples/fts/stub-generation/fts_if.cmx _build/src/ctypes/ctypes.cmx
-_build/examples/fts/stub-generation/bindings/fts.cmi : \
-    _build/examples/fts/stub-generation/bindings/fts_types.cmo _build/src/ctypes/ctypes.cmi
+_build/examples/date/foreign/date.cmi : _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes/ctypes.cmi
+_build/examples/date/foreign/date.cmo : _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
+    _build/examples/date/foreign/date.cmi
+_build/examples/date/foreign/date.cmx : _build/src/ctypes/posixTypes.cmx \
+    _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
+    _build/examples/date/foreign/date.cmi
 _build/examples/fts/stub-generation/bindings/fts_types.cmo : \
     _build/src/ctypes/unsigned.cmi _build/src/ctypes/posixTypes.cmi \
     _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
@@ -283,6 +313,8 @@ _build/examples/fts/stub-generation/bindings/fts_bindings.cmo : \
 _build/examples/fts/stub-generation/bindings/fts_bindings.cmx : \
     _build/examples/fts/stub-generation/bindings/fts_types.cmx _build/src/ctypes/ctypes.cmx \
     _build/src/cstubs/cstubs.cmx
+_build/examples/fts/stub-generation/bindings/fts.cmi : \
+    _build/examples/fts/stub-generation/bindings/fts_types.cmo _build/src/ctypes/ctypes.cmi
 _build/examples/fts/stub-generation/fts_generated.cmo : _build/src/ctypes/ctypes.cmi \
     _build/src/cstubs/cstubs_internals.cmi
 _build/examples/fts/stub-generation/fts_generated.cmx : _build/src/ctypes/ctypes.cmx \
@@ -297,32 +329,44 @@ _build/examples/fts/stub-generation/fts_if.cmx : \
     _build/examples/fts/stub-generation/fts_generated.cmx \
     _build/examples/fts/stub-generation/bindings/fts_bindings.cmx \
     _build/src/ctypes/ctypes.cmx
-_build/examples/fts/foreign/fts_cmd.cmo : _build/examples/fts/foreign/fts.cmi \
-    _build/src/ctypes/ctypes.cmi
-_build/examples/fts/foreign/fts_cmd.cmx : _build/examples/fts/foreign/fts.cmx \
-    _build/src/ctypes/ctypes.cmx
-_build/examples/fts/foreign/fts.cmi : _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes/ctypes.cmi
+_build/examples/fts/stub-generation/fts_cmd.cmo : \
+    _build/examples/fts/stub-generation/bindings/fts_types.cmo \
+    _build/examples/fts/stub-generation/fts_if.cmo _build/src/ctypes/ctypes.cmi
+_build/examples/fts/stub-generation/fts_cmd.cmx : \
+    _build/examples/fts/stub-generation/bindings/fts_types.cmx \
+    _build/examples/fts/stub-generation/fts_if.cmx _build/src/ctypes/ctypes.cmx
+_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmo : \
+    _build/examples/fts/stub-generation/bindings/fts_bindings.cmo \
+    _build/src/cstubs/cstubs.cmi
+_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmx : \
+    _build/examples/fts/stub-generation/bindings/fts_bindings.cmx \
+    _build/src/cstubs/cstubs.cmx
 _build/examples/fts/foreign/fts.cmo : _build/src/ctypes/unsigned.cmi \
     _build/src/ctypes/posixTypes.cmi _build/src/ctypes-foreign-threaded/foreign.cmi \
     _build/src/ctypes/ctypes.cmi _build/src/ctypes/coerce.cmi _build/examples/fts/foreign/fts.cmi
 _build/examples/fts/foreign/fts.cmx : _build/src/ctypes/unsigned.cmx \
     _build/src/ctypes/posixTypes.cmx _build/src/ctypes-foreign-threaded/foreign.cmx \
     _build/src/ctypes/ctypes.cmx _build/src/ctypes/coerce.cmx _build/examples/fts/foreign/fts.cmi
+_build/examples/fts/foreign/fts.cmi : _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes/ctypes.cmi
+_build/examples/fts/foreign/fts_cmd.cmo : _build/examples/fts/foreign/fts.cmi \
+    _build/src/ctypes/ctypes.cmi
+_build/examples/fts/foreign/fts_cmd.cmx : _build/examples/fts/foreign/fts.cmx \
+    _build/src/ctypes/ctypes.cmx
 _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmo : \
     _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs.cmi
 _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmx : \
     _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs.cmx
+_build/examples/ncurses/stub-generation/ncurses_generated.cmo : \
+    _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_internals.cmi
+_build/examples/ncurses/stub-generation/ncurses_generated.cmx : \
+    _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_internals.cmx
 _build/examples/ncurses/stub-generation/ncurses_stub_cmd.cmo : \
     _build/examples/ncurses/stub-generation/ncurses_generated.cmo \
     _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmo
 _build/examples/ncurses/stub-generation/ncurses_stub_cmd.cmx : \
     _build/examples/ncurses/stub-generation/ncurses_generated.cmx \
     _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmx
-_build/examples/ncurses/stub-generation/ncurses_generated.cmo : \
-    _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_internals.cmi
-_build/examples/ncurses/stub-generation/ncurses_generated.cmx : \
-    _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_internals.cmx
 _build/examples/ncurses/foreign/ncurses_cmd.cmo : \
     _build/examples/ncurses/foreign/ncurses.cmi
 _build/examples/ncurses/foreign/ncurses_cmd.cmx : \
@@ -334,38 +378,10 @@ _build/examples/ncurses/foreign/ncurses.cmx : \
     _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
     _build/examples/ncurses/foreign/ncurses.cmi
 _build/examples/ncurses/foreign/ncurses.cmi :
-_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmo : \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
-    _build/src/cstubs/cstubs.cmi
-_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmx : \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
-    _build/src/cstubs/cstubs.cmx
-_build/examples/date/stub-generation/bindings/date_stubs.cmo : \
-    _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
-_build/examples/date/stub-generation/bindings/date_stubs.cmx : \
-    _build/src/ctypes/posixTypes.cmx _build/src/ctypes/ctypes.cmx
-_build/examples/date/stub-generation/date_cmd.cmo : _build/src/ctypes/posixTypes.cmi \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
-    _build/examples/date/stub-generation/date_generated.cmo _build/src/ctypes/ctypes.cmi
-_build/examples/date/stub-generation/date_cmd.cmx : _build/src/ctypes/posixTypes.cmx \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
-    _build/examples/date/stub-generation/date_generated.cmx _build/src/ctypes/ctypes.cmx
-_build/examples/date/stub-generation/date_generated.cmo : _build/src/ctypes/ctypes.cmi \
-    _build/src/cstubs/cstubs_internals.cmi
-_build/examples/date/stub-generation/date_generated.cmx : _build/src/ctypes/ctypes.cmx \
-    _build/src/cstubs/cstubs_internals.cmx
-_build/examples/date/foreign/date.cmo : _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
-    _build/examples/date/foreign/date.cmi
-_build/examples/date/foreign/date.cmx : _build/src/ctypes/posixTypes.cmx \
-    _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
-    _build/examples/date/foreign/date.cmi
-_build/examples/date/foreign/date.cmi : _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes/ctypes.cmi
+_build/examples/sigset/sigset.cmi : _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
 _build/examples/sigset/sigset.cmo : _build/src/ctypes/posixTypes.cmi \
     _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
     _build/examples/sigset/sigset.cmi
 _build/examples/sigset/sigset.cmx : _build/src/ctypes/posixTypes.cmx \
     _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
     _build/examples/sigset/sigset.cmi
-_build/examples/sigset/sigset.cmi : _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
diff --git a/.gitignore b/.gitignore
index 16db330..dac6690 100644
--- .gitignore
+++ .gitignore
@@ -3,6 +3,8 @@ setup.data
 src/ctypes/ctypes_primitives.ml
 src/ctypes_config.h
 src/ctypes_config.ml
+src/ctypes-foreign-base/dl_stubs.c
+src/ctypes-foreign-base/dl.ml
 *~
 generated_stubs.c
 generated_bindings.ml
@@ -12,4 +14,4 @@ date_generated.ml
 date_stubs.c
 fts_generated.ml
 fts_stubs.c
-libffi_abi.ml
\ No newline at end of file
+libffi_abi.ml
diff --git a/.merlin b/.merlin
new file mode 100644
index 0000000..2959c94
--- /dev/null
+++ .merlin
@@ -0,0 +1,23 @@
+PRJ ctypes
+S src
+S src/cstubs
+S src/libffi-abigen
+S src/discover
+S src/ctypes
+S src/ctypes-top
+S src/ctypes-foreign-threaded
+S src/configure
+S src/ctypes-foreign-base
+S src/ctypes-foreign
+S src/ctypes-foreign-unthreaded
+B _build
+B _build/src
+B _build/src/cstubs
+B _build/src/libffi-abigen
+B _build/src/ctypes
+B _build/src/ctypes-top
+B _build/src/ctypes-foreign-threaded
+B _build/src/configure
+B _build/src/ctypes-foreign-base
+B _build/src/ctypes-foreign-unthreaded
+PKG bytes
diff --git a/.travis-ci.sh b/.travis-ci.sh
new file mode 100644
index 0000000..a8c30b3
--- /dev/null
+++ .travis-ci.sh
@@ -0,0 +1,44 @@
+OPAM_DEPENDS="ocamlfind ounit"
+case "$OCAML_VERSION" in
+4.00.1) ppa=avsm/ocaml40+opam11 ;;
+4.01.0) ppa=avsm/ocaml41+opam11 ;;
+4.02.1) ppa=avsm/ocaml42+opam11 ;;
+*) echo Unknown $OCAML_VERSION; exit 1 ;;
+esac
+
+install_on_linux () {
+  echo "yes" | sudo add-apt-repository ppa:$ppa
+  sudo apt-get update -qq
+  sudo apt-get install -qq ocaml ocaml-native-compilers camlp4-extra opam
+  opam init
+}
+
+install_on_osx () {
+  curl -OL "http://xquartz.macosforge.org/downloads/SL/XQuartz-2.7.6.dmg"
+  sudo hdiutil attach XQuartz-2.7.6.dmg
+  sudo installer -verbose -pkg /Volumes/XQuartz-2.7.6/XQuartz.pkg -target /
+  brew install libffi
+  brew install opam
+  opam init
+  opam switch $OCAML_VERSION
+  eval `opam config env` 
+}
+
+export OPAMYES=1
+export OPAMVERBOSE=1
+
+echo $TRAVIS_OS_NAME
+case $TRAVIS_OS_NAME in
+  osx) install_on_osx ;;
+  linux) install_on_linux ;;
+esac
+
+echo OCaml version
+ocaml -version
+echo OPAM versions
+opam --version
+opam --git-version
+opam install ${OPAM_DEPENDS}
+eval `opam config env`
+make
+make test
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..7e06663
--- /dev/null
+++ .travis.yml
@@ -0,0 +1,13 @@
+language: c
+script: bash -ex .travis-ci.sh
+os:
+  - linux
+  - osx
+env:
+  - OCAML_VERSION=4.00.1
+  - OCAML_VERSION=4.01.0
+  - OCAML_VERSION=4.02.1
+matrix:
+  exclude:
+    - os: osx
+      env: OCAML_VERSION=4.00.1
diff --git a/META b/META
index a5db7b7..97864a8 100644
--- META
+++ META
@@ -1,4 +1,4 @@
-version = "0.3.3"
+version = "0.3"
 description = "Combinators for binding to C libraries without writing any C."
 requires = "unix bigarray str bytes"
 archive(byte) = "ctypes.cma"
@@ -8,7 +8,7 @@ archive(native, plugin) = "ctypes.cmxs"
 exists_if = "ctypes.cma"
 
 package "top" (
-  version = "0.3.3"
+  version = "0.3"
   description = "Toplevel printers for C types"
   requires = "ctypes"
   archive(byte) = "ctypes-top.cma"
@@ -19,7 +19,7 @@ package "top" (
 )
 
 package "stubs" (
-  version = "0.3.3"
+  version = "0.3"
   description = "Stub generation from C types"
   requires = "ctypes"
   archive(byte) = "cstubs.cma"
@@ -29,29 +29,42 @@ package "stubs" (
   exists_if = "cstubs.cma"
 )
 
-package "foreign-base" (
- version = "0.3.3"
- description = "Dynamic linking of C functions"
- requires = "ctypes"
- archive(byte) = "ctypes-foreign-base.cma"
- archive(byte, plugin) = "ctypes-foreign-base.cma"
- archive(native) = "ctypes-foreign-base.cmxa"
- archive(native, plugin) = "ctypes-foreign-base.cmxs"
- exists_if = "ctypes-foreign-base.cma"
-)
-
 package "foreign" (
- version = "0.3.3"
+ version = "0.3"
  description = "Dynamic linking of C functions"
- requires = "ctypes ctypes.foreign-base"
- requires(mt) = "threads ctypes ctypes.foreign-base"
- archive(byte, mt) = "ctypes-foreign-threaded.cma"
- archive(byte, plugin, mt) = "ctypes-foreign-threaded.cma"
- archive(native, mt) = "ctypes-foreign-threaded.cmxa"
- archive(native, plugin, mt) = "ctypes-foreign-threaded.cmxs"
- archive(byte) = "ctypes-foreign-unthreaded.cma"
- archive(byte, plugin) = "ctypes-foreign-unthreaded.cma"
- archive(native) = "ctypes-foreign-unthreaded.cmxa"
- archive(native, plugin) = "ctypes-foreign-unthreaded.cmxs"
- exists_if = "ctypes-foreign-threaded.cma"
+ requires(-mt) = "ctypes.foreign.unthreaded"
+ requires(mt) = "ctypes.foreign.threaded"
+
+ package "base" (
+  version = "0.3"
+  description = "Dynamic linking of C functions (base package)"
+  requires = "ctypes"
+  archive(byte) = "ctypes-foreign-base.cma"
+  archive(byte, plugin) = "ctypes-foreign-base.cma"
+  archive(native) = "ctypes-foreign-base.cmxa"
+  archive(native, plugin) = "ctypes-foreign-base.cmxs"
+  exists_if = "ctypes-foreign-base.cma"
+ )
+
+ package "threaded" (
+  version = "0.3"
+  description = "Dynamic linking of C functions (for use in threaded programs)"
+  requires = "threads ctypes ctypes.foreign.base"
+  archive(byte) = "ctypes-foreign-threaded.cma"
+  archive(byte, plugin) = "ctypes-foreign-threaded.cma"
+  archive(native) = "ctypes-foreign-threaded.cmxa"
+  archive(native, plugin) = "ctypes-foreign-threaded.cmxs"
+  exists_if = "ctypes-foreign-threaded.cma"
+ )
+
+ package "unthreaded" (
+  version = "0.3"
+  description = "Dynamic linking of C functions (for use in unthreaded programs)"
+  requires = "ctypes ctypes.foreign.base"
+  archive(byte) = "ctypes-foreign-unthreaded.cma"
+  archive(byte, plugin) = "ctypes-foreign-unthreaded.cma"
+  archive(native) = "ctypes-foreign-unthreaded.cmxa"
+  archive(native, plugin) = "ctypes-foreign-unthreaded.cmxs"
+  exists_if = "ctypes-foreign-unthreaded.cma"
+ )
 )
diff --git a/Makefile b/Makefile
index 48af4c5..b7dde5b 100644
--- Makefile
+++ Makefile
@@ -2,16 +2,25 @@
 
 DEBUG=false
 OCAML=ocaml
-OCAMLDEP=ocamldep
 OCAMLFIND=ocamlfind
-OCAMLMKLIB=ocamlmklib
+OCAMLDEP=$(OCAMLFIND) ocamldep
+OCAMLMKLIB=$(OCAMLFIND) ocamlmklib
 VPATH=src examples
 BUILDDIR=_build
 PROJECTS=configure libffi-abigen configured ctypes cstubs ctypes-foreign-base ctypes-foreign-threaded ctypes-foreign-unthreaded ctypes-top
-GENERATED=src/ctypes_config.h src/ctypes_config.ml setup.data src/ctypes/ctypes_primitives.ml
+GENERATED=src/ctypes_config.h src/ctypes_config.ml setup.data src/ctypes/ctypes_primitives.ml src/ctypes-foreign-base/dl.ml src/ctypes-foreign-base/dl_stubs.c
 OCAML_FFI_INCOPTS=$(libffi_opt)
 export CFLAGS DEBUG
 
+EXTDLL:=$(shell $(OCAMLFIND) ocamlc -config | awk '/^ext_dll:/{print $$2}')
+OSYSTEM:=$(shell $(OCAMLFIND) ocamlc -config | awk '/^system:/{print $$2}')
+
+ifneq (,$(filter mingw%,$(OSYSTEM)))
+OS_ALT_SUFFIX=.win
+else
+OS_ALT_SUFFIX=.unix
+endif
+
 # public targets
 all: setup.data build
 
@@ -51,8 +60,9 @@ ctypes-foreign-base.install_native_objects = yes
 ctypes-foreign-base.threads = no
 ctypes-foreign-base.dir = src/ctypes-foreign-base
 ctypes-foreign-base.subproject_deps = ctypes
-ctypes-foreign-base.extra_mls = libffi_abi.ml
-ctypes-foreign-base.link_flags = $(as_needed_flags) $(libffi_lib)
+ctypes-foreign-base.extra_mls = libffi_abi.ml dl.ml
+ctypes-foreign-base.extra_cs = dl_stubs.c
+ctypes-foreign-base.link_flags = $(as_needed_flags) $(libffi_lib) $(lib_process)
 ctypes-foreign-base.cmo_opts = $(OCAML_FFI_INCOPTS:%=-ccopt %)
 ctypes-foreign-base.cmx_opts = $(OCAML_FFI_INCOPTS:%=-ccopt %)
 
@@ -65,7 +75,7 @@ ctypes-foreign-threaded.install = yes
 ctypes-foreign-threaded.threads = yes
 ctypes-foreign-threaded.dir = src/ctypes-foreign-threaded
 ctypes-foreign-threaded.subproject_deps = ctypes ctypes-foreign-base
-ctypes-foreign-threaded.link_flags = $(as_needed_flags) $(libffi_lib)
+ctypes-foreign-threaded.link_flags = $(as_needed_flags) $(libffi_lib) $(lib_process)
 ctypes-foreign-threaded.cmo_opts = $(OCAML_FFI_INCOPTS:%=-ccopt %)
 ctypes-foreign-threaded.cmx_opts = $(OCAML_FFI_INCOPTS:%=-ccopt %)
 ctypes-foreign-threaded.install_native_objects = no
@@ -79,7 +89,7 @@ ctypes-foreign-unthreaded.install = yes
 ctypes-foreign-unthreaded.threads = no
 ctypes-foreign-unthreaded.dir = src/ctypes-foreign-unthreaded
 ctypes-foreign-unthreaded.subproject_deps = ctypes ctypes-foreign-base
-ctypes-foreign-unthreaded.link_flags = $(as_needed_flags) $(libffi_lib)
+ctypes-foreign-unthreaded.link_flags = $(as_needed_flags) $(libffi_lib) $(lib_process)
 ctypes-foreign-unthreaded.cmo_opts = $(OCAML_FFI_INCOPTS:%=-ccopt %)
 ctypes-foreign-unthreaded.cmx_opts = $(OCAML_FFI_INCOPTS:%=-ccopt %)
 ctypes-foreign-unthreaded.install_native_objects = no
@@ -112,7 +122,12 @@ libffi-abigen: PROJECT=libffi-abigen
 libffi-abigen: $$(NATIVE_TARGET)
 
 # configuration
-configured: src/ctypes/ctypes_primitives.ml src/ctypes-foreign-base/libffi_abi.ml
+configured: src/ctypes/ctypes_primitives.ml src/ctypes-foreign-base/libffi_abi.ml src/ctypes-foreign-base/dl.ml src/ctypes-foreign-base/dl_stubs.c
+
+src/ctypes-foreign-base/dl.ml: src/ctypes-foreign-base/dl.ml$(OS_ALT_SUFFIX)
+	cp $< $@
+src/ctypes-foreign-base/dl_stubs.c: src/ctypes-foreign-base/dl_stubs.c$(OS_ALT_SUFFIX)
+	cp $< $@
 
 src/ctypes/ctypes_primitives.ml: $(BUILDDIR)/configure.native
 	$< > $@
diff --git a/Makefile.examples b/Makefile.examples
index 99dccb2..ef9d18b 100644
--- Makefile.examples
+++ Makefile.examples
@@ -12,7 +12,7 @@ fts-stub-generator.install = no
 fts-stub-generator.dir = examples/fts/stub-generation/stub-generator
 fts-stub-generator.subproject_deps = ctypes cstubs \
   ctypes-foreign-base ctypes-foreign-unthreaded fts-stubs
-fts-stub-generator.deps = str bigarray
+fts-stub-generator.deps = bytes str unix bigarray
 fts-stub-generator: PROJECT=fts-stub-generator
 fts-stub-generator: $$(NATIVE_TARGET)
 
@@ -20,7 +20,7 @@ fts-cmd.install = no
 fts-cmd.dir = examples/fts/stub-generation
 fts-cmd.subproject_deps = ctypes cstubs \
   ctypes-foreign-base ctypes-foreign-unthreaded fts-stubs
-fts-cmd.deps = str bigarray
+fts-cmd.deps = bytes str unix bigarray
 fts-cmd.extra_mls = fts_generated.ml
 fts-cmd: CFLAGS+=-D_FILE_OFFSET_BITS=32
 fts-cmd: PROJECT=fts-cmd
@@ -33,7 +33,7 @@ examples/fts/stub-generation/fts_generated.ml:
 # subproject: fts using dynamic linking (foreign)
 fts.install = no
 fts.dir = examples/fts/foreign
-fts.deps = bigarray str
+fts.deps = bytes unix bigarray str
 fts.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
 fts: PROJECT=fts
 fts: $$(NATIVE_TARGET)
@@ -48,14 +48,14 @@ date-stubs: $$(LIB_TARGETS)
 date-stub-generator.install = no
 date-stub-generator.dir = examples/date/stub-generation/stub-generator
 date-stub-generator.subproject_deps = ctypes cstubs date-stubs
-date-stub-generator.deps = str bigarray
+date-stub-generator.deps = bytes str unix bigarray
 date-stub-generator: PROJECT=date-stub-generator
 date-stub-generator: $$(NATIVE_TARGET)
 
 date-cmd.install = no
 date-cmd.dir = examples/date/stub-generation
 date-cmd.subproject_deps = ctypes cstubs date-stubs
-date-cmd.deps = str bigarray
+date-cmd.deps = bytes str unix bigarray
 date-cmd.extra_mls = date_generated.ml
 date-cmd: PROJECT=date-cmd
 date-cmd: $$(NATIVE_TARGET)
@@ -68,7 +68,7 @@ examples/date/stub-generation/date_generated.ml:
 date.install = no
 date.dir = examples/date/foreign
 date.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
-date.deps = bigarray str
+date.deps = bytes unix bigarray str
 date: PROJECT=date
 date: $$(NATIVE_TARGET)
 
@@ -76,14 +76,14 @@ date: $$(NATIVE_TARGET)
 ncurses-stubs.install = no
 ncurses-stubs.dir = examples/ncurses/stub-generation/bindings
 ncurses-stubs.subproject_deps = ctypes cstubs
-ncurses-stubs.deps = str bigarray
+ncurses-stubs.deps = bytes str unix bigarray
 ncurses-stubs: PROJECT=ncurses-stubs
 ncurses-stubs: $$(NATIVE_TARGET) $$(LIB_TARGETS)
 
 ncurses-cmd.install = no
 ncurses-cmd.dir = examples/ncurses/stub-generation
 ncurses-cmd.subproject_deps = ctypes cstubs ncurses-stubs
-ncurses-cmd.deps = str bigarray
+ncurses-cmd.deps = bytes str unix bigarray
 ncurses-cmd.extra_mls = ncurses_generated.ml
 ncurses-cmd.link_flags = -lncurses
 ncurses-cmd: PROJECT=ncurses-cmd
@@ -97,7 +97,7 @@ examples/ncurses/stub-generation/ncurses_generated.ml:
 ncurses.install = no
 ncurses.dir = examples/ncurses/foreign
 ncurses.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
-ncurses.deps = bigarray str
+ncurses.deps = bytes unix bigarray str
 ncurses.link_flags = -Wl,-no-as-needed -lncurses
 ncurses: PROJECT=ncurses
 ncurses: $$(NATIVE_TARGET)
diff --git a/Makefile.rules b/Makefile.rules
index 9a867e8..3633d29 100644
--- Makefile.rules
+++ Makefile.rules
@@ -2,15 +2,28 @@
 
 .SECONDARY:
 
+ifneq (,$(filter mingw%,$(OSYSTEM)))
+lib_process=-lpsapi
+ifeq ($(DEBUG),false)
+  CFLAGS=-std=c99 -Wall -O3 $(OCAML_FFI_INCOPTS)
+else
+  CFLAGS=-std=c99 -Wall -g $(OCAML_FFI_INCOPTS)
+endif
+else
 ifeq ($(DEBUG),false)
   CFLAGS=-fPIC -Wall -O3 $(OCAML_FFI_INCOPTS)
-  OCAMLFLAGS=
 else
   CFLAGS=-fPIC -Wall -g $(OCAML_FFI_INCOPTS)
+endif
+endif
+
+ifeq ($(DEBUG),false)
+  OCAMLFLAGS=
+else
   OCAMLFLAGS=-g
 endif
 
-C_SOURCE  = $(wildcard $($(PROJECT).dir)/*.c)
+C_SOURCE  = $(wildcard $($(PROJECT).dir)/*.c) $(patsubst %,$($(PROJECT).dir)/%,$($(PROJECT).extra_cs))
 ML_SOURCE = $(shell $(OCAMLDEP) -sort $(sort $(wildcard $($(PROJECT).dir)/*.ml) \
                     $(patsubst %,$($(PROJECT).dir)/%,$($(PROJECT).extra_mls))))
 
@@ -18,7 +31,7 @@ NATIVE_OBJECTS = $(ML_SOURCE:$($(PROJECT).dir)/%.ml=$(BUILDDIR)/$($(PROJECT).dir
 BYTE_OBJECTS = $(ML_SOURCE:$($(PROJECT).dir)/%.ml=$(BUILDDIR)/$($(PROJECT).dir)/%.cmo)
 C_OBJECTS = $(C_SOURCE:$($(PROJECT).dir)/%.c=$(BUILDDIR)/$($(PROJECT).dir)/%.o)
 
-STUB_LIB = $(if $(C_OBJECTS),$(BUILDDIR)/dll$(PROJECT)_stubs.so)
+STUB_LIB = $(if $(C_OBJECTS),$(BUILDDIR)/dll$(PROJECT)_stubs$(EXTDLL))
 
 CMO_OPTS = $($(PROJECT).cmo_opts)
 CMX_OPTS = $($(PROJECT).cmx_opts)
@@ -50,8 +63,8 @@ OCAMLFIND_PACKAGE_FLAGS=$(patsubst %,-package %,$($(PROJECT).deps)) \
 $(BUILDDIR)/%.cmxa: $$(NATIVE_OBJECTS)
 	$(OCAMLFIND) opt -a -linkall $(OCAMLFLAGS) $(THREAD_FLAG) $(OCAMLFIND_PACKAGE_FLAGS) $(CMXA_OPTS) -o $@ $(NATIVE_OBJECTS) $(OCAML_LINK_FLAGS)
 
-$(BUILDDIR)/dll%_stubs.so: $$(C_OBJECTS)
-	$(OCAMLMKLIB) -o $(BUILDDIR)/$*_stubs $^ $(LINK_FLAGS)
+$(BUILDDIR)/dll%_stubs$(EXTDLL): $$(C_OBJECTS)
+	$(OCAMLMKLIB) -o $(BUILDDIR)/$*_stubs $^ $(OCAML_LINK_FLAGS)
 
 $(BUILDDIR)/%.cmxs : $$(NATIVE_OBJECTS)
 	$(OCAMLFIND) opt -shared -linkall $(OCAMLFLAGS) $(THREAD_FLAG) $(OCAMLFIND_PACKAGE_FLAGS) -o $@ $(NATIVE_OBJECTS) $(C_OBJECTS) $(OCAML_LINK_FLAGS)
diff --git a/Makefile.tests b/Makefile.tests
index 7c6d68c..140b049 100644
--- Makefile.tests
+++ Makefile.tests
@@ -268,6 +268,13 @@ test-sizeof.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthread
 test-sizeof: PROJECT=test-sizeof
 test-sizeof: $$(NATIVE_TARGET)
 
+test-foreign_values.dir = tests/test-foreign_values
+test-foreign_values.threads = yes
+test-foreign_values.deps = str bigarray oUnit bytes
+test-foreign_values.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
+test-foreign_values: PROJECT=test-foreign_values
+test-foreign_values: $$(NATIVE_TARGET)
+
 test-unions-stubs.dir  = tests/test-unions/stubs
 test-unions-stubs.threads = yes
 test-unions-stubs.subproject_deps = ctypes cstubs \
@@ -639,6 +646,22 @@ tests/test-passing-ocaml-values/generated_stubs.c: $(BUILDDIR)/test-passing-ocam
 tests/test-passing-ocaml-values/generated_bindings.ml: $(BUILDDIR)/test-passing-ocaml-values-stub-generator.native
 	$< --ml-file $@
 
+test-threads-stubs.dir  = tests/test-threads/stubs
+test-threads-stubs.threads = yes
+test-threads-stubs.subproject_deps = ctypes cstubs \
+   ctypes-foreign-base ctypes-foreign-unthreaded tests-common
+test-threads-stubs: PROJECT=test-threads-stubs
+test-threads-stubs: $$(LIB_TARGETS)
+
+test-threads.dir = tests/test-threads
+test-threads.threads = yes
+test-threads.deps = str bigarray oUnit bytes
+test-threads.subproject_deps = ctypes ctypes-foreign-base \
+   ctypes-foreign-unthreaded cstubs tests-common test-threads-stubs
+test-threads.link_flags = -L$(BUILDDIR)/clib -ltest_functions
+test-threads: PROJECT=test-threads
+test-threads: $$(NATIVE_TARGET)
+
 TESTS =
 TESTS += test-raw
 TESTS += test-pointers-stubs test-pointers-stub-generator test-pointers-generated test-pointers
@@ -650,6 +673,7 @@ TESTS += test-structs-stubs test-structs-stub-generator test-structs-generated t
 TESTS += test-finalisers
 TESTS += test-cstdlib-stubs test-cstdlib-stub-generator test-cstdlib-generated test-cstdlib
 TESTS += test-sizeof
+TESTS += test-foreign_values
 TESTS += test-unions-stubs test-unions-stub-generator test-unions-generated test-unions
 TESTS += test-custom_ops
 TESTS += test-arrays-stubs test-arrays-stub-generator test-arrays-generated test-arrays
@@ -666,13 +690,24 @@ TESTS += test-stubs
 TESTS += test-bigarrays-stubs test-bigarrays-stub-generator test-bigarrays-generated test-bigarrays
 TESTS += test-coercions-stubs test-coercions-stub-generator test-coercions-generated test-coercions
 TESTS += test-passing-ocaml-values-stubs test-passing-ocaml-values-stub-generator test-passing-ocaml-values-generated test-passing-ocaml-values
+TESTS += test-threads-stubs test-threads
+
+
+ifneq (,$(filter mingw%,$(OSYSTEM)))
+WINLDFLAGS=-Wl,--out-implib,libtest_functions.dll.a
+LDFLAGS+=-static-libgcc
+endif
+
+testlib: $(BUILDDIR)/clib/libtest_functions$(EXTDLL)
+$(BUILDDIR)/clib/libtest_functions$(EXTDLL): $(BUILDDIR)/clib/test_functions.o
+	$(CC) -shared $(LDFLAGS) $(WINLDFLAGS) -o $@ $^
+ifneq (,$(filter mingw%,$(OSYSTEM)))
+	cp $@ libtest_functions.dll.a $(BUILDDIR)
+endif
 
-testlib: $(BUILDDIR)/clib/libtest_functions.so
-$(BUILDDIR)/clib/libtest_functions.so: $(BUILDDIR)/clib/test_functions.o
-	$(CC) -shared $(LDFLAGS) -o $@ $^
 $(BUILDDIR)/clib/test_functions.o: tests/clib/test_functions.c
 	@mkdir -p $(@D)
-	$(CC) -c $(CFLAGS) -I `ocamlc -where` -o $@ $^
+	$(CC) -c $(CFLAGS) -I `$(OCAMLFIND) ocamlc -where | sed 's|\r$$||'` -o $@ $^
 tests/clib/test_functions.c: tests/clib/test_functions.h
 
 .PHONY: test testlib $(TESTS) tests-common
@@ -685,4 +720,4 @@ test: build testlib tests-common $(TESTS) \
 run-%:	$*
 	@echo running $*
 	@cd $(BUILDDIR) && LD_LIBRARY_PATH=clib DYLD_LIBRARY_PATH=clib ./$*.native
-	@echo
+
diff --git a/README.md b/README.md
index e010806..c5722a2 100644
--- README.md
+++ README.md
@@ -38,6 +38,23 @@ The documentation and source distribution contain more complex examples, involvi
 
 ## Links
 
-* [Tutorial](https://github.com/ocamllabs/ocaml-ctypes/wiki/ctypes-tutorial)
-* [API documentation](http://ocamllabs.github.io/ocaml-ctypes)
-* [Mailing list](http://lists.ocaml.org/listinfo/ctypes)
+* [Chapter 19: Foreign Function Interface][rwo-19] of [Real World OCaml][rwo] describes ctypes
+* [Modular Foreign Function Bindings][mirage-blogpost] introduces ctypes in the context of the [Mirage][mirage] library operating system
+* [Tutorial][tutorial]
+* [API documentation][apidoc]
+* [Mailing list][mailing-list]
+* [FAQ][faq]
+
+#### Build status:
+
+AppVeyor: [![AppVeyor build status](https://ci.appveyor.com/api/projects/status/n5geenq8sinlptfv/branch/master?svg=true)](https://ci.appveyor.com/project/yallop/ocaml-ctypes/branch/master)  
+Travis: [![Travis build Status](https://travis-ci.org/ocamllabs/ocaml-ctypes.svg?branch=master)](https://travis-ci.org/ocamllabs/ocaml-ctypes)  
+
+[rwo-19]: https://realworldocaml.org/v1/en/html/foreign-function-interface.html
+[rwo]: http://realworldocaml.org/
+[mirage-blogpost]: http://openmirage.org/blog/modular-foreign-function-bindings
+[tutorial]: https://github.com/ocamllabs/ocaml-ctypes/wiki/ctypes-tutorial
+[apidoc]: http://ocamllabs.github.io/ocaml-ctypes
+[mailing-list]: http://lists.ocaml.org/listinfo/ctypes
+[faq]: https://github.com/ocamllabs/ocaml-ctypes/wiki/FAQ
+[mirage]: http://openmirage.org
diff --git a/appveyor.yml b/appveyor.yml
new file mode 100644
index 0000000..66ecfb8
--- /dev/null
+++ appveyor.yml
@@ -0,0 +1,34 @@
+platform:
+    - x64
+
+environment:
+    global:
+        CYG_MIRROR: http://cygwin.uib.no
+        CYG_CACHE: C:/cygwin/var/cache/setup
+    matrix:
+        -   CYG_ARCH: x86
+            CYG_ROOT: C:/cygwin
+            WODI_ARCH: 32
+            MINGW_ARCH: i686
+        -   CYG_ARCH: x86_64
+            CYG_ROOT: C:/cygwin64
+            WODI_ARCH: 64
+            MINGW_ARCH: x86_64
+
+init:
+    - 'echo System architecture: %PLATFORM%'
+
+install:
+    - 'appveyor DownloadFile http://cygwin.com/setup-%CYG_ARCH%.exe -FileName setup.exe'
+    - 'setup.exe -qnNdO -R "%CYG_ROOT%" -s "%CYG_MIRROR%" -l "%CYG_CACHE%" -P wget  -P dos2unix -P diffutils -P cpio -P make -P patch -P mingw64-%MINGW_ARCH%-gcc-core -P mingw64-%MINGW_ARCH%-gcc-g++ >NUL'
+    - '%CYG_ROOT%/bin/bash -lc "cygcheck -dc cygwin"'
+    - '%CYG_ROOT%/bin/bash -lc "wget -q http://ml.ignorelist.com/wodi/8/wodi%WODI_ARCH%.tar.xz -O /tmp/wodi%WODI_ARCH%.tar.xz"'
+    - '%CYG_ROOT%/bin/bash -lc "cd /tmp && rm -rf wodi%WODI_ARCH% && tar -xf wodi%WODI_ARCH%.tar.xz && bash wodi%WODI_ARCH%/install.sh"'
+    - '%CYG_ROOT%/bin/bash -lc "godi_add godi-ounit"'
+
+build_script:
+    - '%CYG_ROOT%/bin/bash -lc "cd \"$OLDPWD\" && ./appveyor/build.sh"'
+
+artifacts:
+  - path: test.log
+    name: test-logs
diff --git a/appveyor/build.sh b/appveyor/build.sh
new file mode 100755
index 0000000..93ffff2
--- /dev/null
+++ appveyor/build.sh
@@ -0,0 +1,68 @@
+#!/usr/bin/env bash
+set -ex
+
+type -p ocamlc
+ocamlc -version
+
+x="$(uname -m)"
+case "$x" in
+    x86_64)
+        build=x86_64-pc-cygwin
+        host=x86_64-w64-mingw32
+        MINGW_TOOL_PREFIX=x86_64-w64-mingw32-
+        ;;
+    *)
+        build=i686-pc-cygwin
+        host=i686-w64-mingw32
+        MINGW_TOOL_PREFIX=i686-w64-mingw32-
+        ;;
+esac
+
+export AR=${MINGW_TOOL_PREFIX}ar.exe
+export AS=${MINGW_TOOL_PREFIX}as.exe
+export CC=${MINGW_TOOL_PREFIX}gcc.exe
+export CPP=${MINGW_TOOL_PREFIX}cpp.exe
+export CPPFILT=${MINGW_TOOL_PREFIX}c++filt.exe
+export CXX=${MINGW_TOOL_PREFIX}g++.exe
+export DLLTOOL=${MINGW_TOOL_PREFIX}dlltool.exe
+export DLLWRAP=${MINGW_TOOL_PREFIX}dllwrap.exe
+export GCOV=${MINGW_TOOL_PREFIX}gcov.exe
+export LD=${MINGW_TOOL_PREFIX}ld.exe
+export NM=${MINGW_TOOL_PREFIX}nm.exe
+export OBJCOPY=${MINGW_TOOL_PREFIX}objcopy.exe
+export OBJDUMP=${MINGW_TOOL_PREFIX}objdump.exe
+export RANLIB=${MINGW_TOOL_PREFIX}ranlib.exe
+export RC=${MINGW_TOOL_PREFIX}windres.exe
+export READELF=${MINGW_TOOL_PREFIX}readelf.exe
+export SIZE=${MINGW_TOOL_PREFIX}size.exe
+export STRINGS=${MINGW_TOOL_PREFIX}strip.exe
+export STRIP=${MINGW_TOOL_PREFIX}strip.exe
+export WINDMC=${MINGW_TOOL_PREFIX}windmc.exe
+export WINDRES=${MINGW_TOOL_PREFIX}windres.exe
+
+# findlib is already installed
+
+# libffi:  we need a static version and only a static version
+(
+  rm -rf /usr/local
+  mkdir -p /usr/local/include
+  wget ftp://sourceware.org/pub/libffi/libffi-3.1.tar.gz
+  rm -rf libffi-3.1
+  tar xfvz libffi-3.1.tar.gz
+  cd libffi-3.1
+  (./configure --build="$build" --host="$host" --prefix /usr/local --disable-shared --enable-static </dev/null && make </dev/null && make install </dev/null) || cat config.log
+  mkdir -p /usr/local/include/
+  ln -s -t /usr/local/include/ /usr/local/lib/libffi-3.1/include/*
+)
+
+export LIBFFI_CFLAGS="-I/usr/local/include"
+export LIBFFI_LIBS="-L/usr/local/lib -lffi"
+
+touch setup.data
+make distclean || true
+rm -f setup.data
+make all
+if ! make -k test &>test.log ; then
+    echo "test case failure" >&2
+    exit 1
+fi
diff --git a/appveyor/findlib-patch-create-process.patch b/appveyor/findlib-patch-create-process.patch
new file mode 100644
index 0000000..7a81ba5
--- /dev/null
+++ appveyor/findlib-patch-create-process.patch
@@ -0,0 +1,28 @@
+diff --git a/findlib-1.5.3/src/findlib/frontend.ml b/findlib-1.5.3/src/findlib/frontend.ml
+index 1fdb117..bf09ce9 100644
+--- a/findlib-1.5.3/src/findlib/frontend.ml
++++ b/findlib-1.5.3/src/findlib/frontend.ml
+@@ -384,13 +384,8 @@ let run_command ?filter verbose cmd args =
+   let () = prerr_endline ("Findlib_config.system : " ^ Findlib_config.system) in
+   let () = prerr_endline ("fixed_cmd : " ^ fixed_cmd) in
+ 
+-  let pid =
+-    Unix.create_process
+-      fixed_cmd
+-      (Array.of_list (cmd :: args))
+-      Unix.stdin
+-      cmd_output
+-      Unix.stderr
++  let status =
++    Unix.system (Printf.sprintf "%s %s" fixed_cmd (String.concat " " args))
+   in
+ 
+   begin match filter with
+@@ -414,7 +409,6 @@ let run_command ?filter verbose cmd args =
+     | None -> ()
+   end;
+ 
+-  let (_,status) = Unix.waitpid [] pid in
+   Sys.set_signal Sys.sigint old_sigint;
+   begin
+     match status with
diff --git a/examples/fts/stub-generation/bindings/fts_types.ml b/examples/fts/stub-generation/bindings/fts_types.ml
index db9abf1..a4afbdb 100644
--- examples/fts/stub-generation/bindings/fts_types.ml
+++ examples/fts/stub-generation/bindings/fts_types.ml
@@ -69,35 +69,39 @@ let fts_set_option_value = function
   | FTS_FOLLOW -> 2
   | FTS_SKIP   -> 4
 
+let id x = x
+
 module FTSENT =
 struct
   open PosixTypes
   open Unsigned
 
   type ftsent
-  let ftsent : ftsent structure typ = structure "FTSENT"
-  let ( -: ) ty label = field ftsent label ty
-  let fts_cycle   = ptr ftsent -: "fts_cycle"
-  let fts_parent  = ptr ftsent -: "fts_parent"
-  let fts_link    = ptr ftsent -: "fts_link"
-  let fts_number  = int        -: "fts_number"
-  let fts_pointer = ptr void   -: "fts_pointer"
-  let fts_accpath = string     -: "fts_accpath"
-  let fts_path    = string     -: "fts_path"
-  let fts_errno   = int        -: "fts_errno"
-  let fts_symfd   = int        -: "fts_symfd"
-  let fts_pathlen = ushort     -: "fts_pathlen"
-  let fts_namelen = ushort     -: "fts_namelen"
-  let fts_ino     = ino_t      -: "fts_ino"
-  let fts_dev     = dev_t      -: "fts_dev"
-  let fts_nlink   = nlink_t    -: "fts_nlink"
-  let fts_level   = short      -: "fts_level"
-  let fts_info    = ushort     -: "fts_info"
-  let fts_flags   = ushort     -: "fts_flags"
-  let fts_instr   = ushort     -: "fts_instr"
-  let fts_statp   = ptr void   -: "fts_statp" (* really a struct stat * *)
-  let fts_name    = char       -: "fts_name"
-  let () = seal ftsent
+  let struct_ftsent : ftsent structure typ = structure "FTSENT"
+  let ( -: ) ty label = field struct_ftsent label ty
+  let fts_cycle   = ptr struct_ftsent -: "fts_cycle"
+  let fts_parent  = ptr struct_ftsent -: "fts_parent"
+  let fts_link    = ptr struct_ftsent -: "fts_link"
+  let fts_number  = int               -: "fts_number"
+  let fts_pointer = ptr void          -: "fts_pointer"
+  let fts_accpath = string            -: "fts_accpath"
+  let fts_path    = string            -: "fts_path"
+  let fts_errno   = int               -: "fts_errno"
+  let fts_symfd   = int               -: "fts_symfd"
+  let fts_pathlen = ushort            -: "fts_pathlen"
+  let fts_namelen = ushort            -: "fts_namelen"
+  let fts_ino     = ino_t             -: "fts_ino"
+  let fts_dev     = dev_t             -: "fts_dev"
+  let fts_nlink   = nlink_t           -: "fts_nlink"
+  let fts_level   = short             -: "fts_level"
+  let fts_info    = ushort            -: "fts_info"
+  let fts_flags   = ushort            -: "fts_flags"
+  let fts_instr   = ushort            -: "fts_instr"
+  let fts_statp   = ptr void          -: "fts_statp" (* really a struct stat * *)
+  let fts_name    = char              -: "fts_name"
+  let () = seal struct_ftsent
+  let ftsent = view struct_ftsent
+    ~read:id ~write:id ~format_typ:(fun k fmt -> Format.pp_print_string fmt "FTSENT"; k fmt)
 
   type t = ftsent structure ptr
   let t = ptr ftsent
@@ -155,8 +159,8 @@ struct
     Foreign.funptr_opt (ptr FTSENT.t @-> ptr FTSENT.t @-> returning int)
 
   type fts
-  let fts : fts structure typ = structure "FTS"
-  let ( -: ) ty label = field fts label ty
+  let struct_fts : fts structure typ = structure "FTS"
+  let ( -: ) ty label = field struct_fts label ty
   let fts_cur     = ptr ftsent       -: "fts_cur"
   let fts_child   = ptr ftsent       -: "fts_child"
   let fts_array   = ptr (ptr ftsent) -: "fts_array"
@@ -168,7 +172,9 @@ struct
   let fts_compar  = compar_typ       -: "fts_compar"
   (* fts_options would work well as a view *)
   let fts_options = int              -: "fts_options"
-  let () = seal fts
+  let () = seal struct_fts
+  let fts = view struct_fts
+    ~read:id ~write:id ~format_typ:(fun k fmt -> Format.pp_print_string fmt "FTS"; k fmt)
 
   type t = { ptr : fts structure ptr;
              (* The compar field ties the lifetime of the comparison function
diff --git a/examples/ncurses/stub-generation/bindings/ncurses_bindings.ml b/examples/ncurses/stub-generation/bindings/ncurses_bindings.ml
index 1759a7b..c9b2d50 100644
--- examples/ncurses/stub-generation/bindings/ncurses_bindings.ml
+++ examples/ncurses/stub-generation/bindings/ncurses_bindings.ml
@@ -50,8 +50,6 @@ end
 
 let c_headers = "#include <ncurses.h>"
 
-let make_stubname cname = "ncurses_stub_" ^ cname
-
 let main () =
   let ml_out = open_out "examples/ncurses/stub-generation/ncurses_generated.ml" in
   let c_out = open_out "examples/ncurses/stub-generation/ncurses_stubs.c" in
diff --git a/src/cstubs/cstubs_c_language.ml b/src/cstubs/cstubs_c_language.ml
new file mode 100644
index 0000000..19170c0
--- /dev/null
+++ src/cstubs/cstubs_c_language.ml
@@ -0,0 +1,105 @@
+(*
+ * Copyright (c) 2014 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* C code representation. *)
+
+open Static
+
+let fresh_var =
+  let var_counter = ref 0 in
+  fun () ->
+    incr var_counter;
+    Printf.sprintf "x%d" !var_counter
+
+type ty = Ty : _ typ -> ty
+type tfn = Fn : _ fn -> tfn
+
+type cfunction = {
+  fname: string;
+  allocates: bool;
+  reads_ocaml_heap: bool;
+  fn: tfn;
+}
+
+type cglobal = {
+  name: string;
+  typ: ty;
+  references_ocaml_heap: bool;
+}
+
+type clocal = [ `Local of string * ty ]
+type cvar = [ clocal | `Global of cglobal ]
+type cconst = [ `Int of int ]
+type cexp = [ cconst
+            | clocal
+            | `Cast of ty * cexp
+            | `Addr of cexp ]
+type clvalue = [ clocal | `Index of clvalue * cexp ]
+type camlop = [ `CAMLparam0
+              | `CAMLlocalN of cexp * cexp ]
+type ceff = [ cexp
+            | camlop
+            | `Global of cglobal
+            | `App of cfunction * cexp list
+            | `Index of ceff * cexp
+            | `Deref of cexp
+            | `Assign of clvalue * ceff ]
+type cbind = clocal * ceff
+type ccomp = [ ceff
+             | `LetConst of clocal * cconst * ccomp
+             | `CAMLreturnT of ty * cexp
+             | `Let of cbind * ccomp ]
+type cfundec = [ `Fundec of string * (string * ty) list * ty ]
+type cfundef = [ `Function of cfundec * ccomp ]
+
+let rec return_type : type a. a fn -> ty = function
+  | Function (_, f) -> return_type f
+  | Returns t -> Ty t
+
+let args : type a. a fn -> (string * ty) list = fun fn ->
+  let rec loop : type a. a Ctypes.fn -> (string * ty) list = function
+    | Static.Function (ty, fn) -> (fresh_var (), Ty ty) :: loop fn
+    | Static.Returns _ -> []
+  in loop fn
+
+module Type_C =
+struct
+  let rec cexp : cexp -> ty = function
+    | `Int _ -> Ty int
+    | `Local (_, ty) -> ty
+    | `Cast (Ty ty, _) -> Ty ty
+    | `Addr e -> let Ty ty = cexp e in Ty (Pointer ty)
+
+  let camlop : camlop -> ty = function
+    | `CAMLparam0
+    | `CAMLlocalN _ -> Ty Void
+
+  let rec ceff : ceff -> ty = function
+    | #cexp as e -> cexp e
+    | #camlop as o -> camlop o
+    | `Global { typ } -> typ
+    | `App ({ fn = Fn f }, _) -> return_type f
+    | `Index (e, _) -> reference_ceff e
+    | `Deref e -> reference_ceff (e :> ceff)
+    | `Assign (_, rv) -> ceff rv
+  and reference_ceff : ceff -> ty =
+    fun e ->
+      begin match ceff e with
+      | Ty (Pointer ty) -> Ty ty
+      | Ty (Array (ty, _)) -> Ty ty
+      | Ty t -> Cstubs_errors.internal_error
+        "dereferencing expression of non-pointer type %s"
+        (Ctypes.string_of_typ t)
+      end
+
+  let rec ccomp : ccomp -> ty = function
+    | #cexp as e -> cexp e
+    | #ceff as e -> ceff e
+    | `Let (_, c)
+    | `LetConst (_, _, c) -> ccomp c
+    | `CAMLreturnT (ty, _) -> ty
+end
diff --git a/src/cstubs/cstubs_emit_c.ml b/src/cstubs/cstubs_emit_c.ml
new file mode 100644
index 0000000..70c06c9
--- /dev/null
+++ src/cstubs/cstubs_emit_c.ml
@@ -0,0 +1,127 @@
+(*
+ * Copyright (c) 2014 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* C pretty printing. *)
+
+open Static
+open Cstubs_c_language
+open Format
+
+let format_seq lbr fmt_item sep rbr fmt items =
+  let open Format in
+  fprintf fmt "%s@[@[" lbr;
+    ListLabels.iteri items ~f:(fun i item ->
+      if i <> 0 then fprintf fmt "@]%s@ @[" sep;
+      fmt_item fmt item);
+  fprintf fmt "@]%s@]" rbr
+
+let format_ty fmt (Ty ty) = Ctypes.format_typ fmt ty
+
+let cvar_name = function
+  | `Local (name, _) | `Global { name } -> name
+
+let cvar fmt v = fprintf fmt "%s" (cvar_name v)
+
+let cconst fmt (`Int i) = fprintf fmt "%d" i
+
+(* Determine whether the C expression [(ty)e] is equivalent to [e] *)
+let cast_unnecessary : ty -> cexp -> bool =
+  let rec harmless l r = match l, r with
+  | Ty (Pointer Void), Ty (Pointer _) -> true
+  | Ty (View { ty }), t -> harmless (Ty ty) t
+  | t, Ty (View { ty }) -> harmless t (Ty ty)
+  | (Ty (Primitive _) as l), (Ty (Primitive _) as r) -> l = r
+  | _ -> false
+  in
+  fun ty e -> harmless ty (Type_C.cexp e)
+
+let rec cexp fmt : cexp -> unit = function
+  | #cconst as c -> cconst fmt c
+  | `Local _ as x -> cvar fmt x
+  | `Cast (ty, e) when cast_unnecessary ty e -> cexp fmt e
+  | `Cast (ty, e) -> fprintf fmt "@[@[(%a)@]%a@]" format_ty ty cexp e
+  | `Addr e -> fprintf fmt "@[&@[%a@]@]" cexp e
+
+let rec clvalue fmt : clvalue -> unit = function
+  | `Local _ as x -> cvar fmt x
+  | `Index (lv, i) ->
+    fprintf fmt "@[@[%a@]@[[%a]@]@]" clvalue lv cexp i
+
+let camlop fmt : camlop -> unit = function
+  | `CAMLparam0 -> Format.fprintf fmt "CAMLparam0()"
+  | `CAMLlocalN (e, c) -> Format.fprintf fmt "CAMLlocalN(@[%a@],@ @[%a@])"
+    cexp e cexp c
+
+let rec ceff fmt : ceff -> unit = function
+  | #cexp as e -> cexp fmt e
+  | #camlop as o -> camlop fmt o
+  | `Global _ as x -> cvar fmt x
+  | `App ({fname}, es) ->
+    fprintf fmt "@[%s(@[" fname;
+    let last_exp = List.length es - 1 in
+    List.iteri
+      (fun i e ->
+        fprintf fmt "@[%a@]%(%)" cexp e
+          (if i <> last_exp then ",@ " else ""))
+      es;
+    fprintf fmt ")@]@]";
+  | `Index (e, i) ->
+    fprintf fmt "@[@[%a@]@[[%a]@]@]" ceff e cexp i
+  | `Deref e -> fprintf fmt "@[*@[%a@]@]" cexp e
+  | `Assign (lv, e) ->
+    fprintf fmt "@[@[%a@]@;=@;@[%a@]@]" clvalue lv ceff e
+
+let rec ccomp fmt : ccomp -> unit = function
+  | #cexp as e -> fprintf fmt "@[<2>return@;@[%a@]@];" cexp e
+  | #ceff as e -> fprintf fmt "@[<2>return@;@[%a@]@];" ceff e
+  | `CAMLreturnT (Ty Void, e) ->
+    fprintf fmt "@[CAMLreturn0@];"
+  | `CAMLreturnT (Ty ty, e) ->
+    fprintf fmt "@[<2>CAMLreturnT(@[%a@],@;@[%a@])@];"
+      (fun t -> Ctypes.format_typ t) ty
+      cexp e
+  | `Let (xe, `Cast (ty, (#cexp as e'))) when cast_unnecessary ty e' ->
+    ccomp fmt (`Let (xe, e'))
+  | `Let ((`Local (x, _), e), `Local (y, _)) when x = y ->
+    ccomp fmt (e :> ccomp)
+  | `Let ((`Local (name, Ty Void), e), s) ->
+    fprintf fmt "@[%a;@]@ %a" ceff e ccomp s
+  | `Let ((`Local (name, Ty (Struct { tag })), e), s) ->
+    fprintf fmt "@[struct@;%s@;%s@;=@;@[%a;@]@]@ %a"
+      tag name ceff e ccomp s
+  | `Let ((`Local (name, Ty (Union { utag })), e), s) ->
+    fprintf fmt "@[union@;%s@;%s@;=@;@[%a;@]@]@ %a"
+      utag name ceff e ccomp s
+  | `Let ((`Local (name, Ty ty), e), s) ->
+    fprintf fmt "@[@[%a@]@;=@;@[%a;@]@]@ %a"
+      (Ctypes.format_typ ~name) ty ceff e ccomp s
+  | `LetConst (`Local (x, _), `Int c, s) ->
+    fprintf fmt "@[enum@ {@[@ %s@ =@ %d@ };@]@]@ %a"
+      x c ccomp s
+
+let format_parameter_list parameters k fmt =
+  let format_arg fmt (name, Ty t) =
+    Type_printing.format_typ ~name fmt t
+  in
+  match parameters with
+  | [] ->
+    Format.fprintf fmt "%t(void)" k
+  | _ ->
+    Format.fprintf fmt "@[%t@[%a@]@]" k
+      (format_seq "(" format_arg "," ")")
+      parameters
+
+let cfundec : Format.formatter -> cfundec -> unit =
+  fun fmt (`Fundec (name, args, Ty return)) ->
+    Type_printing.format_typ' return
+      (fun context fmt ->
+        format_parameter_list args (Type_printing.format_name ~name) fmt)
+      `nonarray fmt
+
+let cfundef fmt (`Function (dec, body) : cfundef) =
+  fprintf fmt "%a@\n{@[<v 2>@\n%a@]@\n}@\n" 
+    cfundec dec ccomp body
diff --git a/src/cstubs/cstubs_generate_c.ml b/src/cstubs/cstubs_generate_c.ml
index e3923a2..f84a728 100644
--- src/cstubs/cstubs_generate_c.ml
+++ src/cstubs/cstubs_generate_c.ml
@@ -8,230 +8,16 @@
 (* C stub generation *)
 
 open Static
-open Cstubs_errors
-
-type ty = Ty : _ typ -> ty
-type _ tfn =
-  Typ : _ typ -> [`Typ] tfn
-| Fn : _ fn -> [`Fn] tfn
-
-type 'a id_properties = {
-  name: string;
-  allocates: bool;
-  reads_ocaml_heap: bool;
-  tfn: 'a tfn;
-}
-
-type 'a cglobal = [ `Global of 'a id_properties ]
-type clocal = [ `Local of string * ty ]
-type cvar = [ clocal | [`Typ] cglobal ]
-type cconst = [ `Int of int ]
-type cexp = [ cconst
-            | cvar
-            | `Cast of ty * cexp
-            | `Addr of cexp ]
-type clvalue = [ clocal | `Index of clvalue * cexp ]
-type camlop = [ `CAMLparam0
-              | `CAMLlocalN of cexp * cexp ]
-type ceff = [ cexp
-            | camlop
-            | `App of [`Fn] cglobal * cexp list
-            | `Index of cexp * cexp
-            | `Deref of cexp
-            | `Assign of clvalue * ceff ]
-type cbind = clocal * ceff
-type ccomp = [ ceff
-             | `LetConst of clocal * cconst * ccomp
-             | `CAMLreturnT of ty * cexp
-             | `Let of cbind * ccomp ]
-type cfundec = [ `Fundec of string * (string * ty) list * ty ]
-type cfundef = [ `Function of cfundec * ccomp ]
+open Cstubs_c_language
 
 let max_byte_args = 5
 
-let var_counter = ref 0
-let fresh_var () =
-  incr var_counter;
-  Printf.sprintf "x%d" !var_counter
-
-let rec return_type : type a. a fn -> ty = function
-  | Function (_, f) -> return_type f
-  | Returns t -> Ty t
-
-let args : type a. a fn -> (string * ty) list = fun fn ->
-  let rec loop : type a. a Ctypes.fn -> (string * ty) list = function
-    | Static.Function (ty, fn) -> (fresh_var (), Ty ty) :: loop fn
-    | Static.Returns _ -> []
-  in loop fn
-
-module Type_C =
-struct
-  let rec cexp : cexp -> ty = function
-    | `Int _ -> Ty int
-    | `Local (_, ty) -> ty
-    | `Global { tfn = Typ t } -> Ty t
-    | `Cast (Ty ty, _) -> Ty ty
-    | `Addr e -> let Ty ty = cexp e in Ty (Pointer ty)
-
-  let camlop : camlop -> ty = function
-    | `CAMLparam0
-    | `CAMLlocalN _ -> Ty Void
-
-  let rec ceff : ceff -> ty = function
-    | #cexp as e -> cexp e
-    | #camlop as o -> camlop o
-    | `App (`Global  { tfn = Fn f; name }, _) -> return_type f
-    | `Index (e, _)
-    | `Deref e ->
-      begin match cexp e with
-      | Ty (Pointer ty) -> Ty ty
-      | Ty (Array (ty, _)) -> Ty ty
-      | Ty t -> internal_error
-        "dereferencing expression of non-pointer type %s"
-        (Ctypes.string_of_typ t)
-      end
-    | `Assign (_, rv) -> ceff rv
-
-  let rec ccomp : ccomp -> ty = function
-    | #cexp as e -> cexp e
-    | #ceff as e -> ceff e
-    | `Let (_, c)
-    | `LetConst (_, _, c) -> ccomp c
-    | `CAMLreturnT (ty, _) -> ty
-end
-
 (* We're using an abstract type ([value]) as an argument and return type, so
    we'll use the [Function] and [Return] constructors directly.  The smart
    constructors [@->] and [returning] would reject the abstract type. *)
 let (@->) f t = Function (f, t)
 let returning t = Returns t
 
-module Emit_C =
-struct
-  open Format
-
-  let format_seq lbr fmt_item sep rbr fmt items =
-    let open Format in
-    fprintf fmt "%s@[@[" lbr;
-      ListLabels.iteri items ~f:(fun i item ->
-        if i <> 0 then fprintf fmt "@]%s@ @[" sep;
-        fmt_item fmt item);
-    fprintf fmt "@]%s@]" rbr
-
-  let format_ty fmt (Ty ty) = Ctypes.format_typ fmt ty
-
-  let cvar_name = function
-    | `Local (name, _) | `Global { name } -> name
-
-  let cvar fmt v = fprintf fmt "%s" (cvar_name v)
-
-  let cconst fmt (`Int i) = fprintf fmt "%d" i
-
-  (* Determine whether the C expression [(ty)e] is equivalent to [e] *)
-  let cast_unnecessary : ty -> cexp -> bool =
-    let rec harmless l r = match l, r with
-    | Ty (Pointer Void), Ty (Pointer _) -> true
-    | Ty (View { ty }), t -> harmless (Ty ty) t
-    | t, Ty (View { ty }) -> harmless t (Ty ty)
-    | (Ty (Primitive _) as l), (Ty (Primitive _) as r) -> l = r
-    | _ -> false
-    in
-    fun ty e -> harmless ty (Type_C.cexp e)
-
-  let rec cexp env fmt : cexp -> unit = function
-    | #cconst as c -> cconst fmt c
-    | `Local (y, _) as x ->
-      begin
-        try cexp env fmt (List.assoc y env)
-        with Not_found -> cvar fmt x
-      end
-    | #cvar as x -> cvar fmt x
-    | `Cast (ty, e) when cast_unnecessary ty e -> cexp env fmt e
-    | `Cast (ty, e) -> fprintf fmt "@[@[(%a)@]%a@]" format_ty ty (cexp env) e
-    | `Addr e -> fprintf fmt "@[&@[%a@]@]" (cexp env) e
-
-  let rec clvalue env fmt : clvalue -> unit = function
-    | `Local _ as x -> cvar fmt x
-    | `Index (lv, i) ->
-      fprintf fmt "@[@[%a@]@[[%a]@]@]" (clvalue env) lv (cexp env) i
-
-  let camlop env fmt : camlop -> unit = function
-    | `CAMLparam0 -> Format.fprintf fmt "CAMLparam0()"
-    | `CAMLlocalN (e, c) -> Format.fprintf fmt "CAMLlocalN(@[%a@],@ @[%a@])"
-      (cexp env) e (cexp env) c
-
-  let rec ceff env fmt : ceff -> unit = function
-    | #cexp as e -> cexp env fmt e
-    | #camlop as o -> camlop env fmt o
-    | `App (v, es) ->
-      fprintf fmt "@[%s(@[" (cvar_name v);
-      let last_exp = List.length es - 1 in
-      List.iteri
-        (fun i e ->
-          fprintf fmt "@[%a@]%(%)" (cexp env) e
-            (if i <> last_exp then ",@ " else ""))
-        es;
-      fprintf fmt ")@]@]";
-    | `Index (e, i) ->
-      fprintf fmt "@[@[%a@]@[[%a]@]@]"
-        (cexp env) e (cexp env) i
-    | `Deref e -> fprintf fmt "@[*@[%a@]@]" (cexp env) e
-    | `Assign (lv, e) ->
-      fprintf fmt "@[@[%a@]@;=@;@[%a@]@]"
-        (clvalue env) lv (ceff env) e
-
-  let rec ccomp env fmt : ccomp -> unit = function
-    | #cexp as e -> fprintf fmt "@[<2>return@;@[%a@]@];" (cexp env) e
-    | #ceff as e -> fprintf fmt "@[<2>return@;@[%a@]@];" (ceff env) e
-    | `CAMLreturnT (Ty Void, e) ->
-      fprintf fmt "@[CAMLreturn0@];"
-    | `CAMLreturnT (Ty ty, e) ->
-      fprintf fmt "@[<2>CAMLreturnT(@[%a@],@;@[%a@])@];"
-        (fun t -> Ctypes.format_typ t) ty
-        (cexp env) e
-    | `Let (xe, `Cast (ty, (#cexp as e'))) when cast_unnecessary ty e' ->
-      ccomp env fmt (`Let (xe, e'))
-    | `Let ((`Local (x, _), e), `Local (y, _)) when x = y ->
-      ccomp env fmt (e :> ccomp)
-    | `Let ((`Local (name, Ty Void), e), s) ->
-      fprintf fmt "@[%a;@]@ %a" (ceff env) e (ccomp env) s
-    | `Let ((`Local (name, Ty (Struct { tag })), e), s) ->
-      fprintf fmt "@[struct@;%s@;%s@;=@;@[%a;@]@]@ %a"
-        tag name (ceff env) e (ccomp env) s
-    | `Let ((`Local (name, Ty (Union { utag })), e), s) ->
-      fprintf fmt "@[union@;%s@;%s@;=@;@[%a;@]@]@ %a"
-        utag name (ceff env) e (ccomp env) s
-    | `Let ((`Local (name, Ty ty), e), s) ->
-      fprintf fmt "@[@[%a@]@;=@;@[%a;@]@]@ %a"
-        (Ctypes.format_typ ~name) ty (ceff env) e (ccomp env) s
-    | `LetConst (`Local (x, _), `Int c, s) ->
-      fprintf fmt "@[enum@ {@[@ %s@ =@ %d@ };@]@]@ %a"
-        x c (ccomp env) s
-
-  let format_parameter_list parameters k fmt =
-    let format_arg fmt (name, Ty t) =
-      Type_printing.format_typ ~name fmt t
-    in
-    match parameters with
-    | [] ->
-      Format.fprintf fmt "%t(void)" k
-    | _ ->
-      Format.fprintf fmt "@[%t@[%a@]@]" k
-        (format_seq "(" format_arg "," ")")
-        parameters
-
-  let cfundec : Format.formatter -> cfundec -> unit =
-    fun fmt (`Fundec (name, args, Ty return)) ->
-      Type_printing.format_typ' return
-        (fun context fmt ->
-          format_parameter_list args (Type_printing.format_name ~name) fmt)
-        `nonarray fmt
-
-  let cfundef fmt (`Function (dec, body) : cfundef) =
-    fprintf fmt "%a@\n{@[<v 2>@\n%a@]@\n}@\n" 
-      cfundec dec (ccomp []) body
-end
-
 let value = abstract ~name:"value" ~size:0 ~alignment:0
 
 module Generate_C =
@@ -240,9 +26,9 @@ struct
     let msg = Printf.sprintf "cstubs does not support passing %s" what in
     raise (Unsupported msg)
 
-  let reader name fn = { name; allocates = false; reads_ocaml_heap = true; tfn = Fn fn }
-  let conser name fn = { name; allocates = true; reads_ocaml_heap = false; tfn = Fn fn }
-  let immediater name fn = { name; allocates = false; reads_ocaml_heap = false; tfn = Fn fn }
+  let reader fname fn = { fname; allocates = false; reads_ocaml_heap = true; fn = Fn fn }
+  let conser fname fn = { fname; allocates = true; reads_ocaml_heap = false; fn = Fn fn }
+  let immediater fname fn = { fname; allocates = false; reads_ocaml_heap = false; fn = Fn fn }
 
   let local name ty = `Local (name, Ty ty)
 
@@ -331,46 +117,46 @@ struct
     | Complex32 -> conser "ctypes_copy_float_complex" (complex32 @-> returning value)
     | Complex64 -> conser "ctypes_copy_double_complex" (complex64 @-> returning value)
 
-  let to_ptr : cexp -> ccomp =
-    fun x -> `App (`Global (reader "CTYPES_TO_PTR" (value @-> returning (ptr void))),
+  let of_fatptr : cexp -> ccomp =
+    fun x -> `App (reader "CTYPES_ADDR_OF_FATPTR"
+                          (value @-> returning (ptr void)),
                    [x])
 
   let string_to_ptr : cexp -> ccomp =
-    fun x -> `App (`Global (reader "CTYPES_PTR_OF_OCAML_STRING"
-                              (value @-> returning (ptr void))),
+    fun x -> `App (reader "CTYPES_PTR_OF_OCAML_STRING"
+                          (value @-> returning (ptr void)),
                    [x])
 
   let float_array_to_ptr : cexp -> ccomp =
-    fun x -> `App (`Global (reader "CTYPES_PTR_OF_FLOAT_ARRAY"
-                              (value @-> returning (ptr void))),
+    fun x -> `App (reader "CTYPES_PTR_OF_FLOAT_ARRAY"
+                          (value @-> returning (ptr void)),
                    [x])
 
   let from_ptr : cexp -> ceff =
-    fun x -> `App (`Global (conser "CTYPES_FROM_PTR" (ptr void @-> returning value)),
+    fun x -> `App (conser "CTYPES_FROM_PTR"
+                          (ptr void @-> returning value),
                    [x])
 
   let val_unit : ceff = `Global { name = "Val_unit";
-                                  allocates = false;
-                                  reads_ocaml_heap = false;
-                                  tfn = Typ value; }
+                                  references_ocaml_heap = true;
+                                  typ = Ty value }
 
-  let functions : cexp = `Global
+  let functions : ceff = `Global
     { name = "functions";
-      allocates = false;
-      reads_ocaml_heap = true;
-      tfn = Typ (ptr value) }
+      references_ocaml_heap = true;
+      typ = Ty (ptr value) }
 
-  let caml_callbackN : [ `Fn] cglobal = `Global
-    { name = "caml_callbackN";
+  let caml_callbackN : cfunction =
+    { fname = "caml_callbackN";
       allocates = true;
       reads_ocaml_heap = true;
-      tfn = Fn (value @-> int @-> ptr value @-> returning value) }
+      fn = Fn (value @-> int @-> ptr value @-> returning value) }
 
-  let copy_bytes : [`Fn] cglobal =
-    `Global { name = "ctypes_copy_bytes";
-              allocates = true;
-              reads_ocaml_heap = true;
-              tfn = Fn (ptr void @-> size_t @-> returning value) }
+  let copy_bytes : cfunction =
+    { fname = "ctypes_copy_bytes";
+      allocates = true;
+      reads_ocaml_heap = true;
+      fn = Fn (ptr void @-> size_t @-> returning value) }
 
   let cast : type a b. from:ty -> into:ty -> ccomp -> ccomp =
     fun ~from:(Ty from) ~into e ->
@@ -381,15 +167,15 @@ struct
     fun ty x -> match ty with
     | Void -> None
     | Primitive p ->
-      let { tfn = Fn fn } as prj = prim_prj p in
+      let { fn = Fn fn } as prj = prim_prj p in
       let rt = return_type fn in
-      Some (cast ~from:rt ~into:(Ty (Primitive p)) (`App (`Global prj, [x])))
-    | Pointer _ -> Some (to_ptr x)
+      Some (cast ~from:rt ~into:(Ty (Primitive p)) (`App (prj, [x])))
+    | Pointer _ -> Some (of_fatptr x)
     | Struct s ->
-      Some ((to_ptr x, ptr void) >>= fun y ->
+      Some ((of_fatptr x, ptr void) >>= fun y ->
             `Deref (`Cast (Ty (ptr ty), y)))
     | Union u -> 
-      Some ((to_ptr x, ptr void) >>= fun y ->
+      Some ((of_fatptr x, ptr void) >>= fun y ->
             `Deref (`Cast (Ty (ptr ty), y)))
     | Abstract _ -> report_unpassable "values of abstract type"
     | View { ty } -> prj ty x
@@ -402,7 +188,7 @@ struct
   let rec inj : type a. a typ -> cexp -> ceff =
     fun ty x -> match ty with
     | Void -> val_unit
-    | Primitive p -> `App (`Global (prim_inj p), [`Cast (Ty (Primitive p), x)])
+    | Primitive p -> `App (prim_inj p, [`Cast (Ty (Primitive p), x)])
     | Pointer _ -> from_ptr x
     | Struct s -> `App (copy_bytes, [`Addr x; `Int (sizeof ty)])
     | Union u -> `App (copy_bytes, [`Addr x; `Int (sizeof ty)])
@@ -429,10 +215,10 @@ struct
 
   let fn : type a. cname:string -> stub_name:string -> a Static.fn -> cfundef =
     fun ~cname ~stub_name f ->
-      let fvar = `Global { name = cname;
-                           allocates = false;
-                           reads_ocaml_heap = false;
-                           tfn = Fn f; } in
+      let fvar = { fname = cname;
+                   allocates = false;
+                   reads_ocaml_heap = false;
+                   fn = Fn f; } in
       let rec body : type a. _ -> a fn -> _ =
          fun vars -> function 
          | Returns t ->
@@ -451,20 +237,20 @@ struct
                  body [] f')
 
   let byte_fn : type a. string -> a Static.fn -> int -> cfundef =
-    fun name fn nargs ->
+    fun fname fn nargs ->
       let argv = ("argv", Ty (ptr value)) in
       let argc = ("argc", Ty int) in
-      let f = `Global { name ;
-                        allocates = true;
-                        reads_ocaml_heap = true;
-                        tfn = Fn fn }
+      let f = { fname ;
+                allocates = true;
+                reads_ocaml_heap = true;
+                fn = Fn fn }
       in
       let rec build_call ?(args=[]) = function
         | 0 -> `App (f, args)
         | n -> (`Index (`Local argv, `Int (n - 1)), value) >>= fun x ->
                build_call ~args:(x :: args) (n - 1)
       in
-      let bytename = Printf.sprintf "%s_byte%d" name nargs in
+      let bytename = Printf.sprintf "%s_byte%d" fname nargs in
       `Function (`Fundec (bytename, [argv; argc], Ty value),
                  build_call nargs)
 
@@ -524,15 +310,15 @@ let fn ~cname  ~stub_name fmt fn =
   in
   let nargs = List.length xs in
   if nargs > max_byte_args then begin
-    Emit_C.cfundef fmt dec;
-    Emit_C.cfundef fmt (Generate_C.byte_fn f fn nargs)
+    Cstubs_emit_c.cfundef fmt dec;
+    Cstubs_emit_c.cfundef fmt (Generate_C.byte_fn f fn nargs)
   end
   else
-    Emit_C.cfundef fmt dec
+    Cstubs_emit_c.cfundef fmt dec
 
 let inverse_fn ~stub_name fmt fn : unit =
-  Emit_C.cfundef fmt (Generate_C.inverse_fn ~stub_name fn)
+  Cstubs_emit_c.cfundef fmt (Generate_C.inverse_fn ~stub_name fn)
 
 let inverse_fn_decl ~stub_name fmt fn =
   Format.fprintf fmt "@[%a@];@\n"
-    Emit_C.cfundec (Generate_C.fundec stub_name fn)
+    Cstubs_emit_c.cfundec (Generate_C.fundec stub_name fn)
diff --git a/src/cstubs/cstubs_generate_ml.ml b/src/cstubs/cstubs_generate_ml.ml
index ec33a6a..08add5a 100644
--- src/cstubs/cstubs_generate_ml.ml
+++ src/cstubs/cstubs_generate_ml.ml
@@ -191,6 +191,7 @@ let attributes : type a. a fn -> attributes =
 
 let managed_buffer = `Ident (path_of_string "Memory_stubs.managed_buffer")
 let voidp = `Ident (path_of_string "CI.voidp")
+let fatptr = `Appl (path_of_string "CI.fatptr", [`Ident (path_of_string "_")])
 let string = `Ident (path_of_string "string")
 let float_array = `Appl (path_of_string "array",
                          [`Ident (path_of_string "float")])
@@ -220,10 +221,10 @@ let rec ml_typ_of_return_typ : type a. a typ -> ml_type =
 let rec ml_typ_of_arg_typ : type a. a typ -> ml_type = function
   | Void -> `Ident (path_of_string "unit")
   | Primitive p -> `Ident (Cstubs_public_name.ident_of_ml_prim (Primitives.ml_prim p))
-  | Pointer _   -> voidp
-  | Struct _    -> voidp
-  | Union _     -> voidp
-  | Abstract _  -> voidp
+  | Pointer _   -> fatptr
+  | Struct _    -> fatptr
+  | Union _     -> fatptr
+  | Abstract _  -> fatptr
   | View { ty } -> ml_typ_of_arg_typ ty
   | Array _    as a -> internal_error
     "Unexpected array in an argument type: %s" (Ctypes.string_of_typ a)
@@ -240,11 +241,22 @@ let rec ml_typ_of_arg_typ : type a. a typ -> ml_type = function
            [`Appl (path_of_string "array",
                    [`Ident (path_of_string "float")])])
 
-let rec ml_external_type_of_fn : type a. a fn -> ml_external_type = function
-  | Returns t -> `Prim ([], ml_typ_of_return_typ t)
+type polarity = In | Out
+
+let flip = function
+  | In -> Out
+  | Out -> In
+
+let ml_typ_of_typ = function
+    In -> ml_typ_of_arg_typ
+  | Out -> ml_typ_of_return_typ
+
+let rec ml_external_type_of_fn : type a. a fn -> polarity -> ml_external_type =
+  fun fn polarity -> match fn with
+  | Returns t -> `Prim ([], ml_typ_of_typ polarity t)
   | Function (f, t) ->
-    let `Prim (l, t) = ml_external_type_of_fn t in
-    `Prim (ml_typ_of_arg_typ f :: l, t)
+    let `Prim (l, t) = ml_external_type_of_fn t polarity in
+    `Prim (ml_typ_of_typ (flip polarity) f :: l, t)
 
 let var_counter = ref 0
 let fresh_var () =
@@ -253,7 +265,7 @@ let fresh_var () =
 
 let extern ~stub_name ~external_name fmt fn =
   let ext =
-    let typ = ml_external_type_of_fn fn in
+    let typ = ml_external_type_of_fn fn Out in
     ({ ident = external_name;
        typ = typ;
        primname = stub_name;
@@ -264,12 +276,6 @@ let extern ~stub_name ~external_name fmt fn =
 let static_con c args =
   `Con (Ctypes_path.path_of_string ("CI." ^ c), args)
 
-type polarity = In | Out
-
-let flip = function
-  | In -> Out
-  | Out -> In
-
 let rec pattern_and_exp_of_typ :
   type a. a typ -> ml_exp -> polarity -> ml_pat * ml_exp option =
   fun typ e pol -> match typ with
@@ -282,14 +288,14 @@ let rec pattern_and_exp_of_typ :
     let x = fresh_var () in
     let pat = static_con "Pointer" [`Var x] in
     begin match pol with
-    | In -> (pat, Some (`Appl (`Ident (path_of_string "CI.raw_ptr"), e)))
+    | In -> (pat, Some (`Appl (`Ident (path_of_string "CI.cptr"), e)))
     | Out -> (pat, Some (`MakePtr (`Ident (path_of_string x), e)))
     end
   | Struct _ ->
     begin match pol with
     | In ->
       let pat = static_con "Struct" [`Underscore] in
-      (pat, Some (`Appl (`Ident (path_of_string "CI.raw_ptr"),
+      (pat, Some (`Appl (`Ident (path_of_string "CI.cptr"),
                          `Appl (`Ident (path_of_string "Ctypes.addr"), e))))
     | Out ->
       let x = fresh_var () in
@@ -300,7 +306,7 @@ let rec pattern_and_exp_of_typ :
     begin match pol with
     | In ->
       let pat = static_con "Union" [`Underscore] in
-      (pat, Some (`Appl (`Ident (path_of_string "CI.raw_ptr"),
+      (pat, Some (`Appl (`Ident (path_of_string "CI.cptr"),
                          `Appl (`Ident (path_of_string "Ctypes.addr"), e))))
     | Out ->
       let x = fresh_var () in
@@ -397,7 +403,7 @@ let case ~stub_name ~external_name fmt fn =
 let constructor_decl : type a. string -> a fn -> Format.formatter -> unit =
   fun name fn fmt ->
     Format.fprintf fmt "@[|@ %s@ : (@[%a@])@ name@]@\n" name
-      Emit_ML.ml_external_type (ml_external_type_of_fn fn)
+      Emit_ML.ml_external_type (ml_external_type_of_fn fn In)
 
 let inverse_case ~register_name ~constructor name fmt fn : unit =
   let p, e = match wrapper fn "f" Out with
diff --git a/src/cstubs/cstubs_internals.ml b/src/cstubs/cstubs_internals.ml
index 3555412..b29ba90 100644
--- src/cstubs/cstubs_internals.ml
+++ src/cstubs/cstubs_internals.ml
@@ -8,21 +8,19 @@
 (* Types and functions used by generated ML code.  This is an internal
    interface and subject to change. *)
 
-type voidp = Ctypes_raw.voidp
+type voidp = Ctypes_ptr.voidp
 type managed_buffer = Memory_stubs.managed_buffer
+type 'a fatptr = 'a Ctypes.typ Ctypes_ptr.Fat.t
 
-let make_structured reftype buf =
+let make_structured reftyp buf =
   let open Static in
-  let pmanaged = Some (Obj.repr buf) in
+  let managed = Obj.repr buf in
   let raw_ptr = Memory_stubs.block_address buf in
-  let pbyte_offset = 0 in
-  { structured = CPointer { reftype; pmanaged; pbyte_offset; raw_ptr; } }
+  { structured = CPointer (Ctypes_ptr.Fat.make ~managed ~reftyp raw_ptr) }
 
 include Static
 include Primitives
 
-let make_ptr reftype raw_ptr =
-  CPointer { reftype; raw_ptr; pmanaged = None; pbyte_offset = 0; }
+let make_ptr reftyp raw_ptr = CPointer (Ctypes_ptr.Fat.make ~reftyp raw_ptr)
 
-let raw_ptr (CPointer { raw_ptr; pbyte_offset }) =
-  Ctypes_raw.PtrType.(add raw_ptr (of_int pbyte_offset))
+let cptr (CPointer p) = p
diff --git a/src/cstubs/cstubs_internals.mli b/src/cstubs/cstubs_internals.mli
index e7f31e9..087786d 100644
--- src/cstubs/cstubs_internals.mli
+++ src/cstubs/cstubs_internals.mli
@@ -12,15 +12,16 @@ open Ctypes
 open Signed
 open Unsigned
 
-type voidp = Ctypes_raw.voidp
+type voidp = Ctypes_ptr.voidp
 type managed_buffer = Memory_stubs.managed_buffer
+type 'a fatptr = 'a typ Ctypes_ptr.Fat.t
 
 val make_structured :
   ('a, 's) structured typ -> managed_buffer -> ('a, 's) structured
 
 val make_ptr : 'a typ -> voidp -> 'a ptr
 
-val raw_ptr : 'a ptr -> voidp
+val cptr : 'a ptr -> 'a typ Ctypes_ptr.Fat.t
 
 type 'a ocaml_type = 'a Static.ocaml_type =
   String     : string ocaml_type
@@ -38,13 +39,8 @@ type 'a typ = 'a Static.typ =
   | Array           : 'a typ * int              -> 'a Static.carray typ
   | Bigarray        : (_, 'a) Ctypes_bigarray.t -> 'a typ
   | OCaml           : 'a ocaml_type             -> 'a ocaml typ
-and 'a cptr = 'a Static.cptr
-  = { reftype      : 'a typ;
-      raw_ptr      : voidp;
-      pmanaged     : Obj.t option;
-      pbyte_offset : int; }
 and ('a, 'b) pointer = ('a, 'b) Static.pointer =
-  CPointer : 'a cptr -> ('a, [`C]) pointer
+  CPointer : 'a typ Ctypes_ptr.Fat.t -> ('a, [`C]) pointer
 | OCamlRef : int * 'a * 'a ocaml_type -> ('a, [`OCaml]) pointer
 and 'a ptr = ('a, [`C]) pointer
 and 'a ocaml = ('a, [`OCaml]) pointer
@@ -52,6 +48,7 @@ and ('a, 'b) view = ('a, 'b) Static.view = {
   read : 'b -> 'a;
   write : 'a -> 'b;
   format_typ: ((Format.formatter -> unit) -> Format.formatter -> unit) option;
+  format: (Format.formatter -> 'a -> unit) option;
   ty: 'b typ;
 }
 
diff --git a/src/ctypes-foreign-base/dl.ml b/src/ctypes-foreign-base/dl.ml
deleted file mode 100644
index 6f0ce31..0000000
--- src/ctypes-foreign-base/dl.ml
+++ /dev/null
@@ -1,59 +0,0 @@
-(*
- * Copyright (c) 2013 Jeremy Yallop.
- *
- * This file is distributed under the terms of the MIT License.
- * See the file LICENSE for details.
- *)
-
-type library
-
-type flag = 
-    RTLD_LAZY
-  | RTLD_NOW
-  | RTLD_GLOBAL
-  | RTLD_NODELETE
-  | RTLD_NOLOAD
-  | RTLD_DEEPBIND
-
-exception DL_error of string
-
-(* void *dlopen(const char *filename, int flag); *)
-external _dlopen : ?filename:string -> flags:int -> library option
-  = "ctypes_dlopen"
-    
-(* void *dlsym(void *handle, const char *symbol); *)
-external _dlsym : ?handle:library -> symbol:string -> int64 option
-  = "ctypes_dlsym"
-
-(* int dlclose(void *handle); *)
-external _dlclose : handle:library -> int
-  = "ctypes_dlclose"
-
-(* char *dlerror(void); *)
-external _dlerror : unit -> string option
-  = "ctypes_dlerror"
-
-external resolve_flag : flag -> int
-  = "ctypes_resolve_dl_flag"
-
-let _report_dl_error () =
-  match _dlerror () with
-    | None       -> failwith "dl_error: expected error, but no error reported"
-    | Some error -> raise (DL_error (error))
-
-let crush_flags f : 'a list -> int = List.fold_left (fun i o -> i lor (f o)) 0
-
-let dlopen ?filename ~flags =
-  match _dlopen ?filename ~flags:(crush_flags resolve_flag flags) with
-    | Some library -> library
-    | None         -> _report_dl_error ()
-
-let dlclose ~handle =
-  match _dlclose ~handle with
-    | 0 -> ()
-    | _ -> _report_dl_error ()
-
-let dlsym ?handle ~symbol =
-  match _dlsym ?handle ~symbol with
-    | Some symbol -> Ctypes_raw.PtrType.of_int64 symbol
-    | None        -> _report_dl_error ()
diff --git a/src/ctypes-foreign-base/dl.ml.unix b/src/ctypes-foreign-base/dl.ml.unix
new file mode 100644
index 0000000..86aa30d
--- /dev/null
+++ src/ctypes-foreign-base/dl.ml.unix
@@ -0,0 +1,63 @@
+(*
+ * Copyright (c) 2013 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+type library
+
+type flag = 
+    RTLD_LAZY
+  | RTLD_NOW
+  | RTLD_GLOBAL
+  | RTLD_NODELETE
+  | RTLD_NOLOAD
+  | RTLD_DEEPBIND
+
+exception DL_error of string
+
+(* void *dlopen(const char *filename, int flag); *)
+external _dlopen : ?filename:string -> flags:int -> library option
+  = "ctypes_dlopen"
+    
+(* void *dlsym(void *handle, const char *symbol); *)
+external _dlsym : ?handle:library -> symbol:string -> nativeint option
+  = "ctypes_dlsym"
+
+(* int dlclose(void *handle); *)
+external _dlclose : handle:library -> int
+  = "ctypes_dlclose"
+
+(* char *dlerror(void); *)
+external _dlerror : unit -> string option
+  = "ctypes_dlerror"
+
+external resolve_flag : flag -> int
+  = "ctypes_resolve_dl_flag"
+
+let _report_dl_error noload =
+  match _dlerror () with
+    | Some error -> raise (DL_error (error))
+    | None       ->
+      if noload then
+        raise (DL_error "library not loaded")
+      else
+        failwith "dl_error: expected error, but no error reported"
+
+let crush_flags f : 'a list -> int = List.fold_left (fun i o -> i lor (f o)) 0
+
+let dlopen ?filename ~flags =
+  match _dlopen ?filename ~flags:(crush_flags resolve_flag flags) with
+    | Some library -> library
+    | None         -> _report_dl_error (List.mem RTLD_NOLOAD flags)
+
+let dlclose ~handle =
+  match _dlclose ~handle with
+    | 0 -> ()
+    | _ -> _report_dl_error false
+
+let dlsym ?handle ~symbol =
+  match _dlsym ?handle ~symbol with
+    | Some symbol -> Ctypes_ptr.Raw.of_nativeint symbol
+    | None        -> _report_dl_error false
diff --git a/src/ctypes-foreign-base/dl.ml.win b/src/ctypes-foreign-base/dl.ml.win
new file mode 100644
index 0000000..859fb3a
--- /dev/null
+++ src/ctypes-foreign-base/dl.ml.win
@@ -0,0 +1,126 @@
+(*
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+type library
+
+type dlsym_ret =
+  | Dlsy_unknown
+  | Dlsy_nomem
+  | Dlsy_enoent
+  | Dlsy_error of string
+  | Dlsy_ok of Ctypes_ptr.voidp
+external _dlsym_default: string -> dlsym_ret = "ctypes_win32_dlsym_rtld_default"
+external _dlsym: library -> string -> dlsym_ret = "ctypes_win32_dlsym"
+
+type dlopen_ret =
+  | Dlop_unknown
+  | Dlop_nomem
+  | Dlop_notloaded
+  | Dlop_error of string
+  | Dlop_ok of library
+external _dlopen: string option -> int -> dlopen_ret = "ctypes_win32_dlopen"
+
+type dlclose_ret =
+  | Dlcl_unknown
+  | Dlcl_nomem
+  | Dlcl_ok
+  | Dlcl_error of string
+external _dlclose: library -> dlclose_ret = "ctypes_win32_dlclose"
+
+exception DL_error of string
+
+type flag =
+  | RTLD_LAZY
+  | RTLD_NOW
+  | RTLD_GLOBAL
+  | RTLD_NODELETE
+  | RTLD_NOLOAD
+  | RTLD_DEEPBIND
+
+let unknown = "unknown_error"
+let nomem = "no memory"
+
+let nonl s =
+  let l = String.length s in
+  if l = 0 || s.[l-1] <> '\n' then
+    s
+  else
+    let nl = if l > 1 && s.[l-2] = '\r' then l - 2 else l - 1 in
+    String.sub s 0 nl
+
+let replace_slash s =
+  let l = String.length s in
+  let b = Bytes.create l in
+  (* according to msdn, slashes are not supported for LoadLibrary *)
+  for i = 0 to pred l do
+    match s.[i] with
+      | '/' -> Bytes.set b i '\\'
+      | x   -> Bytes.set b i x
+  done;
+  Bytes.unsafe_to_string b
+
+let dlopen_raise s msg =
+  let s =
+    match s with
+      | None -> "NULL"
+      | Some x -> x
+  in
+  let msg = Printf.sprintf "dlopen (%s): %s" s (nonl msg) in
+  raise (DL_error msg)
+
+let dlopen ?filename ~flags =
+  let filename =
+    match filename with
+      | None -> None
+      | (Some x) as sx ->
+        let s =
+          if String.contains x '/' then
+            replace_slash x
+          else
+            x
+        in
+        let ls = String.lowercase s in
+        let s' =
+          if Filename.check_suffix ls ".so" ||
+            Filename.check_suffix ls ".dylib"
+          then
+            Filename.chop_extension s ^ ".dll"
+          else
+            s
+        in
+        if s' == x then sx else Some s'
+  in
+  let iflags =
+    (if List.mem RTLD_NOLOAD flags then 1 else 0) +
+    (if List.mem RTLD_NODELETE flags then 2 else 0)
+  in
+  match _dlopen filename iflags with
+    | Dlop_ok x -> x
+    | Dlop_nomem -> dlopen_raise filename nomem
+    | Dlop_unknown -> dlopen_raise filename unknown
+    | Dlop_error s -> dlopen_raise filename s
+    | Dlop_notloaded -> raise (DL_error "library not loaded")
+
+let draise y x = raise (DL_error ( y ^ ": " ^ nonl x))
+
+let dlclose ~handle =
+  match _dlclose handle with
+    | Dlcl_ok -> ()
+    | Dlcl_unknown -> draise "dlclose" unknown
+    | Dlcl_nomem -> draise "dlclose" nomem
+    | Dlcl_error s -> draise "dlclose" s
+
+let dlsym ?handle ~symbol =
+  let r =
+    match handle with
+      | None -> _dlsym_default symbol
+      | Some x -> _dlsym x symbol
+  in
+  match r with
+    | Dlsy_ok v -> v
+    | Dlsy_unknown -> draise "dlsym" unknown
+    | Dlsy_nomem -> draise "dlsym" nomem
+    | Dlsy_enoent -> draise "dlsym" "no such symbol"
+    | Dlsy_error x -> draise "dlsym" x
diff --git a/src/ctypes-foreign-base/dl.mli b/src/ctypes-foreign-base/dl.mli
index 6b2b8e8..46afd33 100644
--- src/ctypes-foreign-base/dl.mli
+++ src/ctypes-foreign-base/dl.mli
@@ -15,7 +15,15 @@ exception DL_error of string
     {!dlsym}.  The argument is the string returned by the [dlerror]
     function. *)
 
-(** Flags for {!dlopen} *)
+(** Flags for {!dlopen}
+
+Note for windows users: Only [RTLD_NOLOAD] and [RTLD_NODELETE] are supported.
+Passing no or any other flags to {!dlopen} will result in standard behaviour:
+just LoadLibrary is called. If [RTLD_NOLOAD] is specified and the module is
+not already loaded, a {!DL_error} with the string "library not loaded" is
+thrown; there is however no test, if such a library exists at all (like under
+linux).
+*)
 type flag = 
     RTLD_LAZY
   | RTLD_NOW
@@ -25,10 +33,12 @@ type flag =
   | RTLD_DEEPBIND
 
 val dlopen : ?filename:string -> flags:flag list -> library
-(** Open a dynamic library. *)
+(** Open a dynamic library.
+
+Note for windows users: the filename must be encoded in UTF-8 *)
 
 val dlclose : handle:library -> unit
 (** Close a dynamic library. *)
 
-val dlsym : ?handle:library -> symbol:string -> Ctypes_raw.voidp
+val dlsym : ?handle:library -> symbol:string -> Ctypes_ptr.voidp
 (** Look up a symbol in a dynamic library. *)
diff --git a/src/ctypes-foreign-base/dl_stubs.c b/src/ctypes-foreign-base/dl_stubs.c
deleted file mode 100644
index 34c9859..0000000
--- src/ctypes-foreign-base/dl_stubs.c
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (c) 2013 Jeremy Yallop.
- *
- * This file is distributed under the terms of the MIT License.
- * See the file LICENSE for details.
- */
-
-#define _GNU_SOURCE
-#include <dlfcn.h>
-
-#include <caml/mlvalues.h>
-#include <caml/memory.h>
-#include <caml/alloc.h>
-
-#include <assert.h>
-#include <stdint.h>
-
-#define Val_none Val_int(0)
-#define Some_val(v) Field(v, 0)
-
-enum dl_flags_caml {
-  _RTLD_LAZY,
-  _RTLD_NOW,
-  _RTLD_GLOBAL,
-#ifdef RTLD_NODELETE
-  _RTLD_NODELETE,
-#endif /* RTLD_NODELETE */
-#ifdef RTLD_NOLOAD
-  _RTLD_NOLOAD,
-#endif /* RTLD_NOLOAD */
-#ifdef RTLD_DEEPBIND
-  _RTLD_DEEPBIND,
-#endif /* RTLD_DEEPBIND */
-};
-
-static value Val_some(value v)
-{
-    CAMLparam1(v);
-    CAMLlocal1(some);
-    some = caml_alloc(1, 0);
-    Store_field(some, 0, v);
-    CAMLreturn(some);
-}
-
-/* ctypes_resolve_dl_flag : flag -> int */
-value ctypes_resolve_dl_flag(value flag)
-{
-  int rv;
-
-  switch (Int_val(flag))
-  {
-    case _RTLD_LAZY:     rv = RTLD_LAZY;     break;
-    case _RTLD_NOW:      rv = RTLD_NOW;      break;
-    case _RTLD_GLOBAL:   rv = RTLD_GLOBAL;   break;
-#ifdef RTLD_NODELETE
-    case _RTLD_NODELETE: rv = RTLD_NODELETE; break;
-#endif /* RTLD_NODELETE */
-#ifdef RTLD_NOLOAD
-    case _RTLD_NOLOAD:   rv = RTLD_NOLOAD;   break;
-#endif /* RTLD_NOLOAD */
-#ifdef RTLD_DEEPBIND
-    case _RTLD_DEEPBIND: rv = RTLD_DEEPBIND; break;
-#endif /* RTLD_DEEPBIND */
-    default: assert(0);
-  }
-
-  return Val_int(rv);
-}
-
-/* ctypes_dlopen : filename:string -> flags:int -> library option */
-value ctypes_dlopen(value filename, value flag)
-{
-  CAMLparam2(filename, flag);
-
-  char *cfilename = filename == Val_none ? NULL : String_val(Some_val(filename));
-  int cflag = Int_val(flag);
-
-  void *handle = dlopen(cfilename, cflag);
-  CAMLreturn (handle != NULL ? Val_some((value)handle) : Val_none);
-}
-
-/* ctypes_dlsym : ?handle:library -> symbol:string -> cvalue option */
-value ctypes_dlsym(value handle_option, value symbol)
-{
-  CAMLparam2(handle_option, symbol);
-
-  void *handle = handle_option == Val_none
-    ? RTLD_DEFAULT
-    : (void *)Some_val(handle_option);
-
-  char *s = String_val(symbol);
-  void *result = dlsym(handle, s);
-  CAMLreturn(result == NULL
-             ? Val_none
-             : Val_some(caml_copy_int64((intptr_t)result)));
-}
-
-
-/* ctypes_dlclose : handle:library -> int */
-value ctypes_dlclose(value handle)
-{
-  return Val_int(dlclose((void *)handle));
-}
-
-/* ctypes_dlerror : unit -> string option */
-value ctypes_dlerror(value unit)
-{
-  CAMLparam1(unit);
-  const char *error = dlerror();
-  CAMLreturn (error != NULL ? Val_some(caml_copy_string(error)) : Val_none);
-}
diff --git a/src/ctypes-foreign-base/dl_stubs.c.unix b/src/ctypes-foreign-base/dl_stubs.c.unix
new file mode 100644
index 0000000..e5e8f82
--- /dev/null
+++ src/ctypes-foreign-base/dl_stubs.c.unix
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2013 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ */
+
+#define _GNU_SOURCE
+#include <dlfcn.h>
+
+#include <caml/mlvalues.h>
+#include <caml/memory.h>
+#include <caml/alloc.h>
+
+#include <assert.h>
+#include <stdint.h>
+
+#define Val_none Val_int(0)
+#define Some_val(v) Field(v, 0)
+
+enum dl_flags_caml {
+  _RTLD_LAZY,
+  _RTLD_NOW,
+  _RTLD_GLOBAL,
+#ifdef RTLD_NODELETE
+  _RTLD_NODELETE,
+#endif /* RTLD_NODELETE */
+#ifdef RTLD_NOLOAD
+  _RTLD_NOLOAD,
+#endif /* RTLD_NOLOAD */
+#ifdef RTLD_DEEPBIND
+  _RTLD_DEEPBIND,
+#endif /* RTLD_DEEPBIND */
+};
+
+static value Val_some(value v)
+{
+    CAMLparam1(v);
+    CAMLlocal1(some);
+    some = caml_alloc(1, 0);
+    Store_field(some, 0, v);
+    CAMLreturn(some);
+}
+
+/* ctypes_resolve_dl_flag : flag -> int */
+value ctypes_resolve_dl_flag(value flag)
+{
+  int rv;
+
+  switch (Int_val(flag))
+  {
+    case _RTLD_LAZY:     rv = RTLD_LAZY;     break;
+    case _RTLD_NOW:      rv = RTLD_NOW;      break;
+    case _RTLD_GLOBAL:   rv = RTLD_GLOBAL;   break;
+#ifdef RTLD_NODELETE
+    case _RTLD_NODELETE: rv = RTLD_NODELETE; break;
+#endif /* RTLD_NODELETE */
+#ifdef RTLD_NOLOAD
+    case _RTLD_NOLOAD:   rv = RTLD_NOLOAD;   break;
+#endif /* RTLD_NOLOAD */
+#ifdef RTLD_DEEPBIND
+    case _RTLD_DEEPBIND: rv = RTLD_DEEPBIND; break;
+#endif /* RTLD_DEEPBIND */
+    default: assert(0);
+  }
+
+  return Val_int(rv);
+}
+
+/* ctypes_dlopen : filename:string -> flags:int -> library option */
+value ctypes_dlopen(value filename, value flag)
+{
+  CAMLparam2(filename, flag);
+
+  char *cfilename = filename == Val_none ? NULL : String_val(Some_val(filename));
+  int cflag = Int_val(flag);
+
+  void *handle = dlopen(cfilename, cflag);
+  CAMLreturn (handle != NULL ? Val_some((value)handle) : Val_none);
+}
+
+/* ctypes_dlsym : ?handle:library -> symbol:string -> cvalue option */
+value ctypes_dlsym(value handle_option, value symbol)
+{
+  CAMLparam2(handle_option, symbol);
+
+  void *handle = handle_option == Val_none
+    ? RTLD_DEFAULT
+    : (void *)Some_val(handle_option);
+
+  char *s = String_val(symbol);
+  void *result = dlsym(handle, s);
+  CAMLreturn(result == NULL
+             ? Val_none
+             : Val_some(caml_copy_nativeint((intptr_t)result)));
+}
+
+
+/* ctypes_dlclose : handle:library -> int */
+value ctypes_dlclose(value handle)
+{
+  return Val_int(dlclose((void *)handle));
+}
+
+/* ctypes_dlerror : unit -> string option */
+value ctypes_dlerror(value unit)
+{
+  CAMLparam1(unit);
+  const char *error = dlerror();
+  CAMLreturn (error != NULL ? Val_some(caml_copy_string(error)) : Val_none);
+}
diff --git a/src/ctypes-foreign-base/dl_stubs.c.win b/src/ctypes-foreign-base/dl_stubs.c.win
new file mode 100644
index 0000000..c67d03d
--- /dev/null
+++ src/ctypes-foreign-base/dl_stubs.c.win
@@ -0,0 +1,281 @@
+/*
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ */
+
+/* for compatiblity with Windows Vista and XP */
+#define PSAPI_VERSION 1
+#include <windows.h>
+#include <psapi.h>
+
+#include <caml/mlvalues.h>
+#include <caml/memory.h>
+#include <caml/alloc.h>
+
+#define STUB_ERROR_UNKNOWN (Val_long(0))
+#define STUB_ERROR_NOMEM (Val_long(1))
+#define STUB_TAG_ERROR 0
+
+static value
+get_tagged_error_msg(DWORD ecode)
+{
+  CAMLparam0();
+  CAMLlocal1(msg);
+  value ret=STUB_ERROR_UNKNOWN;
+  if ( ecode ){
+    char buf[512];
+    DWORD len ;
+    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
+                        NULL,
+                        ecode,
+                        MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
+                        buf,
+                        sizeof(buf),
+                        NULL);
+    if (len){
+      msg=caml_copy_string(buf);
+      ret=caml_alloc_small(1,STUB_TAG_ERROR);
+      Field(ret,0)=msg;
+    }
+  }
+  CAMLreturn(ret);
+}
+
+static value
+utf8_to_wstring(value utf8string)
+{
+  CAMLparam1(utf8string);
+  value ret;
+  int n;
+  WCHAR *result;
+  n = MultiByteToWideChar(CP_UTF8,0,String_val(utf8string),-1, NULL,0);
+  if (!n){
+    ret=Val_unit;
+    goto endp;
+  }
+  ret = caml_alloc_string(n * sizeof(*result));
+  result = (WCHAR *)String_val(ret);
+  if ( n != MultiByteToWideChar(CP_UTF8,0,String_val(utf8string),-1,result,n) ){
+    ret = Val_unit;
+  }
+endp:
+  CAMLreturn(ret);
+}
+
+
+/*
+  In order to get a list of all used dlls, we can use the following approaches:
+  - EnumProcessModules (psapi.dll on older windows versions)
+  - RtlQueryProcessDebugInformation (no documented by microsoft, seems to be
+     slower than EnumProcessModules)
+  - CreateToolhelp32Snapshot (even slower,
+     see http://securityxploded.com/enumheaps.php)
+  - using NtQueryInformationProcess (low level and fiddly)
+ details:
+ https://sites.google.com/site/ericuday/EICAR2008_UserMode_Memory_Scanning_3.doc
+ (Eric Uday Kumar: User-mode memory scanning on 32-bit & 64-bit windows)
+*/
+
+/*
+  integer:
+    0: unknown error
+    1: nomem
+    2: enoent
+  blocks of size 1:
+    0: error message
+    1: success handle
+*/
+value
+ctypes_win32_dlsym_rtld_default(value needle)
+{
+  CAMLparam1(needle);
+  CAMLlocal2(ret,tmp);
+  HMODULE hmodules[128];
+  HMODULE *r_modules = hmodules;
+  HANDLE proc = NULL;
+  DWORD bytes_hmodules;
+  DWORD bytes_hmodules_real;
+  DWORD i;
+  proc = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
+                      FALSE, GetCurrentProcessId() );
+  if ( !proc ){
+    ret=get_tagged_error_msg(GetLastError());
+    goto endp;
+  }
+  if( ! EnumProcessModules(proc, r_modules, sizeof(hmodules), &bytes_hmodules)){
+    DWORD ec = GetLastError();
+    CloseHandle(proc);
+    ret=get_tagged_error_msg(ec);
+    goto endp;
+  }
+  bytes_hmodules_real = bytes_hmodules;
+  if ( bytes_hmodules > sizeof(hmodules) ){
+    r_modules=malloc(bytes_hmodules);
+    if ( !r_modules ){
+      ret=STUB_ERROR_NOMEM;
+      CloseHandle(proc);
+      goto endp;
+    }
+    if(!EnumProcessModules(proc,
+                           r_modules,
+                           bytes_hmodules,
+                           &bytes_hmodules_real)){
+      DWORD ec = GetLastError();
+      free(r_modules);
+      CloseHandle(proc);
+      ret=get_tagged_error_msg(ec);
+      goto endp;
+    }
+    bytes_hmodules_real =
+      bytes_hmodules < bytes_hmodules_real ?
+      bytes_hmodules : bytes_hmodules_real;
+  }
+  for ( i = 0; i < (bytes_hmodules_real / sizeof(HMODULE)); i++ )
+  {
+    FARPROC result=GetProcAddress(r_modules[i],String_val(needle));
+    if ( result ){
+      if ( r_modules != hmodules ){
+        free(r_modules);
+      }
+      CloseHandle(proc);
+      tmp=caml_copy_nativeint((intnat)result);
+      ret=caml_alloc_small(1,1);
+      Field(ret,0)=tmp;
+      goto endp;
+    }
+  }
+  ret=Val_long(2); /* enoent */
+  CloseHandle(proc);
+  if ( r_modules != hmodules ){
+    free(r_modules);
+  }
+endp:
+  CAMLreturn(ret);
+}
+
+/*
+  integer:
+    0: unknown error
+    1: nomem
+  block of size one:
+    0: error message
+    1: success handle
+*/
+value
+ctypes_win32_dlsym(value handle,value sym)
+{
+  CAMLparam2(handle,sym);
+  CAMLlocal2(ret,tmp);
+  PROC p = GetProcAddress((HMODULE)Nativeint_val(handle), String_val(sym));
+  if ( !p ){
+    ret=get_tagged_error_msg(GetLastError());
+  }
+  else {
+    tmp=caml_copy_nativeint((intnat)p);
+    ret=caml_alloc_small(1,1);
+    Field(ret,0)=tmp;
+  }
+  CAMLreturn(ret);
+}
+
+#define Val_none Val_long(0)
+#define Some_val(v) Field(v, 0)
+
+/*
+  integer:
+    0: unknown error
+    1: nomem
+    2: not loaded
+  block of size one:
+    0: error msg;
+    1: handle;
+*/
+value
+ctypes_win32_dlopen(value filename, value flags)
+{
+  CAMLparam1(filename);
+  CAMLlocal2(ret,tmp);
+  if ( filename == Val_none ){
+    HMODULE p = GetModuleHandle(NULL);
+    if ( !p ){
+      ret=get_tagged_error_msg(GetLastError());
+    }
+    else {
+      tmp = caml_copy_nativeint((intnat)p);
+      ret=caml_alloc_small(1,1);
+      Field(ret,0)=tmp;
+    }
+  }
+  else {
+    intnat iflags = Long_val(flags);
+    HMODULE p;
+    UINT e_mode;
+    DWORD ec;
+
+    filename=utf8_to_wstring(Some_val(filename));
+    if ( filename == Val_unit ){
+      tmp=caml_copy_string("invalid filename");
+      ret=caml_alloc_small(1,STUB_TAG_ERROR);
+      Field(ret,0)=tmp;
+      goto endp;
+    }
+    if ( iflags & 1 ){ /* RTLD_NOLOAD */
+      p= GetModuleHandleW((WCHAR *)String_val(filename));
+      if ( !p ){
+        ret=Val_long(2);
+        goto endp;
+      }
+      /* Note: If GetModuleHandle succeeds, we still need to
+         call LoadLibrary in order to increase the reference count
+         for the module. */
+    }
+    /* allocations first, so we are not responsible for not
+       decreasing the reference count, if we are out of
+       memory or another thread does something strange */
+    tmp = caml_copy_nativeint(0);
+    ret = caml_alloc_small(1,1);
+    Field(ret,0)=tmp;
+    /* some windows version show a message box without this */
+    e_mode = SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);
+    p=LoadLibraryW((WCHAR *)String_val(filename));
+    if ( !p ){
+      ec = GetLastError();
+    }
+    SetErrorMode(e_mode); /* restores the previous state */
+    if ( !p ){
+      ret=get_tagged_error_msg(ec);
+      goto endp;
+    }
+    *((intnat *)Data_custom_val(tmp))=(intnat)p;
+    if (iflags & 2 ){ /* RTLD_NODELETE */
+      GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_PIN,
+                         (WCHAR *)String_val(filename),
+                         &p);
+    }
+  }
+endp:
+  CAMLreturn(ret);
+}
+
+/*
+  integer:
+    0: unknown error
+    1: nomem
+    2: ok
+  block of size one:
+    0: error msg
+*/
+value
+ctypes_win32_dlclose(value ohandle)
+{
+  CAMLparam1(ohandle);
+  CAMLlocal1(ret);
+  ret= Val_long(2);
+  HMODULE handle = (HMODULE) Nativeint_val(ohandle);
+  if (handle && handle != GetModuleHandle(NULL)){
+    if (!FreeLibrary(handle)){
+      ret=get_tagged_error_msg(GetLastError());
+    }
+  }
+  CAMLreturn(ret);
+}
diff --git a/src/ctypes-foreign-base/ffi.ml b/src/ctypes-foreign-base/ffi.ml
index 44df403..38d2bd4 100644
--- src/ctypes-foreign-base/ffi.ml
+++ src/ctypes-foreign-base/ffi.ml
@@ -27,8 +27,8 @@ struct
   let () = Ffi_stubs.set_closure_callback Closure_properties.retrieve
 
   type _ ccallspec =
-      Call : bool * (Ctypes_raw.voidp -> 'a) -> 'a ccallspec
-    | WriteArg : ('a -> Ctypes_raw.voidp -> (Obj.t * int) array -> unit) * 'b ccallspec ->
+      Call : bool * (Ctypes_ptr.voidp -> 'a) -> 'a ccallspec
+    | WriteArg : ('a -> Ctypes_ptr.voidp -> (Obj.t * int) array -> unit) * 'b ccallspec ->
                  ('a -> 'b) ccallspec
 
   type arg_type = ArgType : 'a Ffi_stubs.ffitype -> arg_type
@@ -47,7 +47,7 @@ struct
   let rec arg_type : type a. a typ -> arg_type = function
     | Void                                -> ArgType (Ffi_stubs.void_ffitype ())
     | Primitive p as prim                 -> let ffitype = Ffi_stubs.primitive_ffitype p in
-                                             if ffitype = Ctypes_raw.null
+                                             if ffitype = Ctypes_ptr.Raw.null
                                              then report_unpassable
                                                (Type_printing.string_of_typ prim)
                                              else ArgType ffitype
@@ -76,13 +76,6 @@ struct
        Ffi_stubs.complete_struct_type bufspec;
        ArgType (Ffi_stubs.ffi_type_of_struct_type bufspec)
 
-
-  let pick_call_stub check_errno name =
-    match check_errno, name with
-    | true, Some name -> Ffi_stubs.call_errno name
-    | true, None      -> Ffi_stubs.call_errno ""
-    | false, _        -> Ffi_stubs.call
-
   (*
     call addr callspec
      (fun buffer ->
@@ -94,15 +87,15 @@ struct
   *)
   let rec invoke : type a. string option ->
                            a ccallspec ->
-                           (Ctypes_raw.voidp -> (Obj.t * int) array -> unit) list ->
+                           (Ctypes_ptr.voidp -> (Obj.t * int) array -> unit) list ->
                            Ffi_stubs.callspec ->
-                           Ctypes_raw.voidp ->
+                           unit typ Ctypes_ptr.Fat.t ->
                         a
     = fun name -> function
       | Call (check_errno, read_return_value) ->
-        let call = pick_call_stub check_errno name in
+        let name = match name with Some name -> name | None -> "" in
         fun writers callspec addr ->
-          call addr callspec
+          Ffi_stubs.call name addr callspec
             (fun buf arr -> List.iter (fun w -> w buf arr) writers)
             read_return_value
       | WriteArg (write, ccallspec) ->
@@ -126,14 +119,17 @@ struct
       | Returns ty ->
         let () = prep_callspec callspec abi ty in
         let write_rv = Memory.write ty in
-        fun f -> Ffi_stubs.Done (write_rv ~offset:0 (WeakRef.get f), callspec)
+        fun f ->
+          let w = write_rv (WeakRef.get f) in
+          Ffi_stubs.Done ((fun p -> w (Ctypes_ptr.Fat.make ~reftyp:Void p)),
+                          callspec)
       | Function (p, f) ->
         let _ = add_argument callspec p in
         let box = box_function abi f callspec in
-        let read = Memory.build p ~offset:0 in
+        let read = Memory.build p in
         fun f -> Ffi_stubs.Fn (fun buf ->
           let f' =
-            try WeakRef.get f (read buf)
+            try WeakRef.get f (read (Ctypes_ptr.Fat.make ~reftyp:Void buf))
             with WeakRef.EmptyWeakReference ->
               raise Ffi_stubs.CallToExpiredClosure
           in
@@ -142,7 +138,7 @@ struct
           v)
 
   let write_arg : type a. a typ -> offset:int -> idx:int -> a ->
-                  Ctypes_raw.voidp -> (Obj.t * int) array -> unit =
+                  Ctypes_ptr.voidp -> (Obj.t * int) array -> unit =
     let ocaml_arg elt_size =
       fun ~offset ~idx (OCamlRef (disp, obj, _)) dst mov ->
         mov.(idx) <- (Obj.repr obj, disp * elt_size)
@@ -150,7 +146,8 @@ struct
     | OCaml String     -> ocaml_arg 1
     | OCaml Bytes      -> ocaml_arg 1
     | OCaml FloatArray -> ocaml_arg (Ctypes_primitives.sizeof Primitives.Double)
-    | ty -> (fun ~offset ~idx v dst mov -> Memory.write ty ~offset v dst)
+    | ty -> (fun ~offset ~idx v dst mov -> Memory.write ty v
+      (Ctypes_ptr.Fat.(add_bytes (make ~reftyp:Void dst) offset)))
 
   (*
     callspec = allocate_callspec ()
@@ -165,26 +162,32 @@ struct
     = fun ~abi ~check_errno ?(idx=0) fn callspec -> match fn with
       | Returns t ->
         let () = prep_callspec callspec abi t in
-        Call (check_errno, Memory.build t ~offset:0)
+        let b = Memory.build t in
+        Call (check_errno, (fun p -> b (Ctypes_ptr.Fat.make ~reftyp:Void p)))
       | Function (p, f) ->
         let offset = add_argument callspec p in
         let rest = build_ccallspec ~abi ~check_errno ~idx:(idx+1) f callspec in
         WriteArg (write_arg p ~offset ~idx, rest)
 
-  let build_function ?name ~abi ~check_errno fn =
-    let c = Ffi_stubs.allocate_callspec () in
+  let build_function ?name ~abi ~release_runtime_lock ~check_errno fn =
+    let c = Ffi_stubs.allocate_callspec ~check_errno
+      ~runtime_lock:release_runtime_lock
+    in
     let e = build_ccallspec ~abi ~check_errno fn c in
     invoke name e [] c
 
   let ptr_of_rawptr raw_ptr =
-    CPointer { raw_ptr ; pbyte_offset = 0; reftype = void; pmanaged = None; }
+    CPointer (Ctypes_ptr.Fat.make ~reftyp:void raw_ptr)
 
-  let function_of_pointer ?name ~abi ~check_errno fn =
-    let f = build_function ?name ~abi ~check_errno fn in
-    fun (CPointer {raw_ptr}) -> f raw_ptr
+  let function_of_pointer ?name ~abi ~check_errno ~release_runtime_lock fn =
+    let f = build_function ?name ~abi ~check_errno ~release_runtime_lock fn in
+    fun (CPointer p) -> f p
 
-  let pointer_of_function ~abi fn =
-    let cs' = Ffi_stubs.allocate_callspec () in
+  let pointer_of_function ~abi ~acquire_runtime_lock fn =
+    let cs' = Ffi_stubs.allocate_callspec
+      ~check_errno:false
+      ~runtime_lock:acquire_runtime_lock
+    in
     let cs = box_function abi fn cs' in
     fun f ->
       let boxed = cs (WeakRef.make f) in
diff --git a/src/ctypes-foreign-base/ffi.mli b/src/ctypes-foreign-base/ffi.mli
index 434402a..249f290 100644
--- src/ctypes-foreign-base/ffi.mli
+++ src/ctypes-foreign-base/ffi.mli
@@ -25,11 +25,12 @@ sig
   (** Dynamic function calls based on libffi *)
 
   val function_of_pointer : ?name:string -> abi:abi -> check_errno:bool ->
-    ('a -> 'b) fn -> unit ptr -> ('a -> 'b)
+    release_runtime_lock:bool -> ('a -> 'b) fn -> unit ptr -> ('a -> 'b)
   (** Build an OCaml function from a type specification and a pointer to a C
       function. *)
 
-  val pointer_of_function : abi:abi -> ('a -> 'b) fn -> ('a -> 'b) -> unit ptr
+  val pointer_of_function : abi:abi -> acquire_runtime_lock:bool -> ('a -> 'b) fn ->
+    ('a -> 'b) -> unit ptr
   (** Build an C function from a type specification and an OCaml function.
 
       The C function pointer returned is callable as long as the OCaml function
diff --git a/src/ctypes-foreign-base/ffi_call_stubs.c b/src/ctypes-foreign-base/ffi_call_stubs.c
index e18008c..5672d06 100644
--- src/ctypes-foreign-base/ffi_call_stubs.c
+++ src/ctypes-foreign-base/ffi_call_stubs.c
@@ -17,6 +17,7 @@
 #include <caml/fail.h>
 #include <caml/hash.h>
 #include <caml/unixsupport.h>
+#include <caml/threads.h>
 
 #include <ffi.h>
 
@@ -27,8 +28,6 @@
 /* TODO: support callbacks that raise exceptions?  e.g. using
    caml_callback_exn etc.  */
 
-/* TODO: thread support */
-
 /* An OCaml function that converts resolves identifiers to OCaml functions */
 static value retrieve_closure_;
 
@@ -106,7 +105,7 @@ static struct callspec {
   /* The maximum element alignment */
   size_t max_align;
 
-  /* The state of the bufferspec value. */
+  /* The state of the callspec value. */
   enum { BUILDING, CALLSPEC } state;
 
   /* A null-terminated array of size `nelements' types */
@@ -115,6 +114,13 @@ static struct callspec {
   /* return value offset */
   size_t roffset;
 
+  /* The context in which the call should run: whether errno is
+     checked, whether the runtime lock is released, and so on. */
+  struct call_context {
+    int check_errno;
+    int runtime_lock;
+  } context;
+
   /* The libffi call interface structure.  It would be nice for this member to
      be a value rather than a pointer (to save a layer of indirection) but the
      ffi_closure structure keeps the address of the structure, and the GC can
@@ -123,11 +129,11 @@ static struct callspec {
   ffi_cif *cif;
 
 } callspec_prototype = {
-  0, 0, 0, 0, BUILDING, NULL, -1, NULL
+  0, 0, 0, 0, BUILDING, NULL, -1, { 0, 0 }, NULL
 };
 
 
-static void finalize_bufferspec(value v)
+static void finalize_callspec(value v)
 {
   struct callspec *callspec = Data_custom_val(v);
   free(callspec->args);
@@ -136,8 +142,8 @@ static void finalize_bufferspec(value v)
 
 
 static struct custom_operations callspec_custom_ops = {
-  "ocaml-ctypes:bufferspec",
-  finalize_bufferspec,
+  "ocaml-ctypes:callspec",
+  finalize_callspec,
   custom_compare_default,
   custom_hash_default,
   custom_serialize_default,
@@ -187,13 +193,19 @@ static void populate_arg_array(struct callspec *callspec,
 
 
 /* Allocate a new C call specification */
-/* allocate_callspec : unit -> callspec */
-value ctypes_allocate_callspec(value unit)
+/* allocate_callspec : check_errno:bool -> runtime_lock:bool -> callspec */
+value ctypes_allocate_callspec(value check_errno, value runtime_lock)
 {
+  struct call_context context = {
+    Int_val(check_errno),
+    Int_val(runtime_lock),
+  };
+
   value block = caml_alloc_custom(&callspec_custom_ops,
                                   sizeof(struct callspec), 0, 1);
-  memcpy(Data_custom_val(block), &callspec_prototype,
-         sizeof(struct callspec));
+  struct callspec *spec = Data_custom_val(block);
+  memcpy(spec, &callspec_prototype, sizeof(struct callspec));
+  spec->context = context;
   return block;
 }
 
@@ -275,16 +287,19 @@ value ctypes_prep_callspec(value callspec_, value abi_, value rtype)
 
 /* Call the function specified by `callspec', passing arguments and return
    values in `buffer' */
-/* call : raw_pointer -> callspec -> (raw_pointer -> Obj.t array -> unit) ->
-          (raw_pointer -> 'a) -> 'a */
-value ctypes_call(value function, value callspec_, value argwriter, value rvreader)
+/* call : string -> raw_pointer -> callspec ->
+          (raw_pointer -> Obj.t array -> unit) -> (raw_pointer -> 'a) -> 'a */
+value ctypes_call(value fnname, value function, value callspec_,
+                  value argwriter, value rvreader)
 {
-  CAMLparam4(function, callspec_, argwriter, rvreader);
+  CAMLparam5(fnname, function, callspec_, argwriter, rvreader);
   CAMLlocal3(callback_arg_buf, callback_val_arr, callback_rv_buf);
 
   struct callspec *callspec = Data_custom_val(callspec_);
   int roffset = callspec->roffset;
+  struct call_context context = callspec->context;
   size_t nelements = callspec->nelements;
+  ffi_cif *cif = callspec->cif;
 
   assert(callspec->state == CALLSPEC);
 
@@ -319,43 +334,44 @@ value ctypes_call(value function, value callspec_, value argwriter, value rvread
     ((void**)(callbuffer + arg_array_offset))[arg_idx] = &val_refs[arg_idx];
   }
 
-  void (*cfunction)(void) = (void (*)(void)) CTYPES_TO_PTR(function);
+  void (*cfunction)(void) = (void (*)(void)) CTYPES_ADDR_OF_FATPTR(function);
 
-  ffi_call(((struct callspec *)Data_custom_val(callspec_))->cif,
+  if (context.check_errno)
+  {
+    errno = 0;
+  }
+  if (context.runtime_lock)
+  {
+    caml_release_runtime_system();
+  }
+
+  ffi_call(cif,
            cfunction,
            return_slot,
            (void **)(callbuffer + arg_array_offset));
 
-  callback_rv_buf = CTYPES_FROM_PTR(return_slot);
-  CAMLreturn(caml_callback(rvreader, callback_rv_buf));
-}
-
-
-/* call_errno : string -> raw_pointer -> callspec ->
-               (raw_pointer -> unit) ->
-               (raw_pointer -> 'a) -> 'a */
-value ctypes_call_errno(value fnname, value function, value callspec_,
-                        value argwriter, value rvreader)
-{
-  CAMLparam5(fnname, function, callspec_, argwriter, rvreader);
+  if (context.runtime_lock)
+  {
+    caml_acquire_runtime_system();
+  }
 
-  errno = 0;
-  CAMLlocal1(rv);
-  rv = ctypes_call(function, callspec_, argwriter, rvreader);
-  if (errno != 0)
+  if (context.check_errno && errno != 0)
   {
     char *buffer = alloca(caml_string_length(fnname) + 1);
     strcpy(buffer, String_val(fnname));
     unix_error(errno, buffer, Nothing);
   }
-  CAMLreturn(rv);
+
+  callback_rv_buf = CTYPES_FROM_PTR(return_slot);
+  CAMLreturn(caml_callback(rvreader, callback_rv_buf));
 }
 
 typedef struct closure closure;
 struct closure
 {
-  ffi_closure closure;
-  int         fnkey;
+  ffi_closure         closure;
+  int                 fnkey;
+  struct call_context context;
 };
 
 enum boxedfn_tags { Done, Fn };
@@ -368,16 +384,37 @@ static void callback_handler(ffi_cif *cif,
   CAMLparam0 ();
 
   CAMLlocal2(boxedfn, argptr);
-  boxedfn = retrieve_closure(*(int *)user_data);
+  closure *closure = user_data;
+
+  if (closure->context.runtime_lock)
+  {
+    caml_acquire_runtime_system();
+  }
+
+  boxedfn = retrieve_closure(closure->fnkey);
 
   int i, arity = cif->nargs;
-  for (i = 0; i < arity; i++)
+
+  switch (arity)
   {
-    void *cvalue = args[i];
-    assert (Tag_val(boxedfn) == Fn);
-    /* unbox and call */
-    argptr = CTYPES_FROM_PTR(cvalue);
-    boxedfn = caml_callback(Field(boxedfn, 0), argptr);
+    case 0:
+    {
+      assert (Tag_val(boxedfn) == Fn);
+      boxedfn = caml_callback(Field(boxedfn, 0), Val_unit);
+      break;
+    }
+    default:
+    {
+      for (i = 0; i < arity; i++)
+      {
+        void *cvalue = args[i];
+        assert (Tag_val(boxedfn) == Fn);
+        /* unbox and call */
+        argptr = CTYPES_FROM_PTR(cvalue);
+        boxedfn = caml_callback(Field(boxedfn, 0), argptr);
+      }
+      break;
+    }
   }
 
   /* now store the return value */
@@ -385,6 +422,11 @@ static void callback_handler(ffi_cif *cif,
   argptr = CTYPES_FROM_PTR(ret);
   caml_callback(Field(boxedfn, 0), argptr);
 
+  if (closure->context.runtime_lock)
+  {
+    caml_release_runtime_system();
+  }
+
   CAMLreturn0;
 }
 
@@ -411,12 +453,13 @@ value ctypes_make_function_pointer(value callspec_, value fnid)
     caml_raise_out_of_memory();
   } else {
     closure->fnkey = Int_val(fnid);
+    closure->context = callspec->context;
 
     ffi_status status =  ffi_prep_closure_loc
       ((ffi_closure *)closure,
        callspec->cif,
        callback_handler,
-       &closure->fnkey,
+       closure,
        (void *)code_address);
 
     ctypes_check_ffi_status(status);
diff --git a/src/ctypes-foreign-base/ffi_stubs.ml b/src/ctypes-foreign-base/ffi_stubs.ml
index 26677a3..d9e9403 100644
--- src/ctypes-foreign-base/ffi_stubs.ml
+++ src/ctypes-foreign-base/ffi_stubs.ml
@@ -7,7 +7,7 @@
 
 (* Stubs for binding to libffi. *)
 
-open Ctypes_raw
+open Ctypes_ptr
 
 (* The type of structure types *)
 type 'a ffitype = voidp
@@ -41,7 +41,7 @@ external ffi_type_of_struct_type : struct_ffitype -> _ ffitype
 type callspec
 
 (* Allocate a new C call specification *)
-external allocate_callspec : unit -> callspec
+external allocate_callspec : check_errno:bool -> runtime_lock:bool -> callspec
   = "ctypes_allocate_callspec"
 
 (* Add an argument to the C buffer specification *)
@@ -55,15 +55,10 @@ external prep_callspec : callspec -> int -> _ ffitype -> unit
 (* Call the function specified by `callspec' at the given address.
    The callback functions write the arguments to the buffer and read
    the return value. *)
-external call : voidp -> callspec ->
+external call : string -> unit Static.typ Fat.t -> callspec ->
   (voidp -> (Obj.t * int) array -> unit) -> (voidp -> 'a) -> 'a
   = "ctypes_call"
 
-(* As ctypes_call, but check errno and raise Unix_error if the call failed. *)
-external call_errno : string -> voidp -> callspec ->
-  (voidp -> (Obj.t * int) array -> unit) -> (voidp -> 'a) -> 'a
-  = "ctypes_call_errno"
-
 
 (* nary callbacks *)
 type boxedfn =
diff --git a/src/ctypes-foreign-base/foreign_basis.ml b/src/ctypes-foreign-base/foreign_basis.ml
index 8199506..ec6288f 100644
--- src/ctypes-foreign-base/foreign_basis.ml
+++ src/ctypes-foreign-base/foreign_basis.ml
@@ -18,10 +18,13 @@ struct
     Type_printing.format_fn' fn
       (fun fmt -> Format.fprintf fmt "(*%t)" k) fmt
 
-  let funptr ?(abi=Libffi_abi.default_abi) ?name ?(check_errno=false) fn =
+  let funptr ?(abi=Libffi_abi.default_abi) ?name ?(check_errno=false)
+      ?(runtime_lock=false) fn =
     let open Ffi in
-    let read = function_of_pointer ~abi ~check_errno ?name fn
-    and write = pointer_of_function ~abi fn
+    let read = function_of_pointer
+      ~abi ~check_errno ~release_runtime_lock:runtime_lock ?name fn
+    and write = pointer_of_function
+      ~abi ~acquire_runtime_lock:runtime_lock fn
     and format_typ = format_function_pointer fn in
     Static.(view ~format_typ ~read ~write (ptr void))
 
@@ -30,16 +33,16 @@ struct
   let funptr_opt ?abi fn = Std_views.nullable_view (funptr ?abi fn)
 
   let ptr_of_raw_ptr p = 
-    Ctypes.ptr_of_raw_address (Ctypes_raw.PtrType.to_int64 p)
+    Ctypes.ptr_of_raw_address (Ctypes_ptr.Raw.to_nativeint p)
 
   let foreign_value ?from symbol t =
     from_voidp t (ptr_of_raw_ptr (dlsym ?handle:from ~symbol))
 
   let foreign ?(abi=Libffi_abi.default_abi) ?from ?(stub=false)
-      ?(check_errno=false) symbol typ =
+      ?(check_errno=false) ?(release_runtime_lock=false) symbol typ =
     try
       let coerce = Coerce.coerce (ptr void)
-        (funptr ~abi ~name:symbol ~check_errno typ) in
+        (funptr ~abi ~name:symbol ~check_errno ~runtime_lock:release_runtime_lock typ) in
       coerce (ptr_of_raw_ptr (dlsym ?handle:from ~symbol))
     with 
     | exn -> if stub then fun _ -> raise exn else raise exn
diff --git a/src/ctypes-foreign-threaded/foreign.mli b/src/ctypes-foreign-threaded/foreign.mli
index a59904f..ff49ada 100644
--- src/ctypes-foreign-threaded/foreign.mli
+++ src/ctypes-foreign-threaded/foreign.mli
@@ -12,6 +12,7 @@ val foreign :
   ?from:Dl.library ->
   ?stub:bool -> 
   ?check_errno:bool ->
+  ?release_runtime_lock:bool ->
   string ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b)
@@ -28,6 +29,13 @@ val foreign :
     The value [?check_errno], which defaults to [false], indicates whether
     {!Unix.Unix_error} should be raised if the C function modifies [errno].
 
+    The value [?release_runtime_lock], which defaults to [false], indicates
+    whether the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must not
+    call back into OCaml.
+
     @raise Dl.DL_error if [name] is not found in [?from] and [?stub] is
     [false]. *)
 
@@ -40,6 +48,7 @@ val funptr :
   ?abi:Libffi_abi.abi ->
   ?name:string ->
   ?check_errno:bool ->
+  ?runtime_lock:bool ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b) Ctypes.typ
 (** Construct a function pointer type from a function type.
@@ -51,7 +60,19 @@ val funptr :
     restrictions.
 
     The value [?check_errno], which defaults to [false], indicates whether
-    {!Unix.Unix_error} should be raised if the C function modifies [errno]. *)
+    {!Unix.Unix_error} should be raised if the C function modifies [errno].
+
+    The value [?runtime_lock], which defaults to [false], indicates whether
+    the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must
+    not call back into OCaml.  If the function pointer is used to call into
+    OCaml from C then the [?runtime_lock] argument indicates whether the lock
+    should be acquired and held during the call.
+
+    @raise Dl.DL_error if [name] is not found in [?from] and [?stub] is
+    [false]. *)
 
 val funptr_opt :
   ?abi:Libffi_abi.abi ->
diff --git a/src/ctypes-foreign-unthreaded/foreign.mli b/src/ctypes-foreign-unthreaded/foreign.mli
index a59904f..3915f18 100644
--- src/ctypes-foreign-unthreaded/foreign.mli
+++ src/ctypes-foreign-unthreaded/foreign.mli
@@ -12,6 +12,7 @@ val foreign :
   ?from:Dl.library ->
   ?stub:bool -> 
   ?check_errno:bool ->
+  ?release_runtime_lock:bool ->
   string ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b)
@@ -28,6 +29,13 @@ val foreign :
     The value [?check_errno], which defaults to [false], indicates whether
     {!Unix.Unix_error} should be raised if the C function modifies [errno].
 
+    The value [?release_runtime_lock], which defaults to [false], indicates
+    whether the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must not
+    call back into OCaml.
+
     @raise Dl.DL_error if [name] is not found in [?from] and [?stub] is
     [false]. *)
 
@@ -40,6 +48,7 @@ val funptr :
   ?abi:Libffi_abi.abi ->
   ?name:string ->
   ?check_errno:bool ->
+  ?runtime_lock:bool ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b) Ctypes.typ
 (** Construct a function pointer type from a function type.
@@ -51,7 +60,16 @@ val funptr :
     restrictions.
 
     The value [?check_errno], which defaults to [false], indicates whether
-    {!Unix.Unix_error} should be raised if the C function modifies [errno]. *)
+    {!Unix.Unix_error} should be raised if the C function modifies [errno].
+
+    The value [?runtime_lock], which defaults to [false], indicates whether
+    the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must
+    not call back into OCaml.  If the function pointer is used to call into
+    OCaml from C then the [?runtime_lock] argument indicates whether the lock
+    should be acquired and held during the call. *)
 
 val funptr_opt :
   ?abi:Libffi_abi.abi ->
diff --git a/src/ctypes-top/ctypes_printers.ml b/src/ctypes-top/ctypes_printers.ml
index 5b178b1..a988fdb 100644
--- src/ctypes-top/ctypes_printers.ml
+++ src/ctypes-top/ctypes_printers.ml
@@ -43,22 +43,10 @@ let format_array fmt v =
   Ctypes.(format CArray.(array (length v) (reference_type (start v))) fmt v)
 let format_ocaml fmt (Static.OCamlRef (_, _, ty) as v) =
   Ctypes.format (Static.OCaml ty) fmt v
-let format_blkcnt_t fmt v =
-  Ctypes.format PosixTypes.blkcnt_t fmt v
-let format_blksize_t fmt v =
-  Ctypes.format PosixTypes.blksize_t fmt v
 let format_clock_t fmt v =
   Ctypes.format PosixTypes.clock_t fmt v
 let format_dev_t fmt v =
   Ctypes.format PosixTypes.dev_t fmt v
-let format_fsblkcnt_t fmt v =
-  Ctypes.format PosixTypes.fsblkcnt_t fmt v
-let format_fsfilcnt_t fmt v =
-  Ctypes.format PosixTypes.fsfilcnt_t fmt v
-let format_gid_t fmt v =
-  Ctypes.format PosixTypes.gid_t fmt v
-let format_id_t fmt v =
-  Ctypes.format PosixTypes.id_t fmt v
 let format_ino_t fmt v =
   Ctypes.format PosixTypes.ino_t fmt v
 let format_mode_t fmt v =
@@ -73,11 +61,7 @@ let format_size_t fmt v =
   Ctypes.format PosixTypes.size_t fmt v
 let format_ssize_t fmt v =
   Ctypes.format PosixTypes.ssize_t fmt v
-let format_suseconds_t fmt v =
-  Ctypes.format PosixTypes.suseconds_t fmt v
 let format_time_t fmt v =
   Ctypes.format PosixTypes.time_t fmt v
-let format_uid_t fmt v =
-  Ctypes.format PosixTypes.uid_t fmt v
 let format_useconds_t fmt v =
   Ctypes.format PosixTypes.useconds_t fmt v
diff --git a/src/ctypes-top/ctypes_printers.mli b/src/ctypes-top/ctypes_printers.mli
index ea055b5..3c8a2a4 100644
--- src/ctypes-top/ctypes_printers.mli
+++ src/ctypes-top/ctypes_printers.mli
@@ -25,14 +25,8 @@ val format_struct : formatter -> ('a, 'b) Ctypes.structured -> unit
 val format_union : formatter -> ('a, 'b) Ctypes.structured -> unit
 val format_array : formatter -> 'a Ctypes.CArray.t -> unit
 val format_ocaml : formatter -> 'a Ctypes.ocaml -> unit
-val format_blkcnt_t : formatter -> PosixTypes.blkcnt_t -> unit
-val format_blksize_t : formatter -> PosixTypes.blksize_t -> unit
 val format_clock_t : formatter -> PosixTypes.clock_t -> unit
 val format_dev_t : formatter -> PosixTypes.dev_t -> unit
-val format_fsblkcnt_t : formatter -> PosixTypes.fsblkcnt_t -> unit
-val format_fsfilcnt_t : formatter -> PosixTypes.fsfilcnt_t -> unit
-val format_gid_t : formatter -> PosixTypes.gid_t -> unit
-val format_id_t : formatter -> PosixTypes.id_t -> unit
 val format_ino_t : formatter -> PosixTypes.ino_t -> unit
 val format_mode_t : formatter -> PosixTypes.mode_t -> unit
 val format_nlink_t : formatter -> PosixTypes.nlink_t -> unit
@@ -40,7 +34,5 @@ val format_off_t : formatter -> PosixTypes.off_t -> unit
 val format_pid_t : formatter -> PosixTypes.pid_t -> unit
 val format_size_t : formatter -> PosixTypes.size_t -> unit
 val format_ssize_t : formatter -> PosixTypes.ssize_t -> unit
-val format_suseconds_t : formatter -> PosixTypes.suseconds_t -> unit
 val format_time_t : formatter -> PosixTypes.time_t -> unit
-val format_uid_t : formatter -> PosixTypes.uid_t -> unit
 val format_useconds_t : formatter -> PosixTypes.useconds_t -> unit
diff --git a/src/ctypes/bigarray_stubs.ml b/src/ctypes/bigarray_stubs.ml
index c9a62e1..4eac02c 100644
--- src/ctypes/bigarray_stubs.ml
+++ src/ctypes/bigarray_stubs.ml
@@ -25,27 +25,26 @@ external kind : ('a, 'b) Bigarray.kind -> 'a kind
      starting from zero, so we can directly transform its values to a variant
      with appropriately-ordered constructors.
 
-     Unfortunately, Bigarray.char and Bigarray.int8_unsigned are currently
+     In OCaml <= 4.01.0, Bigarray.char and Bigarray.int8_unsigned are
      indistinguishable, so the 'kind' function will never return Kind_char.
-     Mantis bug 6064 has a patch that gives char and int8_unsigned distinct
-     representations. *)
+     OCaml 4.02.0 gives the types distinct representations. *)
   = "%identity"
 
-external address : 'b -> Ctypes_raw.voidp
+external address : 'b -> Ctypes_ptr.voidp
   = "ctypes_bigarray_address"
 
-external view : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t
   = "ctypes_bigarray_view"
 
-external view1 : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view1 : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Array1.t
   = "ctypes_bigarray_view"
 
-external view2 : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view2 : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Array2.t
   = "ctypes_bigarray_view"
 
-external view3 : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view3 : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Array3.t
   = "ctypes_bigarray_view"
diff --git a/src/ctypes/coerce.ml b/src/ctypes/coerce.ml
index 23abcb9..1919f33 100644
--- src/ctypes/coerce.ml
+++ src/ctypes/coerce.ml
@@ -62,10 +62,11 @@ let rec coercion : type a b. a typ -> b typ -> (a, b) coercion =
       try
         begin match coercion a b with
         | Id -> Id
-        | Coercion _ -> Coercion (fun (CPointer p) -> CPointer { p with reftype = b })
+        | Coercion _ ->
+          Coercion (fun (CPointer p) -> CPointer (Ctypes_ptr.Fat.coerce p b))
         end
       with Uncoercible ->
-        Coercion (fun (CPointer p) -> CPointer { p with reftype = b })
+        Coercion (fun (CPointer p) -> CPointer (Ctypes_ptr.Fat.coerce p b))
     end
   | _ -> raise Uncoercible
 
diff --git a/src/ctypes/ctypes.mli b/src/ctypes/ctypes.mli
index 54f5e85..70dcb04 100644
--- src/ctypes/ctypes.mli
+++ src/ctypes/ctypes.mli
@@ -351,6 +351,7 @@ val seal : (_, [< `Struct | `Union]) structured typ -> unit
 (** {3 View types} *)
 
 val view : ?format_typ:((Format.formatter -> unit) -> Format.formatter -> unit) ->
+           ?format:(Format.formatter -> 'b -> unit) ->
            read:('a -> 'b) -> write:('b -> 'a) -> 'a typ -> 'b typ
 (** [view ~read:r ~write:w t] creates a C type representation [t'] which
     behaves like [t] except that values read using [t'] are subsequently
@@ -370,6 +371,11 @@ val view : ?format_typ:((Format.formatter -> unit) -> Format.formatter -> unit)
     {!string_of_typ} functions to print the type at the top level and
     elsewhere.  If [format_typ] is not supplied the printer for [t] is used
     instead.
+
+    The optional argument [format] is used by the {!Ctypes.format}
+    and {!string_of} functions to print the values. If [format_val]
+    is not supplied the printer for [t] is used instead.
+
 *)
 
 (** {3 Abstract types} *)
@@ -477,11 +483,16 @@ val ptr_compare : 'a ptr -> 'a ptr -> int
 val reference_type : 'a ptr -> 'a typ
 (** Retrieve the reference type of a pointer. *)
 
-val ptr_of_raw_address : int64 -> unit ptr
+val ptr_of_raw_address : nativeint -> unit ptr
 (** Convert the numeric representation of an address to a pointer *)
 
-val raw_address_of_ptr : unit ptr -> int64
-(** Return the numeric representation of an address *)
+val raw_address_of_ptr : unit ptr -> nativeint
+(** [raw_address_of_ptr p] returns the numeric representation of p.
+
+    Note that the return value remains valid only as long as the pointed-to
+    object is alive.  If [p] is a managed object (e.g. a value returned by
+    {!make}) then unless the caller retains a reference to [p], the object may
+    be collected, invalidating the returned address. *)
 
 val string_from_ptr : char ptr -> length:int -> string
 (** [string_from_ptr p ~length] creates a string initialized with the [length]
@@ -634,6 +645,9 @@ val offsetof : (_, _ structure) field -> int
 val field_type : ('a, _) field -> 'a typ
 (** [field_type f] returns the type of the field [f]. *)
 
+val field_name : (_, _) field -> string
+(** [field_name f] returns the name of the field [f]. *)
+
 val addr : ((_, _) structured as 's) -> 's ptr
 (** [addr s] returns the address of the structure or union [s]. *)
 
@@ -704,4 +718,3 @@ exception IncompleteType
 
 exception Uncoercible
 (** An attempt was made to coerce between uncoercible types.  *)
-
diff --git a/src/ctypes/ctypes_bigarray.ml b/src/ctypes/ctypes_bigarray.ml
index d3637e4..643baf1 100644
--- src/ctypes/ctypes_bigarray.ml
+++ src/ctypes/ctypes_bigarray.ml
@@ -134,15 +134,15 @@ let type_expression : type a b. (a, b) t -> _ =
 
 let prim_of_kind k = prim_of_kind (kind k)
 
-let address _ b = Bigarray_stubs.address b
+let unsafe_address b = Bigarray_stubs.address b
 
-let view : type a b. (a, b) t -> ?ref:Obj.t -> Ctypes_raw.voidp -> offset:int -> b =
+let view : type a b. (a, b) t -> _ Ctypes_ptr.Fat.t -> b =
   let open Bigarray_stubs in
-  fun (dims, kind) ?ref ptr ~offset -> let ba : b = match dims with
-  | DimsGen ds -> view kind ds ptr offset
-  | Dims1 d -> view1 kind [| d |] ptr offset
-  | Dims2 (d1, d2) -> view2 kind [| d1; d2 |] ptr offset
-  | Dims3 (d1, d2, d3) -> view3 kind [| d1; d2; d3 |] ptr offset in
-  match ref with
+  fun (dims, kind) ptr -> let ba : b = match dims with
+  | DimsGen ds -> view kind ds ptr
+  | Dims1 d -> view1 kind [| d |] ptr
+  | Dims2 (d1, d2) -> view2 kind [| d1; d2 |] ptr
+  | Dims3 (d1, d2, d3) -> view3 kind [| d1; d2; d3 |] ptr in
+  match Ctypes_ptr.Fat.managed ptr with
   | None -> ba
   | Some src -> Gc.finalise (fun _ -> ignore src; ()) ba; ba
diff --git a/src/ctypes/ctypes_bigarray.mli b/src/ctypes/ctypes_bigarray.mli
index 2ac647c..3c3b19f 100644
--- src/ctypes/ctypes_bigarray.mli
+++ src/ctypes/ctypes_bigarray.mli
@@ -30,7 +30,7 @@ val bigarray3 : int -> int -> int -> ('a, 'b) Bigarray.kind ->
 (** Create a {!t} value for the {!Bigarray.Array3.t} type. *)
 
 val prim_of_kind : ('a, _) Bigarray.kind -> 'a Primitives.prim
-(** Create a {!Ctypes_raw.Types.ctype} for a {!Bigarray.kind}. *)
+(** Create a {!Ctypes_ptr.Types.ctype} for a {!Bigarray.kind}. *)
 
 (** {3 Type eliminators *)
 
@@ -52,12 +52,16 @@ val type_expression : ('a, 'b) t -> ([> `Appl of Ctypes_path.path * 'c list
 
 (** {2 Values *)
 
-val address : (_, 'a) t -> 'a -> Ctypes_raw.voidp
-(** Return the address of a bigarray value. *)
+val unsafe_address : 'a -> Ctypes_ptr.voidp
+(** Return the address of a bigarray value.  This function is unsafe because
+    it dissociates the raw address of the C array from the OCaml object that
+    manages the lifetime of the array.  If the caller does not hold a
+    reference to the OCaml object then the array might be freed, invalidating
+    the address. *)
 
-val view : (_, 'a) t -> ?ref:Obj.t -> Ctypes_raw.voidp -> offset:int -> 'a
-(** Create a bigarray view onto existing memory.
+val view : (_, 'a) t -> _ Ctypes_ptr.Fat.t -> 'a
+(** [view b ptr] creates a bigarray view onto existing memory.
 
-    The optional [ref] argument is an OCaml object that controls the lifetime
-    of the memory; if [ref] is present, [view] will ensure that it is not
-    collected before the bigarray returned by [view]. *)
+    If [ptr] references an OCaml object then [view] will ensure that
+    that object is not collected before the bigarray returned by
+    [view]. *)
diff --git a/src/ctypes/ctypes_bigarray_stubs.c b/src/ctypes/ctypes_bigarray_stubs.c
index 9aae442..9f246ab 100644
--- src/ctypes/ctypes_bigarray_stubs.c
+++ src/ctypes/ctypes_bigarray_stubs.c
@@ -16,19 +16,18 @@ value ctypes_bigarray_address(value ba)
   return CTYPES_FROM_PTR(Caml_ba_data_val(ba));
 }
 
-/* _view : ('a, 'b) kind -> dims:int array -> ptr -> offset:int ->
+/* _view : ('a, 'b) kind -> dims:int array -> fatptr ->
            ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t */
-value ctypes_bigarray_view(value kind_, value dims_, value ptr_, value offset_)
+value ctypes_bigarray_view(value kind_, value dims_, value ptr_)
 {
   int kind = Int_val(kind_);
   int ndims = Wosize_val(dims_);
-  int offset = Int_val(offset_);
   intnat dims[CAML_BA_MAX_NUM_DIMS];
   int i;
   for (i = 0; i < ndims; i++) {
     dims[i] = Int_val(Field(dims_, i));
   }
   int flags = kind | CAML_BA_C_LAYOUT | CAML_BA_EXTERNAL;
-  void *data = offset + (char *)CTYPES_TO_PTR(ptr_);
+  void *data = CTYPES_ADDR_OF_FATPTR(ptr_);
   return caml_ba_alloc(flags, ndims, data, dims);
 }
diff --git a/src/ctypes/ctypes_ptr.ml b/src/ctypes/ctypes_ptr.ml
new file mode 100644
index 0000000..81fd574
--- /dev/null
+++ src/ctypes/ctypes_ptr.ml
@@ -0,0 +1,94 @@
+(*
+ * Copyright (c) 2013 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* Boxed pointers to C memory locations . *)
+
+module Raw :
+sig
+  include Signed.S
+  val null : t
+end =
+struct
+  include Nativeint
+
+  module Infix =
+  struct
+    let (+) = add
+    let (-) = sub
+    let ( * ) = mul
+    let (/) = div
+    let (mod) = rem
+    let (land) = logand
+    let (lor) = logor
+    let (lxor) = logxor
+    let (lsl) = shift_left
+    let (lsr) = shift_right_logical
+  end
+
+  let of_nativeint x = x
+  let to_nativeint x = x
+
+  let null = zero
+end
+
+type voidp = Raw.t
+
+module Fat :
+sig
+  (** A fat pointer, which holds a reference to the reference type, the C memory
+      location, and an OCaml object. *)
+  type _ t
+
+  (** [make ?managed ~reftyp raw] builds a fat pointer from the reference
+      type [reftyp], the C memory location [raw], and (optionally) an OCaml
+      value, [managed].  The [managed] argument may be used to manage the
+      lifetime of the C object; a typical use it to attach a finaliser to
+      [managed] which releases the memory associated with the C object whose
+      address is stored in [raw_ptr]. *)
+  val make : ?managed:_ -> reftyp:'typ -> voidp -> 'typ t
+
+  val reftype : 'typ t -> 'typ
+
+  val managed : _ t -> Obj.t option
+
+  val coerce : _ t -> 'typ -> 'typ t
+
+  (** Return the raw pointer address.  The function is unsafe in the sense
+      that it dissociates the address from the value which manages the memory,
+      which may trigger associated finalisers, invalidating the address. *)
+  val unsafe_raw_addr : _ t -> voidp
+
+  val add_bytes : 'typ t -> int -> 'typ t
+
+  val compare : 'typ t -> 'typ t -> int
+
+  val diff_bytes : 'typ t -> 'typ t -> int
+end =
+struct
+  type 'typ t =
+    { reftyp  : 'typ;
+      raw     : voidp;
+      managed : Obj.t option; }
+
+  let make ?managed ~reftyp raw = match managed with
+    | None   -> { reftyp; raw; managed = None }
+    | Some v -> { reftyp; raw; managed = Some (Obj.repr v) }
+
+  let reftype { reftyp } = reftyp
+
+  let managed { managed } = managed
+
+  let coerce p reftyp = { p with reftyp }
+    
+  let unsafe_raw_addr { raw } = raw
+
+  let add_bytes p bytes = { p with raw = Raw.(add p.raw (of_int bytes)) }
+
+  let compare l r = Raw.compare l.raw r.raw
+
+  let diff_bytes l r = Raw.(to_int (sub r.raw l.raw))
+end
diff --git a/src/ctypes/ctypes_raw.ml b/src/ctypes/ctypes_raw.ml
deleted file mode 100644
index 51aaad4..0000000
--- src/ctypes/ctypes_raw.ml
+++ /dev/null
@@ -1,20 +0,0 @@
-(*
- * Copyright (c) 2013 Jeremy Yallop.
- *
- * This file is distributed under the terms of the MIT License.
- * See the file LICENSE for details.
- *)
-
-(* Boxed pointers to C memory locations . *)
-
-module PtrType = (val match Ctypes_primitives.pointer_size with
-  4 -> (module Signed.Int32 : Signed.S)
-| 8 -> (module Signed.Int64 : Signed.S)
-| _ -> failwith "No suitable type available to represent pointers.")
-
-type voidp = PtrType.t
-
-let null = PtrType.zero
-
-
-
diff --git a/src/ctypes/managed_buffer_stubs.c b/src/ctypes/managed_buffer_stubs.c
index 5369448..d296743 100644
--- src/ctypes/managed_buffer_stubs.c
+++ src/ctypes/managed_buffer_stubs.c
@@ -28,10 +28,10 @@ static int compare_pointers(value l_, value r_)
   return (l > r) - (l < r);
 }
 
-static long hash_address(value l)
+static intnat hash_address(value l)
 {
   /* address hashing */
-  return (long)*(void **)Data_custom_val(l);
+  return (intnat)*(void **)Data_custom_val(l);
 }
 
 static struct custom_operations managed_buffer_custom_ops = {
diff --git a/src/ctypes/managed_buffer_stubs.h b/src/ctypes/managed_buffer_stubs.h
index 19ccf69..fc2bc6a 100644
--- src/ctypes/managed_buffer_stubs.h
+++ src/ctypes/managed_buffer_stubs.h
@@ -19,4 +19,7 @@ extern value ctypes_allocate(value size);
 /* block_address : managed_buffer -> immediate_pointer */
 extern value ctypes_block_address(value managed_buffer);
 
+/* CTYPES_FROM_FAT_PTR : _ Ctypes_ptr.Fat.t -> void * */
+
+
 #endif /* MANAGED_BUFFER_STUBS_H */
diff --git a/src/ctypes/memory.ml b/src/ctypes/memory.ml
index ddd39a6..7fe7559 100644
--- src/ctypes/memory.ml
+++ src/ctypes/memory.ml
@@ -8,36 +8,31 @@
 open Static
 
 module Stubs = Memory_stubs
-module Raw = Ctypes_raw
+module Raw = Ctypes_ptr.Raw
+module Fat = Ctypes_ptr.Fat
+
+let castp reftype (CPointer p) = CPointer (Fat.coerce p reftype)
 
 (* Describes how to read a value, e.g. from a return buffer *)
-let rec build : type a. a typ -> offset:int -> Raw.voidp -> a
+let rec build : type a b. a typ -> b typ Fat.t -> a
  = function
     | Void ->
-      fun ~offset _ -> ()
+      fun _ -> ()
     | Primitive p -> Stubs.read p
     | Struct { spec = Incomplete _ } ->
       raise IncompleteType
-    | Struct { spec = Complete { size } } as reftype ->
-      (fun ~offset buf ->
-        let m = Stubs.allocate size in
-        let raw_ptr = Stubs.block_address m in
-        let () = Stubs.memcpy ~size
-          ~dst:raw_ptr ~dst_offset:0
-          ~src:buf ~src_offset:offset in
-        { structured =
-            CPointer { pmanaged = Some (Obj.repr m); reftype; raw_ptr; pbyte_offset = 0; } })
-    | Pointer reftype ->
-      (fun ~offset buf ->
-        CPointer {
-          raw_ptr = Stubs.Pointer.read ~offset buf;
-          pbyte_offset = 0;
-          reftype;
-          pmanaged = None; })
+    | Struct { spec = Complete { size } } as reftyp ->
+      (fun buf ->
+        let managed = Stubs.allocate size in
+        let dst = Fat.make ~managed ~reftyp (Stubs.block_address managed) in
+        let () = Stubs.memcpy ~size ~dst ~src:buf in
+        { structured = CPointer dst})
+    | Pointer reftyp ->
+      (fun buf -> CPointer (Fat.make ~reftyp (Stubs.Pointer.read buf)))
     | View { read; ty } ->
       let buildty = build ty in
-      (fun ~offset buf -> read (buildty ~offset buf))
-    | OCaml _ -> (fun ~offset buf -> assert false)
+      (fun buf -> read (buildty buf))
+    | OCaml _ -> (fun buf -> assert false)
     (* The following cases should never happen; non-struct aggregate
        types are excluded during type construction. *)
     | Union _ -> assert false
@@ -45,17 +40,15 @@ let rec build : type a. a typ -> offset:int -> Raw.voidp -> a
     | Bigarray _ -> assert false
     | Abstract _ -> assert false
 
-let rec write : type a. a typ -> offset:int -> a -> Raw.voidp -> unit
-  = let write_aggregate size =
-      (fun ~offset { structured = CPointer { raw_ptr; pbyte_offset = src_offset } } dst ->
-        Stubs.memcpy ~size ~dst ~dst_offset:offset ~src:raw_ptr ~src_offset) in
+let rec write : type a b. a typ -> a -> b Fat.t -> unit
+  = let write_aggregate size { structured = CPointer src } dst =
+      Stubs.memcpy ~size ~dst ~src
+    in
     function
-    | Void -> (fun ~offset _ _ -> ())
+    | Void -> (fun _ _ -> ())
     | Primitive p -> Stubs.write p
     | Pointer _ ->
-      (fun ~offset (CPointer { raw_ptr; pbyte_offset }) dst ->
-        Stubs.Pointer.write ~offset
-          (Raw.PtrType.(add raw_ptr (of_int pbyte_offset))) dst)
+      (fun (CPointer p) dst -> Stubs.Pointer.write p dst)
     | Struct { spec = Incomplete _ } -> raise IncompleteType
     | Struct { spec = Complete _ } as s -> write_aggregate (sizeof s)
     | Union { uspec = None } -> raise IncompleteType
@@ -63,53 +56,47 @@ let rec write : type a. a typ -> offset:int -> a -> Raw.voidp -> unit
     | Abstract { asize } -> write_aggregate asize
     | Array _ as a ->
       let size = sizeof a in
-      (fun ~offset { astart = CPointer { raw_ptr; pbyte_offset = src_offset } } dst ->
-        Stubs.memcpy ~size ~dst ~dst_offset:offset ~src:raw_ptr ~src_offset)
+      (fun { astart = CPointer src } dst ->
+        Stubs.memcpy ~size ~dst ~src)
     | Bigarray b as t ->
       let size = sizeof t in
-      (fun ~offset ba dst ->
-        let src = Ctypes_bigarray.address b ba in
-        Stubs.memcpy ~size ~dst ~dst_offset:offset ~src ~src_offset:0)
+      (fun ba dst ->
+        let src = Fat.make ~managed:ba ~reftyp:Void
+          (Ctypes_bigarray.unsafe_address ba)
+        in
+        Stubs.memcpy ~size ~dst ~src)
     | View { write = w; ty } ->
       let writety = write ty in
-      (fun ~offset v -> writety ~offset (w v))
+      (fun v -> writety (w v))
     | OCaml _ -> raise IncompleteType
 
-let null : unit ptr = CPointer {
-                        raw_ptr = Raw.null;
-                        reftype = Void;
-                        pbyte_offset = 0;
-                        pmanaged = None; }
+let null : unit ptr = CPointer (Fat.make Void Raw.null)
 
 let rec (!@) : type a. a ptr -> a
-  = fun (CPointer ({ raw_ptr; reftype; pbyte_offset = offset; pmanaged = ref } as cptr) as ptr) ->
-    match reftype with
+  = fun (CPointer cptr as ptr) ->
+    match Fat.reftype cptr with
       | Void -> raise IncompleteType
       | Union { uspec = None } -> raise IncompleteType
       | Struct { spec = Incomplete _ } -> raise IncompleteType
-      | View { read; ty = reftype } -> read (!@ (CPointer { cptr with reftype }))
+      | View { read; ty } -> read (!@ (CPointer (Fat.coerce cptr ty)))
       (* If it's a reference type then we take a reference *)
       | Union _ -> { structured = ptr }
       | Struct _ -> { structured = ptr }
       | Array (elemtype, alength) ->
-        { astart = CPointer { cptr with reftype = elemtype }; alength }
-      | Bigarray b -> Ctypes_bigarray.view b ?ref ~offset raw_ptr
+        { astart = CPointer (Fat.coerce cptr elemtype); alength }
+      | Bigarray b -> Ctypes_bigarray.view b cptr
       | Abstract _ -> { structured = ptr }
       | OCaml _ -> raise IncompleteType
       (* If it's a value type then we cons a new value. *)
-      | _ -> build reftype ~offset raw_ptr
+      | _ -> build (Fat.reftype cptr) cptr
 
 let ptr_diff : type a b. (a, b) pointer -> (a, b) pointer -> int
   = fun l r ->
     match l, r with
-    | CPointer { raw_ptr = lp; pbyte_offset = loff; reftype },
-      CPointer { raw_ptr = rp; pbyte_offset = roff } ->
+    | CPointer lp, CPointer rp ->
       (* We assume the pointers are properly aligned, or at least that
          the difference is a multiple of sizeof reftype. *)
-      let open Raw.PtrType in
-        let l = add lp (of_int loff)
-        and r = add rp (of_int roff) in
-        to_int (sub r l) / sizeof reftype
+      Fat.diff_bytes lp rp / sizeof (Fat.reftype lp)
     | OCamlRef (lo, l, _), OCamlRef (ro, r, _) ->
       if l != r then invalid_arg "Ctypes.ptr_diff";
       ro - lo
@@ -117,33 +104,30 @@ let ptr_diff : type a b. (a, b) pointer -> (a, b) pointer -> int
 let (+@) : type a b. (a, b) pointer -> int -> (a, b) pointer
   = fun p x ->
     match p with
-    | CPointer ({ pbyte_offset; reftype } as p) ->
-      CPointer { p with pbyte_offset = pbyte_offset + (x * sizeof reftype) }
+    | CPointer p ->
+      CPointer (Fat.add_bytes p (x * sizeof (Fat.reftype p)))
     | OCamlRef (offset, obj, ty) ->
       OCamlRef (offset + x, obj, ty)
 
 let (-@) p x = p +@ (-x)
 
 let (<-@) : type a. a ptr -> a -> unit
-  = fun (CPointer { reftype; raw_ptr; pbyte_offset = offset }) ->
-    fun v -> write reftype ~offset v raw_ptr
-
-let from_voidp : type a. a typ -> unit ptr -> a ptr
-  = fun reftype (CPointer p) -> CPointer { p with reftype }
+  = fun (CPointer p) ->
+    fun v -> write (Fat.reftype p) v p
 
-let to_voidp : type a. a ptr -> unit ptr
-  = fun (CPointer p) -> CPointer { p with reftype = Void }
+let from_voidp = castp
+let to_voidp p = castp Void p
 
 let allocate_n : type a. ?finalise:(a ptr -> unit) -> a typ -> count:int -> a ptr
-  = fun ?finalise reftype ~count ->
+  = fun ?finalise reftyp ~count ->
     let package p =
-      CPointer { reftype; pbyte_offset = 0; raw_ptr = Stubs.block_address p;
-                 pmanaged = Some (Obj.repr p); } in
+      CPointer (Fat.make ~managed:p ~reftyp (Stubs.block_address p))
+    in
     let finalise = match finalise with
       | Some f -> Gc.finalise (fun p -> f (package p))
       | None -> ignore
     in
-    let p = Stubs.allocate (count * sizeof reftype) in begin
+    let p = Stubs.allocate (count * sizeof reftyp) in begin
       finalise p;
       package p
     end
@@ -155,19 +139,19 @@ let allocate : type a. ?finalise:(a ptr -> unit) -> a typ -> a -> a ptr
       p
     end
 
-let ptr_compare (CPointer {raw_ptr = lp; pbyte_offset = loff})
-                (CPointer {raw_ptr = rp; pbyte_offset = roff})
-    = Raw.PtrType.(compare (add lp (of_int loff)) (add rp (of_int roff)))
+let ptr_compare (CPointer l) (CPointer r) = Fat.(compare l r)
 
-let reference_type (CPointer { reftype }) = reftype
+let reference_type (CPointer p) = Fat.reftype p
 
 let ptr_of_raw_address addr =
-  CPointer {
-    reftype = Void; raw_ptr = Raw.PtrType.of_int64 addr;
-    pmanaged = None; pbyte_offset = 0; }
+  CPointer (Fat.make ~reftyp:Void (Raw.of_nativeint addr))
 
-let raw_address_of_ptr (CPointer { raw_ptr; pbyte_offset }) =
-  Int64.(add (Raw.PtrType.to_int64 raw_ptr) (of_int pbyte_offset))
+let raw_address_of_ptr (CPointer p) =
+  (* This is unsafe by definition: if the object to which [p] refers
+     is collected at this point then the returned address is invalid.
+     If there is an OCaml object associated with [p] then it is vital
+     that the caller retains a reference to it. *)
+  Raw.to_nativeint (Fat.unsafe_raw_addr p)
 
 module CArray =
 struct
@@ -227,8 +211,9 @@ let make ?finalise s =
     | Some f -> Some (fun structured -> f { structured })
     | None -> None in
   { structured = allocate_n ?finalise s ~count:1 }
-let (|->) (CPointer p) { ftype = reftype; foffset } =
-  CPointer { p with reftype; pbyte_offset = p.pbyte_offset + foffset }
+let (|->) (CPointer p) { ftype; foffset } =
+  CPointer (Fat.(add_bytes (Fat.coerce p ftype) foffset))
+
 let (@.) { structured = p } f = p |-> f
 let setf s field v = (s @. field) <-@ v
 let getf s field = !@(s @. field)
@@ -237,40 +222,24 @@ let addr { structured } = structured
 
 open Bigarray
 
-let _bigarray_start kind typ ba =
-  let raw_address = Ctypes_bigarray.address typ ba in
-  let reftype = Primitive (Ctypes_bigarray.prim_of_kind kind) in
-  CPointer {
-    reftype      = reftype ;
-    raw_ptr      = raw_address ;
-    pmanaged     = Some (Obj.repr ba) ;
-    pbyte_offset = 0; }
+let _bigarray_start kind ba =
+  let raw_address = Ctypes_bigarray.unsafe_address ba in
+  let reftyp = Primitive (Ctypes_bigarray.prim_of_kind kind) in
+  CPointer (Fat.make ~managed:ba ~reftyp raw_address)
 
-let bigarray_start : type a b c d f.
+let bigarray_kind : type a b c d f.
   < element: a;
     ba_repr: f;
     bigarray: b;
     carray: c;
-    dims: d > bigarray_class -> b -> a ptr
-  = fun spec ba -> match spec with
-  | Genarray ->
-    let kind = Genarray.kind ba in
-    let dims = Genarray.dims ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray dims kind) ba
-  | Array1 ->
-    let kind = Array1.kind ba in
-    let d = Array1.dim ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray1 d kind) ba
-  | Array2 ->
-    let kind = Array2.kind ba in
-    let d1 = Array2.dim1 ba and d2 = Array2.dim2 ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray2 d1 d2 kind) ba
-  | Array3 ->
-    let kind = Array3.kind ba in
-    let d1 = Array3.dim1 ba and d2 = Array3.dim2 ba and d3 = Array3.dim3 ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray3 d1 d2 d3 kind) ba
+    dims: d > bigarray_class -> b -> (a, f) Bigarray.kind =
+  function
+  | Genarray -> Genarray.kind
+  | Array1 -> Array1.kind
+  | Array2 -> Array2.kind
+  | Array3 -> Array3.kind
 
-let castp reftype (CPointer p) = CPointer { p with reftype }
+let bigarray_start spec ba = _bigarray_start (bigarray_kind spec ba) ba
 
 let array_of_bigarray : type a b c d e.
   < element: a;
@@ -279,7 +248,8 @@ let array_of_bigarray : type a b c d e.
     carray: c;
     dims: d > bigarray_class -> b -> c
   = fun spec ba ->
-    let CPointer { reftype } as element_ptr = bigarray_start spec ba in
+    let CPointer p as element_ptr =
+      bigarray_start spec ba in
     match spec with
   | Genarray ->
     let ds = Genarray.dims ba in
@@ -289,10 +259,10 @@ let array_of_bigarray : type a b c d e.
     CArray.from_ptr element_ptr d
   | Array2 ->
     let d1 = Array2.dim1 ba and d2 = Array2.dim2 ba in
-    CArray.from_ptr (castp (array d2 reftype) element_ptr) d1
+    CArray.from_ptr (castp (array d2 (Fat.reftype p)) element_ptr) d1
   | Array3 ->
     let d1 = Array3.dim1 ba and d2 = Array3.dim2 ba and d3 = Array3.dim3 ba in
-    CArray.from_ptr (castp (array d2 (array d3 reftype)) element_ptr) d1
+    CArray.from_ptr (castp (array d2 (array d3 (Fat.reftype p))) element_ptr) d1
 
 let bigarray_elements : type a b c d f.
    < element: a;
@@ -315,18 +285,27 @@ let array_dims : type a b c d f.
      bigarray: b;
      carray: c carray;
      dims: d > bigarray_class -> c carray -> d =
+   let unsupported () = raise (Unsupported "taking dimensions of non-array type") in
    fun spec a -> match spec with
    | Genarray -> [| a.alength |]
    | Array1 -> a.alength
    | Array2 ->
      begin match a.astart with
-     | CPointer {reftype = Array (_, n)} -> (a.alength, n)
-     | _ -> raise (Unsupported "taking dimensions of non-array type")
+     | CPointer p ->
+       begin match Fat.reftype p with
+       | Array (_, n) -> (a.alength, n)
+       | _ -> unsupported ()
+       end
+     | _ -> unsupported ()
     end
    | Array3 ->
      begin match a.astart with
-     | CPointer {reftype = Array (Array (_, m), n)} -> (a.alength, n, m)
-     | _ -> raise (Unsupported "taking dimensions of non-array type")
+     | CPointer p ->
+       begin match Fat.reftype p with
+       |  Array (Array (_, m), n) -> (a.alength, n, m)
+       | _ -> unsupported ()
+       end
+     | _ -> unsupported ()
      end
 
 let bigarray_of_array spec kind a =
@@ -339,9 +318,9 @@ let array2 = Array2
 let array3 = Array3
 let typ_of_bigarray_kind k = Primitive (Ctypes_bigarray.prim_of_kind k)
 
-let string_from_ptr (CPointer { raw_ptr; pbyte_offset = offset }) ~length:len =
+let string_from_ptr (CPointer p) ~length:len =
   if len < 0 then invalid_arg "Ctypes.string_from_ptr"
-  else Stubs.string_of_array raw_ptr ~offset ~len
+  else Stubs.string_of_array p ~len
 
 let ocaml_string_start str =
   OCamlRef (0, str, String)
diff --git a/src/ctypes/memory_stubs.ml b/src/ctypes/memory_stubs.ml
index 8d1fd6c..0f77a81 100644
--- src/ctypes/memory_stubs.ml
+++ src/ctypes/memory_stubs.ml
@@ -7,6 +7,8 @@
 
 (* Stubs for reading and writing memory. *)
 
+open Ctypes_ptr
+
 (* A reference, managed by the garbage collector, to a region of memory in the
    C heap. *)
 type managed_buffer
@@ -16,33 +18,30 @@ external allocate : int -> managed_buffer
   = "ctypes_allocate"
 
 (* Obtain the address of the managed block. *)
-external block_address : managed_buffer -> Ctypes_raw.voidp
+external block_address : managed_buffer -> voidp
   = "ctypes_block_address"
 
 (* Read a C value from a block of memory *)
-external read : 'a Primitives.prim -> offset:int -> Ctypes_raw.voidp -> 'a
+external read : 'a Primitives.prim -> _ Fat.t -> 'a
   = "ctypes_read"
 
 (* Write a C value to a block of memory *)
-external write :  'a Primitives.prim -> offset:int -> 'a -> Ctypes_raw.voidp -> unit
+external write : 'a Primitives.prim -> 'a -> _ Fat.t -> unit
   = "ctypes_write"
 
 module Pointer =
 struct
-  external read : offset:int -> Ctypes_raw.voidp -> Ctypes_raw.voidp
+  external read : _ Fat.t -> voidp
     = "ctypes_read_pointer"
 
-  external write : offset:int -> Ctypes_raw.voidp -> Ctypes_raw.voidp -> unit
+  external write : _ Fat.t -> _ Fat.t -> unit
   = "ctypes_write_pointer"
 end
 
-(* Copy [size] bytes from [src + src_offset] to [dst + dst_offset]. *)
-external memcpy :
-  dst:Ctypes_raw.voidp -> dst_offset:int ->
-  src:Ctypes_raw.voidp -> src_offset:int ->
-    size:int -> unit
+(* Copy [size] bytes from [src] to [dst]. *)
+external memcpy : dst:_ Fat.t -> src:_ Fat.t -> size:int -> unit
   = "ctypes_memcpy"
 
 (* Read a fixed length OCaml string from memory *)
-external string_of_array : Ctypes_raw.voidp -> offset:int -> len:int -> string
+external string_of_array : _ Fat.t -> len:int -> string
   = "ctypes_string_of_array"
diff --git a/src/ctypes/posixTypes.ml b/src/ctypes/posixTypes.ml
index d10584e..70eb8bf 100644
--- src/ctypes/posixTypes.ml
+++ src/ctypes/posixTypes.ml
@@ -54,33 +54,19 @@ let mkArithmetic =
   | Double -> mkAbstract double
 
 (* Arithmetic types *)
-external typeof_blkcnt_t : unit -> arithmetic = "ctypes_typeof_blkcnt_t"
-external typeof_blksize_t : unit -> arithmetic = "ctypes_typeof_blksize_t"
 external typeof_clock_t : unit -> arithmetic = "ctypes_typeof_clock_t"
 external typeof_dev_t : unit -> arithmetic = "ctypes_typeof_dev_t"
-external typeof_fsblkcnt_t : unit -> arithmetic = "ctypes_typeof_fsblkcnt_t"
-external typeof_fsfilcnt_t : unit -> arithmetic = "ctypes_typeof_fsfilcnt_t"
-external typeof_gid_t : unit -> arithmetic = "ctypes_typeof_gid_t"
-external typeof_id_t : unit -> arithmetic = "ctypes_typeof_id_t"
 external typeof_ino_t : unit -> arithmetic = "ctypes_typeof_ino_t"
 external typeof_mode_t : unit -> arithmetic = "ctypes_typeof_mode_t"
 external typeof_nlink_t : unit -> arithmetic = "ctypes_typeof_nlink_t"
 external typeof_off_t : unit -> arithmetic = "ctypes_typeof_off_t"
 external typeof_pid_t : unit -> arithmetic = "ctypes_typeof_pid_t"
 external typeof_ssize_t : unit -> arithmetic = "ctypes_typeof_ssize_t"
-external typeof_suseconds_t : unit -> arithmetic = "ctypes_typeof_suseconds_t"
 external typeof_time_t : unit -> arithmetic = "ctypes_typeof_time_t"
-external typeof_uid_t : unit -> arithmetic = "ctypes_typeof_uid_t"
 external typeof_useconds_t : unit -> arithmetic = "ctypes_typeof_useconds_t"
 
-module Blkcnt = (val mkArithmetic (typeof_blkcnt_t ()) : Abstract)
-module Blksize = (val mkArithmetic (typeof_blksize_t ()) : Abstract)
 module Clock = (val mkArithmetic (typeof_clock_t ()) : Abstract)
 module Dev = (val mkArithmetic (typeof_dev_t ()) : Abstract)
-module Fsblkcnt = (val mkArithmetic (typeof_fsblkcnt_t ()) : Abstract)
-module Fsfilcnt = (val mkArithmetic (typeof_fsfilcnt_t ()) : Abstract)
-module Gid = (val mkArithmetic (typeof_gid_t ()) : Abstract)
-module Id = (val mkArithmetic (typeof_id_t ()) : Abstract)
 module Ino = (val mkArithmetic (typeof_ino_t ()) : Abstract)
 module Mode = (val mkArithmetic (typeof_mode_t ()) : Abstract)
 module Nlink = (val mkArithmetic (typeof_nlink_t ()) : Abstract)
@@ -92,19 +78,11 @@ struct
   let t = Ctypes.size_t
 end
 module Ssize = (val mkArithmetic (typeof_ssize_t ()) : Abstract)
-module Suseconds = (val mkArithmetic (typeof_suseconds_t ()) : Abstract)
 module Time = (val mkArithmetic (typeof_time_t ()) : Abstract)
-module Uid = (val mkArithmetic (typeof_uid_t ()) : Abstract)
 module Useconds = (val mkArithmetic (typeof_useconds_t ()) : Abstract)
 
-type blkcnt_t = Blkcnt.t
-type blksize_t = Blksize.t
 type clock_t = Clock.t
 type dev_t = Dev.t
-type fsblkcnt_t = Fsblkcnt.t
-type fsfilcnt_t = Fsfilcnt.t
-type gid_t = Gid.t
-type id_t = Id.t
 type ino_t = Ino.t
 type mode_t = Mode.t
 type nlink_t = Nlink.t
@@ -112,19 +90,11 @@ type off_t = Off.t
 type pid_t = Pid.t
 type size_t = Size.t
 type ssize_t = Ssize.t
-type suseconds_t = Suseconds.t
 type time_t = Time.t
-type uid_t = Uid.t
 type useconds_t = Useconds.t
 
-let blkcnt_t = Blkcnt.t
-let blksize_t = Blksize.t
 let clock_t = Clock.t
 let dev_t = Dev.t
-let fsblkcnt_t = Fsblkcnt.t
-let fsfilcnt_t = Fsfilcnt.t
-let gid_t = Gid.t
-let id_t = Id.t
 let ino_t = Ino.t
 let mode_t = Mode.t
 let nlink_t = Nlink.t
@@ -132,74 +102,17 @@ let off_t = Off.t
 let pid_t = Pid.t
 let size_t = Size.t
 let ssize_t = Ssize.t
-let suseconds_t = Suseconds.t
 let time_t = Time.t
-let uid_t = Uid.t
 let useconds_t = Useconds.t
 
 (* Non-arithmetic types *)
 
-external sizeof_key_t : unit -> int = "ctypes_sizeof_key_t"
-external sizeof_pthread_t : unit -> int = "ctypes_sizeof_pthread_t"
-external sizeof_pthread_attr_t : unit -> int = "ctypes_sizeof_pthread_attr_t"
-external sizeof_pthread_cond_t : unit -> int = "ctypes_sizeof_pthread_cond_t"
-external sizeof_pthread_condattr_t : unit -> int = "ctypes_sizeof_pthread_condattr_t"
-external sizeof_pthread_key_t : unit -> int = "ctypes_sizeof_pthread_key_t"
-external sizeof_pthread_mutex_t : unit -> int = "ctypes_sizeof_pthread_mutex_t"
-external sizeof_pthread_mutexattr_t : unit -> int = "ctypes_sizeof_pthread_mutexattr_t"
-external sizeof_pthread_once_t : unit -> int = "ctypes_sizeof_pthread_once_t"
-external sizeof_pthread_rwlock_t : unit -> int = "ctypes_sizeof_pthread_rwlock_t"
-external sizeof_pthread_rwlockattr_t : unit -> int = "ctypes_sizeof_pthread_rwlockattr_t"
 external sizeof_sigset_t : unit -> int = "ctypes_sizeof_sigset_t"
 
-external alignmentof_key_t : unit -> int = "ctypes_alignmentof_key_t"
-external alignmentof_pthread_t : unit -> int = "ctypes_alignmentof_pthread_t"
-external alignmentof_pthread_attr_t : unit -> int = "ctypes_alignmentof_pthread_attr_t"
-external alignmentof_pthread_cond_t : unit -> int = "ctypes_alignmentof_pthread_cond_t"
-external alignmentof_pthread_condattr_t : unit -> int = "ctypes_alignmentof_pthread_condattr_t"
-external alignmentof_pthread_key_t : unit -> int = "ctypes_alignmentof_pthread_key_t"
-external alignmentof_pthread_mutex_t : unit -> int = "ctypes_alignmentof_pthread_mutex_t"
-external alignmentof_pthread_mutexattr_t : unit -> int = "ctypes_alignmentof_pthread_mutexattr_t"
-external alignmentof_pthread_once_t : unit -> int = "ctypes_alignmentof_pthread_once_t"
-external alignmentof_pthread_rwlock_t : unit -> int = "ctypes_alignmentof_pthread_rwlock_t"
-external alignmentof_pthread_rwlockattr_t : unit -> int = "ctypes_alignmentof_pthread_rwlockattr_t"
 external alignmentof_sigset_t : unit -> int = "ctypes_alignmentof_sigset_t"
 
-module Key = (val mkAbstractSized ~name:"key_t" ~size:(sizeof_key_t ()) ~alignment:(alignmentof_key_t ()) : Abstract)
-module Pthread = (val mkAbstractSized ~name:"pthread_t" ~size:(sizeof_pthread_t ()) ~alignment:(alignmentof_pthread_t ()) : Abstract)
-module Pthread_attr = (val mkAbstractSized ~name:"pthread_attr_t" ~size:(sizeof_pthread_attr_t ()) ~alignment:(alignmentof_pthread_attr_t ()) : Abstract)
-module Pthread_cond = (val mkAbstractSized ~name:"pthread_cond_t" ~size:(sizeof_pthread_cond_t ()) ~alignment:(alignmentof_pthread_cond_t ()) : Abstract)
-module Pthread_condattr = (val mkAbstractSized ~name:"pthread_condattr_t" ~size:(sizeof_pthread_condattr_t ()) ~alignment:(alignmentof_pthread_condattr_t ()) : Abstract)
-module Pthread_key = (val mkAbstractSized ~name:"pthread_key_t" ~size:(sizeof_pthread_key_t ()) ~alignment:(alignmentof_pthread_key_t ()) : Abstract)
-module Pthread_mutex = (val mkAbstractSized ~name:"pthread_mutex_t" ~size:(sizeof_pthread_mutex_t ()) ~alignment:(alignmentof_pthread_mutex_t ()) : Abstract)
-module Pthread_mutexattr = (val mkAbstractSized ~name:"pthread_mutexattr_t" ~size:(sizeof_pthread_mutexattr_t ()) ~alignment:(alignmentof_pthread_mutexattr_t ()) : Abstract)
-module Pthread_once = (val mkAbstractSized ~name:"pthread_once_t" ~size:(sizeof_pthread_once_t ()) ~alignment:(alignmentof_pthread_once_t ()) : Abstract)
-module Pthread_rwlock = (val mkAbstractSized ~name:"pthread_rwlock_t" ~size:(sizeof_pthread_rwlock_t ()) ~alignment:(alignmentof_pthread_rwlock_t ()) : Abstract)
-module Pthread_rwlockattr = (val mkAbstractSized ~name:"pthread_rwlockattr_t" ~size:(sizeof_pthread_rwlockattr_t ()) ~alignment:(alignmentof_pthread_rwlockattr_t ()) : Abstract)
 module Sigset = (val mkAbstractSized ~name:"sigset_t" ~size:(sizeof_sigset_t ()) ~alignment:(alignmentof_sigset_t ()) : Abstract)
 
-type key_t = Key.t
-type pthread_t = Pthread.t
-type pthread_attr_t = Pthread_attr.t
-type pthread_cond_t = Pthread_cond.t
-type pthread_condattr_t = Pthread_condattr.t
-type pthread_key_t = Pthread_key.t
-type pthread_mutex_t = Pthread_mutex.t
-type pthread_mutexattr_t = Pthread_mutexattr.t
-type pthread_once_t = Pthread_once.t
-type pthread_rwlock_t = Pthread_rwlock.t
-type pthread_rwlockattr_t = Pthread_rwlockattr.t
 type sigset_t = Sigset.t
 
-let key_t = Key.t
-let pthread_t = Pthread.t
-let pthread_attr_t = Pthread_attr.t
-let pthread_cond_t = Pthread_cond.t
-let pthread_condattr_t = Pthread_condattr.t
-let pthread_key_t = Pthread_key.t
-let pthread_mutex_t = Pthread_mutex.t
-let pthread_mutexattr_t = Pthread_mutexattr.t
-let pthread_once_t = Pthread_once.t
-let pthread_rwlock_t = Pthread_rwlock.t
-let pthread_rwlockattr_t = Pthread_rwlockattr.t
 let sigset_t = Sigset.t
diff --git a/src/ctypes/posixTypes.mli b/src/ctypes/posixTypes.mli
index 5079194..877835e 100644
--- src/ctypes/posixTypes.mli
+++ src/ctypes/posixTypes.mli
@@ -12,14 +12,8 @@ open Ctypes
 (* arithmetic types from <sys/types.h> *)
 (** {2 POSIX arithmetic types} *)
 
-type blkcnt_t
-type blksize_t
 type clock_t
 type dev_t
-type fsblkcnt_t
-type fsfilcnt_t
-type gid_t
-type id_t
 type ino_t
 type mode_t
 type nlink_t
@@ -27,21 +21,13 @@ type off_t
 type pid_t
 type size_t = Unsigned.size_t
 type ssize_t
-type suseconds_t
 type time_t
-type uid_t
 type useconds_t
 
 (** {3 Values representing POSIX arithmetic types} *)
 
-val blkcnt_t    : blkcnt_t typ
-val blksize_t   : blksize_t typ
 val clock_t     : clock_t typ
 val dev_t       : dev_t typ
-val fsblkcnt_t  : fsblkcnt_t typ
-val fsfilcnt_t  : fsfilcnt_t typ
-val gid_t       : gid_t typ
-val id_t        : id_t typ
 val ino_t       : ino_t typ
 val mode_t      : mode_t typ
 val nlink_t     : nlink_t typ
@@ -49,38 +35,14 @@ val off_t       : off_t typ
 val pid_t       : pid_t typ
 val size_t      : size_t typ
 val ssize_t     : ssize_t typ
-val suseconds_t : suseconds_t typ
 val time_t      : time_t typ
-val uid_t       : uid_t typ
 val useconds_t  : useconds_t typ
 
 (* non-arithmetic types from <sys/types.h> *)
 (** {2 POSIX non-arithmetic types} *)
 
-type key_t
-type pthread_t
-type pthread_attr_t
-type pthread_cond_t
-type pthread_condattr_t
-type pthread_key_t
-type pthread_mutex_t
-type pthread_mutexattr_t
-type pthread_once_t
-type pthread_rwlock_t
-type pthread_rwlockattr_t
 type sigset_t
 
 (** {3 Values representing POSIX non-arithmetic types} *)
 
-val key_t                : key_t typ
-val pthread_t            : pthread_t typ
-val pthread_attr_t       : pthread_attr_t typ
-val pthread_cond_t       : pthread_cond_t typ
-val pthread_condattr_t   : pthread_condattr_t typ
-val pthread_key_t        : pthread_key_t typ
-val pthread_mutex_t      : pthread_mutex_t typ
-val pthread_mutexattr_t  : pthread_mutexattr_t typ
-val pthread_once_t       : pthread_once_t typ
-val pthread_rwlock_t     : pthread_rwlock_t typ
-val pthread_rwlockattr_t : pthread_rwlockattr_t typ
 val sigset_t             : sigset_t typ
diff --git a/src/ctypes/posix_types_stubs.c b/src/ctypes/posix_types_stubs.c
index ad174a0..fb2b6ad 100644
--- src/ctypes/posix_types_stubs.c
+++ src/ctypes/posix_types_stubs.c
@@ -12,7 +12,10 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <signal.h>
+#if !defined _WIN32 || defined __CYGWIN__
 #include <pthread.h>
+#endif
+#include <time.h>
 
 #include <stdint.h>
 
@@ -58,68 +61,56 @@ static enum arithmetic _underlying_type(size_t typeinfo)
   }
 }
 
-#define EXPOSE_TYPEINFO(TYPENAME)                            \
+#define EXPOSE_TYPEINFO_COMMON(TYPENAME,STYPENAME)           \
   value ctypes_typeof_ ## TYPENAME(value unit)               \
   {                                                          \
-    size_t typeinfo = ARITHMETIC_TYPEINFO(TYPENAME);         \
+    size_t typeinfo = ARITHMETIC_TYPEINFO(STYPENAME);        \
     enum arithmetic underlying = _underlying_type(typeinfo); \
     return Val_int(underlying);                              \
   }
 
-EXPOSE_TYPEINFO(blkcnt_t)
-EXPOSE_TYPEINFO(blksize_t)
+#define EXPOSE_ALIGNMENT_COMMON(TYPENAME,STYPENAME)          \
+  value ctypes_alignmentof_ ## TYPENAME(value unit)          \
+  {                                                          \
+    struct s { char c; STYPENAME t; };                       \
+    return Val_int(offsetof(struct s, t));                   \
+  }
+
+#define EXPOSE_TYPESIZE_COMMON(TYPENAME,STYPENAME)           \
+  value ctypes_sizeof_ ## TYPENAME(value unit)               \
+  {                                                          \
+    return Val_int(sizeof(STYPENAME));                       \
+  }
+
+#if !defined _WIN32 || defined __CYGWIN__
+  #define UNDERSCORE(X) X
+#else
+  #define UNDERSCORE(X) _## X
+#endif
+
+#define EXPOSE_TYPEINFO(X) EXPOSE_TYPEINFO_COMMON(X, X)
+#define EXPOSE_TYPEINFO_S(X) EXPOSE_TYPEINFO_COMMON(X, UNDERSCORE(X))
+#define EXPOSE_TYPESIZE(X) EXPOSE_TYPESIZE_COMMON(X, X)
+#define EXPOSE_TYPESIZE_S(X) EXPOSE_TYPESIZE_COMMON(X, UNDERSCORE(X))
+#define EXPOSE_ALIGNMENT(X) EXPOSE_ALIGNMENT_COMMON(X, X)
+#define EXPOSE_ALIGNMENT_S(X) EXPOSE_ALIGNMENT_COMMON(X, UNDERSCORE(X))
+
 EXPOSE_TYPEINFO(clock_t)
-EXPOSE_TYPEINFO(dev_t)
-EXPOSE_TYPEINFO(fsblkcnt_t)
-EXPOSE_TYPEINFO(fsfilcnt_t)
-EXPOSE_TYPEINFO(gid_t)
-EXPOSE_TYPEINFO(id_t)
-EXPOSE_TYPEINFO(ino_t)
-EXPOSE_TYPEINFO(mode_t)
-EXPOSE_TYPEINFO(nlink_t)
-EXPOSE_TYPEINFO(off_t)
-EXPOSE_TYPEINFO(pid_t)
+EXPOSE_TYPEINFO_S(dev_t)
+EXPOSE_TYPEINFO_S(ino_t)
+EXPOSE_TYPEINFO_S(mode_t)
+EXPOSE_TYPEINFO_S(off_t)
+EXPOSE_TYPEINFO_S(pid_t)
 EXPOSE_TYPEINFO(ssize_t)
-EXPOSE_TYPEINFO(suseconds_t)
 EXPOSE_TYPEINFO(time_t)
-EXPOSE_TYPEINFO(uid_t)
 EXPOSE_TYPEINFO(useconds_t)
+#if !defined _WIN32 || defined __CYGWIN__
+  EXPOSE_TYPEINFO(nlink_t)
+#else
+  /* the mingw port of fts uses an int for nlink_t */
+  EXPOSE_TYPEINFO_COMMON(nlink_t, int)
+#endif
 
-#define EXPOSE_TYPESIZE(TYPENAME)              \
-  value ctypes_sizeof_ ## TYPENAME(value unit) \
-  {                                            \
-    return Val_int(sizeof(TYPENAME));          \
-  }
-
-EXPOSE_TYPESIZE(key_t)
-EXPOSE_TYPESIZE(pthread_t)
-EXPOSE_TYPESIZE(pthread_attr_t)
-EXPOSE_TYPESIZE(pthread_cond_t)
-EXPOSE_TYPESIZE(pthread_condattr_t)
-EXPOSE_TYPESIZE(pthread_key_t)
-EXPOSE_TYPESIZE(pthread_mutex_t)
-EXPOSE_TYPESIZE(pthread_mutexattr_t)
-EXPOSE_TYPESIZE(pthread_once_t)
-EXPOSE_TYPESIZE(pthread_rwlock_t)
-EXPOSE_TYPESIZE(pthread_rwlockattr_t)
-EXPOSE_TYPESIZE(sigset_t)
-
-#define EXPOSE_ALIGNMENT(TYPENAME)                  \
-  value ctypes_alignmentof_ ## TYPENAME(value unit) \
-  {                                                 \
-    struct s { char c; TYPENAME t; };               \
-    return Val_int(offsetof(struct s, t));          \
-  }
 
-EXPOSE_ALIGNMENT(key_t)
-EXPOSE_ALIGNMENT(pthread_t)
-EXPOSE_ALIGNMENT(pthread_attr_t)
-EXPOSE_ALIGNMENT(pthread_cond_t)
-EXPOSE_ALIGNMENT(pthread_condattr_t)
-EXPOSE_ALIGNMENT(pthread_key_t)
-EXPOSE_ALIGNMENT(pthread_mutex_t)
-EXPOSE_ALIGNMENT(pthread_mutexattr_t)
-EXPOSE_ALIGNMENT(pthread_once_t)
-EXPOSE_ALIGNMENT(pthread_rwlock_t)
-EXPOSE_ALIGNMENT(pthread_rwlockattr_t)
-EXPOSE_ALIGNMENT(sigset_t)
+EXPOSE_TYPESIZE_S(sigset_t)
+EXPOSE_ALIGNMENT_S(sigset_t)
diff --git a/src/ctypes/raw_pointer.h b/src/ctypes/raw_pointer.h
index 33f89c2..6d62aac 100644
--- src/ctypes/raw_pointer.h
+++ src/ctypes/raw_pointer.h
@@ -12,16 +12,10 @@
 #include <caml/alloc.h>
 #include <stdint.h>
 
-#if SIZEOF_PTR == 4
-#define CTYPES_FROM_PTR(P) caml_copy_int32((intptr_t)P)
-#define CTYPES_TO_PTR(I32) ((void *)Int32_val(I32))
-#define CTYPES_PTR_PLUS(I32, I) caml_copy_int32(Int32_val(I32) + I)
-#elif SIZEOF_PTR == 8
-#define CTYPES_FROM_PTR(P) caml_copy_int64((intptr_t)P)
-#define CTYPES_TO_PTR(I64) ((void *)Int64_val(I64))
-#define CTYPES_PTR_PLUS(I64, I) caml_copy_int64(Int64_val(I64) + I)
-#else
-#error "No suitable type available to represent pointers."
-#endif
+#define CTYPES_FROM_PTR(P) caml_copy_nativeint((intptr_t)P)
+#define CTYPES_TO_PTR(I) ((void *)Nativeint_val(I))
+
+/* CTYPES_ADDR_OF_FATPTR : _ Ctypes_ptr.Fat.t -> void * */
+#define CTYPES_ADDR_OF_FATPTR(P) CTYPES_TO_PTR(Field(P, 1))
 
 #endif /* RAW_POINTER_STUBS_H */
diff --git a/src/ctypes/raw_pointer_stubs.c b/src/ctypes/raw_pointer_stubs.c
index 9c1d4fa..dce8526 100644
--- src/ctypes/raw_pointer_stubs.c
+++ src/ctypes/raw_pointer_stubs.c
@@ -14,40 +14,32 @@
 #include "type_info_stubs.h"
 #include "raw_pointer.h"
 
-/* memcpy : dest:raw_pointer -> dest_offset:int ->
-            src:raw_pointer -> src_offset:int ->
-            size:int -> unit */
-value ctypes_memcpy(value dst, value dst_offset,
-                    value src, value src_offset, value size)
+/* memcpy : dst:fat_pointer -> src:fat_pointer -> size:int -> unit */
+value ctypes_memcpy(value dst, value src, value size)
 {
-  CAMLparam5(dst, dst_offset, src, src_offset, size);
-  memcpy((char *)CTYPES_TO_PTR(dst) + Int_val(dst_offset),
-         (char *)CTYPES_TO_PTR(src) + Int_val(src_offset),
-         Int_val(size));
+  CAMLparam3(dst, src, size);
+  memcpy(CTYPES_ADDR_OF_FATPTR(dst), CTYPES_ADDR_OF_FATPTR(src), Int_val(size));
   CAMLreturn(Val_unit);
 }
 
 
 /* string_of_cstring : raw_ptr -> int -> string */
-value ctypes_string_of_cstring(value p, value offset)
+value ctypes_string_of_cstring(value p)
 {
-  return caml_copy_string(((char *)CTYPES_TO_PTR(p))
-                          + Int_val(offset));
+  return caml_copy_string(CTYPES_ADDR_OF_FATPTR(p));
 }
 
 
-/* string_of_array : raw_ptr -> off:int -> len:int -> string */
-value ctypes_string_of_array(value p, value offset, value vlen)
+/* string_of_array : fat_ptr -> len:int -> string */
+value ctypes_string_of_array(value p, value vlen)
 {
-  CAMLparam3(p, offset, vlen);
+  CAMLparam2(p, vlen);
   CAMLlocal1(dst);
   int len = Int_val(vlen);
   if (len < 0)
     caml_invalid_argument("ctypes_string_of_array");
   dst = caml_alloc_string(len);
-  memcpy(String_val(dst),
-         (char *)CTYPES_TO_PTR(p) + Int_val(offset),
-         len);
+  memcpy(String_val(dst), CTYPES_ADDR_OF_FATPTR(p), len);
   CAMLreturn(dst);
 }
 
diff --git a/src/ctypes/signed.ml b/src/ctypes/signed.ml
index 1e3ecb2..f7a7ef7 100644
--- src/ctypes/signed.ml
+++ src/ctypes/signed.ml
@@ -13,8 +13,8 @@ module type S = sig
   val minus_one : t
   val min_int : t
   val shift_right_logical : t -> int -> t
-  val of_int64 : int64 -> t
-  val to_int64 : t -> int64
+  val of_nativeint : nativeint -> t
+  val to_nativeint : t -> nativeint
 end
 
 module type Basics = sig
@@ -53,8 +53,8 @@ module Int32 =
 struct
   include Int32
   module Infix = MakeInfix(Int32)
-  let of_int64 = Int64.to_int32
-  let to_int64 = Int64.of_int32
+  let of_nativeint = Nativeint.to_int32
+  let to_nativeint = Nativeint.of_int32
 end
 
 module Int64 = 
diff --git a/src/ctypes/signed.mli b/src/ctypes/signed.mli
index 2f20a3e..ef43305 100644
--- src/ctypes/signed.mli
+++ src/ctypes/signed.mli
@@ -26,11 +26,11 @@ module type S = sig
   (** {!shift_right_logical} [x] [y] shifts [x] to the right by [y] bits.  See
       {!Int32.shift_right_logical}. *)
 
-  val of_int64 : int64 -> t
-  (** Convert the given int64 value to a signed integer. *)
+  val of_nativeint : nativeint -> t
+  (** Convert the given nativeint value to a signed integer. *)
 
-  val to_int64 : t -> int64
-  (** Convert the given signed integer to an int64 value. *)
+  val to_nativeint : t -> nativeint
+  (** Convert the given signed integer to a nativeint value. *)
 end
 (** Signed integer operations *)
 
diff --git a/src/ctypes/static.ml b/src/ctypes/static.ml
index b2b9ae2..c4002ea 100644
--- src/ctypes/static.ml
+++ src/ctypes/static.ml
@@ -44,17 +44,13 @@ type _ typ =
   | Bigarray        : (_, 'a) Ctypes_bigarray.t
                                          -> 'a typ
   | OCaml           : 'a ocaml_type      -> 'a ocaml typ
-and 'a cptr = { reftype      : 'a typ;
-                raw_ptr      : Ctypes_raw.voidp;
-                pmanaged     : Obj.t option;
-                pbyte_offset : int; }
 and 'a carray = { astart : 'a ptr; alength : int }
 and ('a, 'kind) structured = { structured : ('a, 'kind) structured ptr }
 and 'a union = ('a, [`Union]) structured
 and 'a structure = ('a, [`Struct]) structured
 and 'a abstract = ('a, [`Abstract]) structured
 and (_, _) pointer =
-  CPointer : 'a cptr -> ('a, [`C]) pointer
+  CPointer : 'a typ Ctypes_ptr.Fat.t -> ('a, [`C]) pointer
 | OCamlRef : int * 'a * 'a ocaml_type -> ('a, [`OCaml]) pointer
 and 'a ptr = ('a, [`C]) pointer
 and 'a ocaml = ('a, [`OCaml]) pointer
@@ -62,6 +58,7 @@ and ('a, 'b) view = {
   read : 'b -> 'a;
   write : 'a -> 'b;
   format_typ: ((Format.formatter -> unit) -> Format.formatter -> unit) option;
+  format: (Format.formatter -> 'a -> unit) option;
   ty: 'b typ;
 }
 and ('a, 's) field = {
@@ -199,7 +196,8 @@ let ( @->) f t =
     Function (f, t)
 let abstract ~name ~size ~alignment =
   Abstract { aname = name; asize = size; aalignment = alignment }
-let view ?format_typ ~read ~write ty = View { read; write; format_typ; ty }
+let view ?format_typ ?format ~read ~write ty =
+  View { read; write; format_typ; format; ty }
 let bigarray : type a b c d e.
   < element: a;
     dims: b;
@@ -227,3 +225,4 @@ let union utag = Union { utag; uspec = None; ufields = [] }
 
 let offsetof { foffset } = foffset
 let field_type { ftype } = ftype
+let field_name { fname } = fname
diff --git a/src/ctypes/static.mli b/src/ctypes/static.mli
index 3fc7979..83b9327 100644
--- src/ctypes/static.mli
+++ src/ctypes/static.mli
@@ -38,17 +38,13 @@ type _ typ =
   | Bigarray        : (_, 'a) Ctypes_bigarray.t
                                          -> 'a typ
   | OCaml           : 'a ocaml_type      -> 'a ocaml typ
-and 'a cptr = { reftype      : 'a typ;
-                raw_ptr      : Ctypes_raw.voidp;
-                pmanaged     : Obj.t option;
-                pbyte_offset : int; }
 and 'a carray = { astart : 'a ptr; alength : int }
 and ('a, 'kind) structured = { structured : ('a, 'kind) structured ptr }
 and 'a union = ('a, [`Union]) structured
 and 'a structure = ('a, [`Struct]) structured
 and 'a abstract = ('a, [`Abstract]) structured
 and (_, _) pointer =
-  CPointer : 'a cptr -> ('a, [`C]) pointer
+  CPointer : 'a typ Ctypes_ptr.Fat.t -> ('a, [`C]) pointer
 | OCamlRef : int * 'a * 'a ocaml_type -> ('a, [`OCaml]) pointer
 and 'a ptr = ('a, [`C]) pointer
 and 'a ocaml = ('a, [`OCaml]) pointer
@@ -56,6 +52,7 @@ and ('a, 'b) view = {
   read : 'b -> 'a;
   write : 'a -> 'b;
   format_typ: ((Format.formatter -> unit) -> Format.formatter -> unit) option;
+  format: (Format.formatter -> 'a -> unit) option;
   ty: 'b typ;
 }
 and ('a, 's) field = {
@@ -147,6 +144,7 @@ val ( @-> ) : 'a typ -> 'b fn -> ('a -> 'b) fn
 val abstract : name:string -> size:int -> alignment:int -> 'a abstract typ
 val view : ?format_typ:((Format.formatter -> unit) ->
                         Format.formatter -> unit) ->
+           ?format: (Format.formatter -> 'b -> unit) ->
            read:('a -> 'b) -> write:('b -> 'a) -> 'a typ -> 'b typ
 val bigarray : < ba_repr : 'c;
                  bigarray : 'd;
@@ -159,6 +157,7 @@ val structure : string -> 'a structure typ
 val union : string -> 'a union typ
 val offsetof : ('a, 'b) field -> int
 val field_type : ('a, 'b) field -> 'a typ
+val field_name : ('a, 'b) field -> string
 
 exception IncompleteType
 exception ModifyingSealedType of string
diff --git a/src/ctypes/std_view_stubs.ml b/src/ctypes/std_view_stubs.ml
index aaa8cd7..a2166dc 100644
--- src/ctypes/std_view_stubs.ml
+++ src/ctypes/std_view_stubs.ml
@@ -8,7 +8,7 @@
 (* Stubs for standard views. *)
 
 (* Convert a C string to an OCaml string *)
-external string_of_cstring : Ctypes_raw.voidp -> int -> string
+external string_of_cstring : char Static.typ Ctypes_ptr.Fat.t -> string
   = "ctypes_string_of_cstring"
 
 (* Convert an OCaml string to a C string *)
diff --git a/src/ctypes/std_views.ml b/src/ctypes/std_views.ml
index 64ea416..e3cfee5 100644
--- src/ctypes/std_views.ml
+++ src/ctypes/std_views.ml
@@ -5,22 +5,17 @@
  * See the file LICENSE for details.
  *)
 
-let string_of_char_ptr (Static.CPointer {Static.raw_ptr; pbyte_offset}) =
-  Std_view_stubs.string_of_cstring raw_ptr pbyte_offset
+let string_of_char_ptr (Static.CPointer p) =
+  Std_view_stubs.string_of_cstring p
 
 let char_ptr_of_string s =
-  let buf = Std_view_stubs.cstring_of_string s in
-  Static.CPointer {
-    Static.reftype = Static.char;
-    pmanaged = Some (Obj.repr buf);
-    raw_ptr = Memory_stubs.block_address buf;
-    pbyte_offset = 0; }
+  let managed = Std_view_stubs.cstring_of_string s in
+  Static.CPointer (Ctypes_ptr.Fat.make ~managed ~reftyp:Static.char
+                     (Memory_stubs.block_address managed))
 
 let string = Static.(view (ptr char))
   ~read:string_of_char_ptr ~write:char_ptr_of_string
 
-let castp typ p = Memory.(from_voidp typ (to_voidp p))
-
 let read_nullable t =
   let coerce = Coerce.coerce Static.(ptr void) t in
   fun p -> Memory.(if p = null then None else Some (coerce p))
diff --git a/src/ctypes/type_info_stubs.c b/src/ctypes/type_info_stubs.c
index 29eeca7..28c1d9f 100644
--- src/ctypes/type_info_stubs.c
+++ src/ctypes/type_info_stubs.c
@@ -5,6 +5,10 @@
  * See the file LICENSE for details.
  */
 
+#if !__USE_MINGW_ANSI_STDIO && (defined(__MINGW32__) || defined(__MINGW64__))
+#define __USE_MINGW_ANSI_STDIO 1
+#endif
+
 #include <inttypes.h>
 #include <stdio.h>
 #include <assert.h>
@@ -14,19 +18,25 @@
 #include <caml/memory.h>
 #include <caml/alloc.h>
 
+#include "type_info_stubs.h"
 #include "unsigned_stubs.h"
 #include "complex_stubs.h"
 #include "raw_pointer.h"
 #include "primitives.h"
 
+#if __USE_MINGW_ANSI_STDIO && defined(__MINGW64__)
+#define REAL_ARCH_INTNAT_PRINTF_FORMAT "ll"
+#else
+#define REAL_ARCH_INTNAT_PRINTF_FORMAT ARCH_INTNAT_PRINTF_FORMAT
+#endif
+
 /* Read a C value from a block of memory */
-/* read : 'a prim -> offset:int -> raw_pointer -> 'a */
-value ctypes_read(value prim_, value offset_, value buffer_)
+/* read : 'a prim -> fat_pointer -> 'a */
+value ctypes_read(value prim_, value buffer_)
 {
-  CAMLparam3(prim_, offset_, buffer_);
+  CAMLparam2(prim_, buffer_);
   CAMLlocal1(b);
-  int offset = Int_val(offset_);
-  void *buf = (char *)CTYPES_TO_PTR(buffer_) + offset;
+  void *buf = CTYPES_ADDR_OF_FATPTR(buffer_);
   switch (Int_val(prim_))
   {
    case Char: b = Val_int(*(char *)buf); break;
@@ -62,12 +72,11 @@ value ctypes_read(value prim_, value offset_, value buffer_)
 }
 
 /* Read a C value from a block of memory */
-/* write : 'a prim -> offset:int -> 'a -> raw_pointer -> unit */
-value ctypes_write(value prim_, value offset_, value v, value buffer_)
+/* write : 'a prim -> 'a -> fat_pointer -> unit */
+value ctypes_write(value prim_, value v, value buffer_)
 {
-  CAMLparam4(prim_, offset_, v, buffer_);
-  int offset = Int_val(offset_);
-  void *buf = (char *)CTYPES_TO_PTR(buffer_) + offset;
+  CAMLparam3(prim_, v, buffer_);
+  void *buf = CTYPES_ADDR_OF_FATPTR(buffer_);
   switch (Int_val(prim_))
   {
    case Char: *(char *)buf = Int_val(v); break;
@@ -132,9 +141,9 @@ value ctypes_string_of_prim(value prim_, value v)
   case Uint16_t: len = snprintf(buf, sizeof buf, "%" PRIu16, Uint16_val(v)); break;
   case Uint32_t: len = snprintf(buf, sizeof buf, "%" PRIu32, Uint32_val(v)); break;
   case Uint64_t: len = snprintf(buf, sizeof buf, "%" PRIu64, Uint64_val(v)); break;
-  case Camlint: len = snprintf(buf, sizeof buf, "%" ARCH_INTNAT_PRINTF_FORMAT "d",
+  case Camlint: len = snprintf(buf, sizeof buf, "%" REAL_ARCH_INTNAT_PRINTF_FORMAT "d",
                          (intnat)Int_val(v)); break;
-  case Nativeint: len = snprintf(buf, sizeof buf, "%" ARCH_INTNAT_PRINTF_FORMAT "d",
+  case Nativeint: len = snprintf(buf, sizeof buf, "%" REAL_ARCH_INTNAT_PRINTF_FORMAT "d",
                            (intnat)Nativeint_val(v)); break;
   case Float: len = snprintf(buf, sizeof buf, "%.12g", Double_val(v)); break;
   case Double: len = snprintf(buf, sizeof buf, "%.12g", Double_val(v)); break;
@@ -156,28 +165,28 @@ value ctypes_string_of_prim(value prim_, value v)
   CAMLreturn (s);
 }
 
-/* read_pointer : offset:int -> raw_pointer -> raw_pointer */
-value ctypes_read_pointer(value offset_, value src_)
+/* read_pointer : fat_pointer -> raw_pointer */
+value ctypes_read_pointer(value src_)
 {
-  CAMLparam2(offset_, src_);
-  void *src = (char *)CTYPES_TO_PTR(src_) + Int_val(offset_);
+  CAMLparam1(src_);
+  void *src = CTYPES_ADDR_OF_FATPTR(src_);
   CAMLreturn(CTYPES_FROM_PTR(*(void **)src));
 }
 
-/* write_pointer : offset:int -> raw_pointer -> dst:raw_pointer -> unit */
-value ctypes_write_pointer(value offset_, value p_, value dst_)
+/* write_pointer : fat_pointer -> dst:fat_pointer -> unit */
+value ctypes_write_pointer(value p_, value dst_)
 {
-  CAMLparam3(offset_, p_, dst_);
-  void *dst = (char *)CTYPES_TO_PTR(dst_) + Int_val(offset_);
-  *(void **)dst = CTYPES_TO_PTR(p_);
+  CAMLparam2(p_, dst_);
+  void *dst = CTYPES_ADDR_OF_FATPTR(dst_);
+  *(void **)dst = CTYPES_ADDR_OF_FATPTR(p_);
   CAMLreturn(Val_unit);
 }
 
-/* string_of_pointer : raw_pointer -> string */
+/* string_of_pointer : fat_pointer -> string */
 value ctypes_string_of_pointer(value p_)
 {
   char buf[32];
   CAMLparam1(p_);
-  snprintf(buf, sizeof buf, "%p", CTYPES_TO_PTR(p_));
+  snprintf(buf, sizeof buf, "%p", CTYPES_ADDR_OF_FATPTR(p_));
   CAMLreturn (caml_copy_string(buf));
 }
diff --git a/src/ctypes/type_info_stubs.h b/src/ctypes/type_info_stubs.h
index cebace2..b06f83f 100644
--- src/ctypes/type_info_stubs.h
+++ src/ctypes/type_info_stubs.h
@@ -11,11 +11,11 @@
 #include <caml/mlvalues.h>
 
 /* Read a C value from a block of memory */
-/* read : 'a prim -> offset:int -> raw_pointer -> 'a */
-extern value ctypes_read(value ctype, value offset, value buffer);
+/* read : 'a prim -> raw_pointer -> 'a */
+extern value ctypes_read(value ctype, value buffer);
 
 /* Write a C value to a block of memory */
-/* write : 'a prim -> offset:int -> 'a -> raw_pointer -> unit */
-extern value ctypes_write(value ctype, value offset, value v, value buffer);
+/* write : 'a prim -> 'a -> raw_pointer -> unit */
+extern value ctypes_write(value ctype, value v, value buffer);
 
 #endif /* TYPE_INFO_STUBS_H */
diff --git a/src/ctypes/unsigned_stubs.c b/src/ctypes/unsigned_stubs.c
index 17d50d7..d36e53c 100644
--- src/ctypes/unsigned_stubs.c
+++ src/ctypes/unsigned_stubs.c
@@ -5,6 +5,10 @@
  * See the file LICENSE for details.
  */
 
+#if !__USE_MINGW_ANSI_STDIO && (defined(__MINGW32__) || defined(__MINGW64__))
+#define __USE_MINGW_ANSI_STDIO 1
+#endif
+
 #include <caml/mlvalues.h>
 #include <caml/custom.h>
 #include <caml/alloc.h>
@@ -36,20 +40,20 @@
     return (u1 > u2) - (u1 < u2);                                            \
   }                                                                          \
                                                                              \
-  static long uint ## BITS ## _hash(value v)                                 \
+  static intnat uint ## BITS ## _hash(value v)                               \
   {                                                                          \
     return Uint_custom_val(TYPE(BITS), v);                                   \
   }                                                                          \
                                                                              \
   static void uint ## BITS ## _serialize(value v,                            \
-                                         unsigned long *wsize_32,            \
-                                         unsigned long *wsize_64)            \
+                                         uintnat *wsize_32,                  \
+                                         uintnat *wsize_64)                  \
   {                                                                          \
     caml_serialize_int_ ## BYTES(Uint_custom_val(TYPE(BITS), v));            \
     *wsize_32 = *wsize_64 = BYTES;                                           \
   }                                                                          \
                                                                              \
-  static unsigned long uint ## BITS ## _deserialize(void *dst)               \
+  static uintnat uint ## BITS ## _deserialize(void *dst)                     \
   {                                                                          \
     *(TYPE(BITS) *)dst = caml_deserialize_uint_ ## BYTES();                  \
     return BYTES;                                                            \
diff --git a/src/ctypes/value_printing.ml b/src/ctypes/value_printing.ml
index 4162298..9236755 100644
--- src/ctypes/value_printing.ml
+++ src/ctypes/value_printing.ml
@@ -21,12 +21,15 @@ let rec format : type a. a typ -> Format.formatter -> a -> unit
     (fun fmt -> Type_printing.format_typ fmt) typ
   | Abstract _ -> format_structured fmt v
   | OCaml _ -> format_ocaml fmt v
-    (* For now, just print the underlying value in a view *)
-  | View {write; ty} -> format ty fmt (write v)
+  | View {write; ty; format=f} ->
+    begin match f with
+      | None -> format ty fmt (write v)
+      | Some f -> f fmt v
+    end
 and format_structured : type a b. Format.formatter -> (a, b) structured -> unit
-  = fun fmt ({structured = CPointer {reftype}} as s) ->
+  = fun fmt ({structured = CPointer p} as s) ->
     let open Format in
-    match reftype with
+    match Ctypes_ptr.Fat.reftype p with
     | Struct {fields} ->
       fprintf fmt "{@;<1 2>@[";
       format_fields "," fields fmt s;
@@ -39,11 +42,11 @@ and format_structured : type a b. Format.formatter -> (a, b) structured -> unit
       pp_print_string fmt "<abstract>"
     | _ -> raise (Unsupported "unknown structured type")
 and format_array : type a. Format.formatter -> a carray -> unit
-  = fun fmt ({astart = CPointer {reftype}; alength} as arr) ->
+  = fun fmt ({astart = CPointer p; alength} as arr) ->
     let open Format in
     fprintf fmt "{@;<1 2>@[";
     for i = 0 to alength - 1 do
-      format reftype fmt (CArray.get arr i);
+      format (Ctypes_ptr.Fat.reftype p) fmt (CArray.get arr i);
       if i <> alength - 1 then
         fprintf fmt ",@;"
     done;
@@ -77,9 +80,7 @@ and format_fields : type a b. string -> (a, b) structured boxed_field list ->
           (if i <> last_field then sep else ""))
       fields
 and format_ptr : type a. Format.formatter -> a ptr -> unit
-  = fun fmt (CPointer {raw_ptr; reftype; pbyte_offset}) ->
-    Format.fprintf fmt "%s"
-      (Value_printing_stubs.string_of_pointer
-         (Raw.PtrType.(add raw_ptr (of_int pbyte_offset))))
+  = fun fmt (CPointer p) ->
+    Format.fprintf fmt "%s" (Value_printing_stubs.string_of_pointer p)
 
 let string_of typ v = Common.string_of (format typ) v
diff --git a/src/ctypes/value_printing_stubs.ml b/src/ctypes/value_printing_stubs.ml
index 9ebf216..15acd0e 100644
--- src/ctypes/value_printing_stubs.ml
+++ src/ctypes/value_printing_stubs.ml
@@ -11,5 +11,5 @@
 external string_of_prim : 'a Primitives.prim -> 'a -> string
   = "ctypes_string_of_prim"
 
-external string_of_pointer : Ctypes_raw.voidp -> string
+external string_of_pointer : _ Ctypes_ptr.Fat.t -> string
   = "ctypes_string_of_pointer"
diff --git a/src/discover/discover.ml b/src/discover/discover.ml
index c6b5464..97aac72 100644
--- src/discover/discover.ml
+++ src/discover/discover.ml
@@ -49,7 +49,9 @@ let default_search_paths =
     "/mingw";
   ]
 
-let path_sep = if Sys.os_type = "Win32" then ';' else ':'
+let is_win = Sys.os_type = "Win32"
+
+let path_sep = if is_win then ';' else ':'
 
 let split_path str =
   let len = String.length str in
@@ -385,7 +387,7 @@ let () =
     if not have_pkg_config then
       printf "Warning: the 'pkg-config' command is not available.";
     printf "
-The following recquired C libraries are missing: %s.
+The following required C libraries are missing: %s.
 Please install them and retry. If they are installed in a non-standard location
 or need special flags, set the environment variables <LIB>_CFLAGS and <LIB>_LIBS
 accordingly and retry.
@@ -401,9 +403,12 @@ export LIBFFI_LIBS=-L/opt/local/lib
 
   fprintf config "#endif\n";
 
-  test_feature "no_as_needed" ""
-    (fun () ->
-      ksprintf Sys.command "
+  (match is_win with
+   | true -> setup_data := ("as_needed_flags", []) :: !setup_data;
+   | false ->
+     test_feature "no_as_needed" ""
+       (fun () ->
+         ksprintf Sys.command "
          touch as_needed_test.ml;
          ocamlopt -shared -cclib -Wl,--no-as-needed as_needed_test.ml -o as_needed_test.cmxs > %s 2>&1;
          EXIT=$?;
@@ -411,10 +416,11 @@ export LIBFFI_LIBS=-L/opt/local/lib
          exit $EXIT"
         !log_file = 0);
 
-  if !not_available = [] then
-    setup_data := ("as_needed_flags", ["-Wl,--no-as-needed"]) :: !setup_data
-  else
-    setup_data := ("as_needed_flags", []) :: !setup_data;
+     if !not_available = [] then
+       setup_data := ("as_needed_flags", ["-Wl,--no-as-needed"]) :: !setup_data
+     else
+       setup_data := ("as_needed_flags", []) :: !setup_data;
+  );
   not_available := [];
 
   (* Our setup.data keys. *)
diff --git a/src/libffi-abigen/libffi_abigen.ml b/src/libffi-abigen/libffi_abigen.ml
index d69c70e..adeb9c2 100644
--- src/libffi-abigen/libffi_abigen.ml
+++ src/libffi-abigen/libffi_abigen.ml
@@ -57,13 +57,20 @@ let getenv ~default name =
   try Sys.getenv name
   with Not_found -> default
 
+let null_device =
+  if Sys.os_type = "Win32" then
+    "nul"
+  else
+    "/dev/null"
+
 let read_output_int input_filename output_filename =
   let cmd = 
-    Printf.sprintf "%s -o %s %s %s 2>/dev/null && %s"
+    Printf.sprintf "%s -o %s %s %s 2>%s && %s"
       (getenv ~default:"cc" "CC")
       output_filename
       (getenv ~default:"" "CFLAGS")
       input_filename
+      null_device
       output_filename
   in
   let inch = Unix.open_process_in cmd in
diff --git a/tests/clib/test_functions.c b/tests/clib/test_functions.c
index 0d85022..001cdd5 100644
--- tests/clib/test_functions.c
+++ tests/clib/test_functions.c
@@ -16,6 +16,12 @@
 #include <string.h>
 #include <complex.h>
 
+#if defined _WIN32 && !defined __CYGWIN__
+#include <windows.h>
+#else
+#include <semaphore.h>
+#endif
+
 #include "test_functions.h"
 
 static int add(int x, int y) { return x + y; }
@@ -376,8 +382,6 @@ int retrieve_INT_MAX(void) { return INT_MAX; }
 unsigned int retrieve_UINT_MAX(void) { return UINT_MAX; }
 long retrieve_LONG_MAX(void) { return LONG_MAX; }
 long retrieve_LONG_MIN(void) { return LONG_MIN; }
-long retrieve_nLONG_MAX(void) { return LONG_MAX; }
-long retrieve_nLONG_MIN(void) { return LONG_MIN; }
 unsigned long retrieve_ULONG_MAX(void) { return ULONG_MAX; }
 long long retrieve_LLONG_MAX(void) { return LLONG_MAX; }
 long long retrieve_LLONG_MIN(void) { return LLONG_MIN; }
@@ -501,3 +505,49 @@ int sum_range_with_plus_callback(int a, int b)
   }
   return sum;
 }
+
+static callback_t *registered_callback = NULL;
+
+void register_callback(callback_t *callback)
+{
+  registered_callback = callback;
+}
+
+void call_registered_callback(int times, int starting_value)
+{
+  int i;
+  for (i = 0; i < times; i++) {
+    int result = registered_callback();
+    assert (result == starting_value++);
+  }
+}
+
+#if defined _WIN32 && !defined __CYGWIN__
+#define sem_t HANDLE
+#define sem_init(sem, sem_attr1, sem_init_value)        \
+  (void)((*sem = CreateSemaphore(NULL,0,32768,NULL))==NULL)
+#define sem_wait(sem) \
+  (void)(WAIT_OBJECT_0 != WaitForSingleObject(*sem,INFINITE))
+#define sem_post(sem) (void)ReleaseSemaphore(*sem,1,NULL)
+#endif
+
+static sem_t semaphore1;
+static sem_t semaphore2;
+
+void initialize_waiters(void)
+{
+  sem_init(&semaphore1, 0, -1);
+  sem_init(&semaphore2, 0, -1);
+}
+
+void post1_wait2(void)
+{
+  sem_post(&semaphore1);
+  sem_wait(&semaphore2);
+}
+
+void post2_wait1(void)
+{
+  sem_post(&semaphore2);
+  sem_wait(&semaphore1);
+}
diff --git a/tests/clib/test_functions.h b/tests/clib/test_functions.h
index 534a608..7b061d6 100644
--- tests/clib/test_functions.h
+++ tests/clib/test_functions.h
@@ -118,8 +118,6 @@ int retrieve_INT_MAX(void);
 unsigned int retrieve_UINT_MAX(void);
 long retrieve_LONG_MAX(void);
 long retrieve_LONG_MIN(void);
-long retrieve_nLONG_MAX(void);
-long retrieve_nLONG_MIN(void);
 unsigned long retrieve_ULONG_MAX(void);
 long long retrieve_LLONG_MAX(void);
 long long retrieve_LLONG_MIN(void);
@@ -158,5 +156,11 @@ void matrix_mul(int, int, int, double *, double *, double *);
 double *matrix_transpose(int, int, double *);
 int (*plus_callback)(int);
 int sum_range_with_plus_callback(int, int);
+typedef int callback_t(void);
+void register_callback(callback_t *);
+void call_registered_callback(int, int);
+void initialize_waiters(void);
+void post1_wait2(void);
+void post2_wait1(void);
 
 #endif /* TEST_FUNCTIONS_H */
diff --git a/tests/test-alignment/test_alignment.ml b/tests/test-alignment/test_alignment.ml
index 93a4d9c..2b67b71 100644
--- tests/test-alignment/test_alignment.ml
+++ tests/test-alignment/test_alignment.ml
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Test some relationships between the alignment requirements of primitive types.
 *)
-let test_primitive_alignment () = begin
+let test_primitive_alignment _ = begin
   assert_equal ~msg:"alignmentof(char) == 1"
     (alignment char) 1;
 
@@ -57,7 +57,7 @@ end
 (*
   Test the alignment of abstract types
 *)
-let test_abstract_alignment () =
+let test_abstract_alignment _ =
   for i = 1 to 10 do
     assert_equal
       i (alignment (abstract ~name:"abstract" ~size:(11 - i) ~alignment:i))
@@ -67,7 +67,7 @@ let test_abstract_alignment () =
 (*
   Test that requesting the alignment of an incomplete type raises an exception.
 *)
-let test_incomplete_alignment () =
+let test_incomplete_alignment _ =
   assert_raises IncompleteType
     (fun () -> alignment void);
 
@@ -94,7 +94,7 @@ let test_incomplete_alignment () =
 (*
   Test that [alignment] treats OCaml types as incomplete.
 *)
-let test_alignment_ocaml_string () =
+let test_alignment_ocaml_string _ =
   assert_raises IncompleteType
     (fun () -> alignment ocaml_string)
 
@@ -103,7 +103,7 @@ let test_alignment_ocaml_string () =
    Test that the alignment of a struct is equal to the maximum
    alignment of its members.
 *)
-let test_struct_alignment () = 
+let test_struct_alignment _ = 
   let module M = struct
     type a and b and u
 
@@ -160,7 +160,7 @@ let test_struct_alignment () =
      sizeof (struct A) == 12
      sizeof (struct B) == 16
 *)
-let test_struct_tail_padding () = 
+let test_struct_tail_padding _ = 
   let module M = struct
     type a and b and u
 
@@ -237,7 +237,7 @@ let test_struct_tail_padding () =
    Test that the alignment of a bigarray is the same as the alignment
    of its element type.
 *)
-let test_bigarray_alignment () =
+let test_bigarray_alignment _ =
   let module M = struct
     module B = Bigarray
     type k = K : ('a, 'b) Bigarray.kind * int -> k
diff --git a/tests/test-arrays/test_array.ml b/tests/test-arrays/test_array.ml
index 0f6df5e..f6b4e88 100644
--- tests/test-arrays/test_array.ml
+++ tests/test-arrays/test_array.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -15,7 +15,7 @@ let testlib = Dl.(dlopen ~filename:"clib/libtest_functions.so" ~flags:[RTLD_NOW]
 (*
   Creating multidimensional arrays, and reading and writing elements.
 *)
-let test_multidimensional_arrays () =
+let test_multidimensional_arrays _ =
   let module Array = CArray in
   (* one dimension *)
   let one = Array.make int 10 in
@@ -96,7 +96,7 @@ let test_multidimensional_arrays () =
 (*
   Test that creating an array initializes all elements appropriately.
 *)
-let test_array_initialiation () =
+let test_array_initialiation _ =
   let module Array = CArray in
   let int_array = Array.make int ~initial:33 10 in
   for i = 0 to Array.length int_array - 1 do
@@ -114,7 +114,7 @@ let test_array_initialiation () =
 (*
   Test that creating arrays of elements of incomplete type fails.
 *)
-let test_arrays_of_incomplete_type () =
+let test_arrays_of_incomplete_type _ =
   let module M = struct
     let () = assert_raises IncompleteType
       (fun () -> CArray.make void 10)
@@ -128,7 +128,7 @@ let test_arrays_of_incomplete_type () =
 (*
   Test that OCaml types cannot be used to build arrays.
 *)
-let test_ocaml_types_rejected_as_array_elements () =
+let test_ocaml_types_rejected_as_array_elements _ =
   assert_raises IncompleteType
     (fun () -> CArray.make ocaml_string 10)
 
@@ -136,7 +136,7 @@ let test_ocaml_types_rejected_as_array_elements () =
 (*
   Test that creating an array initializes all elements appropriately.
 *)
-let test_pointer_to_array_arithmetic () =
+let test_pointer_to_array_arithmetic _ =
   let module Array = CArray in
   (* int ( * )[3] *)
   let p = allocate_n (array 3 int) ~count:4 in
@@ -161,7 +161,7 @@ struct
   (*
     Test passing pointer to array of structs.
   *)
-  let test_passing_pointer_to_array_of_structs () =
+  let test_passing_pointer_to_array_of_structs _ =
     let box_int x =
       let v = make s in
       setf v tag 'i';
diff --git a/tests/test-bigarrays/test_bigarrays.ml b/tests/test-bigarrays/test_bigarrays.ml
index 603c78b..f9c6bfe 100644
--- tests/test-bigarrays/test_bigarrays.ml
+++ tests/test-bigarrays/test_bigarrays.ml
@@ -8,7 +8,7 @@
 module Std_array = Array
 type 'a std_array = 'a array
 
-open OUnit
+open OUnit2
 open Ctypes
 module BA = Bigarray
 
@@ -37,7 +37,7 @@ let castp typ p = from_voidp typ (to_voidp p)
 (*
   View ctypes-managed memory through a bigarray lens.
 *)
-let test_bigarray_of_ctypes_array () =
+let test_bigarray_of_ctypes_array _ =
   (* One-dimensional Genarrays *)
   let module Array = CArray in
   let a1 = Array.of_list int8_t [10; 20; 30; 40] in
@@ -157,7 +157,7 @@ let test_bigarray_of_ctypes_array () =
 (*
   View bigarray-managed memory through a ctypes lens
 *)
-let test_ctypes_array_of_bigarray () =
+let test_ctypes_array_of_bigarray _ =
   let module Array = CArray in
 
   (* One-dimensional Genarrays *)
@@ -328,7 +328,7 @@ struct
   (*
     Test passing bigarrays to c functions.
   *)
-  let test_passing_bigarrays () =
+  let test_passing_bigarrays _ =
     let mul l r =
       let m = BA.Array2.dim1 l and n = BA.Array2.dim2 l in
       let o = BA.Array2.dim1 r and p = BA.Array2.dim2 r in
@@ -360,7 +360,7 @@ struct
   (*
     Test returning bigarrays from c functions.
   *)
-  let test_returning_bigarrays () =
+  let test_returning_bigarrays _ =
     let transpose m =
       (* For the purposes of the test we'll just leak the allocated memory. *)
       let rows = BA.Array2.dim1 m and cols = BA.Array2.dim2 m in
@@ -382,7 +382,7 @@ end
   Test that bigarrays are not collected while there's a ctypes pointer pointing
   into them.
 *)
-let test_bigarray_lifetime_with_ctypes_reference () =
+let test_bigarray_lifetime_with_ctypes_reference _ =
   let state = ref `Not_safe_to_collect in
   let finalise ba =
     begin
@@ -424,7 +424,7 @@ let test_bigarray_lifetime_with_ctypes_reference () =
   Test that ctypes-allocated memory is not collected while there's a bigarray
   associated with it.
 *)
-let test_ctypes_memory_lifetime_with_bigarray_reference () =
+let test_ctypes_memory_lifetime_with_bigarray_reference _ =
   let module Array = CArray in
   let state = ref `Not_safe_to_collect in
   let finalise a =
diff --git a/tests/test-builtins/test_builtins.ml b/tests/test-builtins/test_builtins.ml
index 7508e77..799d2e6 100644
--- tests/test-builtins/test_builtins.ml
+++ tests/test-builtins/test_builtins.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 module Bindings = Functions.Stubs(Generated_bindings)
@@ -13,7 +13,7 @@ module Bindings = Functions.Stubs(Generated_bindings)
 (*
   Test calling builtins.
 *)
-let test_calling_builtins () =
+let test_calling_builtins _ =
   let open Unsigned.UInt8 in
   let open Bindings in
   let u1 = of_int 0x77
diff --git a/tests/test-callback_lifetime/test_callback_lifetime.ml b/tests/test-callback_lifetime/test_callback_lifetime.ml
index 3978404..f0d7356 100644
--- tests/test-callback_lifetime/test_callback_lifetime.ml
+++ tests/test-callback_lifetime/test_callback_lifetime.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
@@ -19,7 +19,7 @@ struct
     Check that we can store a reference to an OCaml function in a C global and
     invoke it later.
   *)
-  let test_storing_function_reference () =
+  let test_storing_function_reference _ =
     (* This shouldn't be collected in the code that follows. *)
     let double x = x * 2 in
 
@@ -38,7 +38,7 @@ struct
     have defined behaviour, since the structures needed to make the call may
     have been garbage collected.
   *)
-  let test_calling_collected_closure_raises_exception () =
+  let test_calling_collected_closure_raises_exception _ =
     let closure x y = x * y in
 
     begin
@@ -57,7 +57,7 @@ struct
     Check that we have fairly fine-grained control over the lifetime of closures
     passed to C.
   *)
-  let test_controlling_closure_lifetime () =
+  let test_controlling_closure_lifetime _ =
     (* The return_callback function simply returns its argument.  However, since
        that involves converting an OCaml function ("arg") to a C function
        pointer and back to an OCaml function ("ret"), there are potential
diff --git a/tests/test-coercions/test_coercions.ml b/tests/test-coercions/test_coercions.ml
index adf2f53..412140b 100644
--- tests/test-coercions/test_coercions.ml
+++ tests/test-coercions/test_coercions.ml
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (* 
    Check coercions between pointers.
 *)
-let test_pointer_coercions () =
+let test_pointer_coercions _ =
   let module M = struct
     type boxed_type = T : 'a typ -> boxed_type
     let types = [
@@ -53,7 +53,7 @@ let test_pointer_coercions () =
   Check that coercions between a pointer to a struct and a pointer to
   its first member succeed.
 *)
-let test_struct_first_member_coercions () =
+let test_struct_first_member_coercions _ =
   let module M = struct
     let s = structure "s"
     let f = field s "f" double
@@ -77,7 +77,7 @@ let test_struct_first_member_coercions () =
    Check that coercions between a pointer to a union and a pointer to
    a member succeed.
 *)
-let test_union_coercions () =
+let test_union_coercions _ =
   let module M = struct
     let u = union "u"
     let f = field u "f" double
@@ -108,7 +108,7 @@ let test_union_coercions () =
 (* 
    Check coercions between views.
 *)
-let test_view_coercions () =
+let test_view_coercions _ =
   let module M = struct
     type 'a variant = V of 'a
     let unV (V v) = v and inV v = V v
@@ -142,7 +142,7 @@ struct
   (* 
      Check coercions between functions.
   *)
-  let test_function_coercions () =
+  let test_function_coercions _ =
     let isize_t = view size_t
       ~read:Unsigned.Size_t.to_int ~write:Unsigned.Size_t.of_int in
     let memchr' = coerce_fn
@@ -164,7 +164,7 @@ end
 (* 
    Check that identity coercions are cost-free.
 *)
-let test_identity_coercions () =
+let test_identity_coercions _ =
   let f = fun x y -> x in
   let fn = int @-> float @-> returning int in
   let f' = coerce_fn fn fn f in
@@ -174,7 +174,7 @@ let test_identity_coercions () =
 (* 
    Check that coercions between unsupported types raise an exception
 *)
-let test_unsupported_coercions () =
+let test_unsupported_coercions _ =
   let module M = struct
     type boxed_type = T : 'a typ -> boxed_type
     let types = [
diff --git a/tests/test-complex/test_complex.ml b/tests/test-complex/test_complex.ml
index 9d5f34f..17a7977 100644
--- tests/test-complex/test_complex.ml
+++ tests/test-complex/test_complex.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -23,7 +23,7 @@ struct
     Arguments and return values are currently mediated through pointers,
     since libffi doesn't support passing complex numbers.
   *)
-  let test_complex_primitive_operations () =
+  let test_complex_primitive_operations _ =
     let wrap typ f l r =
       let rv = allocate_n ~count:1 typ in
       f (allocate typ l) (allocate typ r) rv;
@@ -68,7 +68,7 @@ struct
   (*
     Test primitive operations on complex numbers passed by value.
   *)
-  let test_complex_primitive_value_operations () =
+  let test_complex_primitive_value_operations _ =
     begin
       let open Complex in
 
diff --git a/tests/test-cstdlib/test_cstdlib.ml b/tests/test-cstdlib/test_cstdlib.ml
index a59a816..1a78be4 100644
--- tests/test-cstdlib/test_cstdlib.ml
+++ tests/test-cstdlib/test_cstdlib.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Unsigned
 open Foreign
@@ -31,7 +31,7 @@ struct
        int isisupper(int)
        int isisxdigit(int)
   *)
-  let test_isX_functions () =
+  let test_isX_functions _ =
     begin
       assert_bool "" (isalnum 'a');
       assert_bool "" (not (isalnum ' '));
@@ -74,7 +74,7 @@ struct
       char *strchr(const char *str, int c);
       int strcmp(const char *str1, const char *str2);
   *)
-  let test_string_functions () =
+  let test_string_functions _ =
     assert_equal "efg" (strchr "abcdefg" (Char.code 'e'))
       ~printer:(fun x -> x);
 
@@ -110,7 +110,7 @@ struct
        void qsort(void *base, size_t nmemb, size_t size,
                   int(*compar)(const void *, const void *));
   *)
-  let test_qsort () =
+  let test_qsort _ =
     let sortby (type a) (typ : a typ) (f : a -> a -> int) (l : a list) =
       let open CArray in
       let open Size_t in
@@ -143,7 +143,7 @@ struct
                      size_t nmemb, size_t size,
                      int (*compar)(const void *, const void *));
   *)
-  let test_bsearch () =
+  let test_bsearch _ =
     let module M = struct
       (*
         struct mi {
@@ -173,12 +173,12 @@ struct
         arr.(len) <- '\000';
         arr
 
-    let as_string : char ptr -> string =
+    let as_string : char ptr -> Bytes.t =
       fun p ->
         let len = Size_t.to_int (strlen p) in
-        let s = String.create len in
+        let s = Bytes.create len in
         for i = 0 to len - 1 do
-          s.[i] <- !@(p +@ i);
+          Bytes.set s i (!@(p +@ i));
         done;
         s
 
@@ -284,7 +284,7 @@ end
         int rem;			/* Remainder.  */
       } div_t;
 *)
-let test_div () =
+let test_div _ =
   let module M = struct
     type div_t
     let div_t : div_t structure typ = structure "div_t"
diff --git a/tests/test-custom_ops/test_custom_ops.ml b/tests/test-custom_ops/test_custom_ops.ml
index 58e0ac4..f20fbdc 100644
--- tests/test-custom_ops/test_custom_ops.ml
+++ tests/test-custom_ops/test_custom_ops.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 let hash = Hashtbl.hash
@@ -18,7 +18,7 @@ let hash = Hashtbl.hash
   objects, so even structurally-equal values should have different
   hashes and compare unequal.
 *)
-let test_managed_buffer_hashing_and_equality () =
+let test_managed_buffer_hashing_and_equality _ =
   let i1 = allocate int 20 in
   let i2 = allocate int 20 in
   assert_equal !@i1 !@i2;
@@ -38,7 +38,7 @@ let test_managed_buffer_hashing_and_equality () =
   should have equal hashes and compare equal.
 *)
 
-let test_type_info_hashing_and_equality () =
+let test_type_info_hashing_and_equality _ =
   let module M = struct
     type s
     let s : s structure typ = structure "s"
diff --git a/tests/test-errno/test_errno.ml b/tests/test-errno/test_errno.ml
index ab9595d..90b73f9 100644
--- tests/test-errno/test_errno.ml
+++ tests/test-errno/test_errno.ml
@@ -5,43 +5,51 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
+let us x = if Sys.os_type <> "Win32" then x else "_" ^ x
+
 (*
-   Call fdopendir() with a bogus file descriptor and check that an exception
+   Call close() with a bogus file descriptor and check that an exception
    is raised.
 *)
-let test_errno_exception_raised () =
-  let close = Foreign.foreign "close" ~check_errno:true
+let test_errno_exception_raised _ =
+  let close = Foreign.foreign (us "close") ~check_errno:true
     (int @-> returning int) in
-  assert_raises (Unix.Unix_error(Unix.EBADF, "close", ""))
+  assert_raises (Unix.Unix_error(Unix.EBADF, us "close", ""))
     (fun () -> close (-300))
     
 
 (*
   Call chdir() with a valid directory path and check that zero is returned. 
 *)
-let test_int_return_errno_exception_raised () =
-  let chdir = Foreign.foreign "chdir" ~check_errno:true
+let test_int_return_errno_exception_raised _ =
+  let unlikely_to_exist =
+    if Sys.os_type <> "Win32" then
+      "/unlikely_to_exist"
+    else
+      "C:\\unlikely_to_exist"
+  in
+  let chdir = Foreign.foreign (us "chdir") ~check_errno:true
     (string @-> returning int) in
-  assert_raises (Unix.Unix_error(Unix.ENOENT, "chdir", ""))
-    (fun () -> chdir "/unlikely_to_exist")
+  assert_raises (Unix.Unix_error(Unix.ENOENT, us "chdir", ""))
+    (fun () -> chdir unlikely_to_exist)
     
 
 (*
   Call chdir() with a valid directory path and check that zero is returned. 
 *)
-let test_errno_no_exception_raised () =
-  let chdir = Foreign.foreign "chdir" ~check_errno:true
+let test_errno_no_exception_raised _ =
+  let chdir = Foreign.foreign (us "chdir") ~check_errno:true
     (string @-> returning int) in
   assert_equal 0 (chdir (Sys.getcwd ()))
 
     
 
 let suite = "errno tests" >:::
-  ["Exception from fdopendir"
+  ["Exception from close"
     >:: test_errno_exception_raised;
 
    "Exception from chdir"
diff --git a/tests/test-finalisers/test_finalisers.ml b/tests/test-finalisers/test_finalisers.ml
index 7d54373..4ae5946 100644
--- tests/test-finalisers/test_finalisers.ml
+++ tests/test-finalisers/test_finalisers.ml
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Simple finalisation test for arrays.
 *)
-let test_array_finaliser () =
+let test_array_finaliser _ =
   let module Array = CArray in
   let finaliser_completed = ref false in
   let finalise a =
@@ -44,7 +44,7 @@ let test_array_finaliser () =
 (*
   Simple finalisation test for structs.
 *)
-let test_struct_finaliser () =
+let test_struct_finaliser _ =
   let module M = struct
     type s
     let s : s structure typ = structure "s"
diff --git a/tests/test-foreign_values/test_foreign_values.ml b/tests/test-foreign_values/test_foreign_values.ml
index cc88c34..ea3532c 100644
--- tests/test-foreign_values/test_foreign_values.ml
+++ tests/test-foreign_values/test_foreign_values.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -15,14 +15,14 @@ let testlib = Dl.(dlopen ~filename:"clib/libtest_functions.so" ~flags:[RTLD_NOW]
 (*
   Retrieve a struct exposed as a global value. 
 *)
-let test_retrieving_struct () =
+let test_retrieving_struct _ =
   let s = structure "global_struct" in
   let (-:) ty label = field s label ty in
   let len = size_t       -: "len" in
   let str = array 1 char -: "str" in
   let () = seal s in
   let global_struct = Foreign.foreign_value "global_struct" s ~from:testlib in
-  let p = Array.start (getf !@global_struct str) in
+  let p = CArray.start (getf !@global_struct str) in
   let stringp = from_voidp string (to_voidp (allocate (ptr char) p)) in
   begin
     let expected = "global string" in
@@ -36,7 +36,7 @@ let test_retrieving_struct () =
 (*
   Store a reference to an OCaml function as a global function pointer.
 *)
-let test_global_callback () =
+let test_global_callback _ =
   let open Foreign in
 
   let plus =
diff --git a/tests/test-higher_order/stubs/functions.ml b/tests/test-higher_order/stubs/functions.ml
index 5a0b0fb..e88e765 100644
--- tests/test-higher_order/stubs/functions.ml
+++ tests/test-higher_order/stubs/functions.ml
@@ -28,4 +28,10 @@ struct
   let callback_returns_funptr = foreign "callback_returns_funptr"
     (funptr (int @-> returning (funptr (int @-> returning int))) @->
      int @-> returning int)
+
+  let register_callback = foreign "register_callback"
+      (funptr (void @-> returning int) @-> returning void)
+
+  let call_registered_callback = foreign "call_registered_callback"
+      (int @-> int @-> returning void)
 end
diff --git a/tests/test-higher_order/test_higher_order.ml b/tests/test-higher_order/test_higher_order.ml
index d0ed814..189d580 100644
--- tests/test-higher_order/test_higher_order.ml
+++ tests/test-higher_order/test_higher_order.ml
@@ -6,7 +6,7 @@
  *)
 
 open Ctypes
-open OUnit
+open OUnit2
 open Foreign
 
 
@@ -26,7 +26,7 @@ struct
 
      as the first argument.
   *)
-  let test_higher_order_basic () =
+  let test_higher_order_basic _ =
     (* higher_order_1 f x y returns true iff f x y == x + y *)
     assert_equal 1 (higher_order_1 ( + ) 2 3);
     assert_equal 0 (higher_order_1 ( * ) 2 3);
@@ -48,7 +48,7 @@ struct
 
     as the first and second arguments.
   *)
-  let test_higher_higher_order () =
+  let test_higher_higher_order _ =
     let acceptor op x y = op x (op x y) in
     assert_equal 10 (higher_order_3 acceptor ( + ) 3 4);
     assert_equal 36 (higher_order_3 acceptor ( * ) 3 4)
@@ -62,7 +62,7 @@ struct
     (i.e. a function that returns a pointer-to-function) and ensure that we can
     call the returned function from OCaml.
   *)
-  let test_returning_pointer_to_function () =
+  let test_returning_pointer_to_function _ =
     let add = returning_funptr 0 in
 
     let times = returning_funptr 1 in
@@ -81,7 +81,7 @@ struct
     (i.e. a function whose first argument is a pointer-to-function
     returning a pointer-to-function.)
   *)
-  let test_callback_returns_pointer_to_function () =
+  let test_callback_returns_pointer_to_function _ =
     let callback = function
       | 0 -> ( + ) 10
       | 1 -> ( * ) 13
@@ -89,6 +89,24 @@ struct
     in
 
     assert_equal 280 (callback_returns_funptr callback 0)
+
+  (*
+    Call an OCaml function through a C function pointer of type
+
+         void ( * )(void)
+  *)
+  let test_zero_argument_callbacks _ =
+    let counter = ref 0 in
+    let callback () = let c = !counter in incr counter; c in
+    let () = register_callback callback in
+
+    begin
+      assert_equal !counter 0;
+      call_registered_callback 5 !counter;
+      assert_equal !counter 5;
+      call_registered_callback 3 !counter;
+      assert_equal !counter 8;
+    end
 end
 
 
@@ -120,6 +138,12 @@ let suite = "Higher-order tests" >:::
 
    "test_callback_returns_pointer_to_function (stubs)"
    >:: Stub_tests.test_callback_returns_pointer_to_function;
+
+   "test_zero_argument_callbacks (foreign)"
+   >:: Foreign_tests.test_zero_argument_callbacks;
+
+   "test_zero_argument_callbacks (stubs)"
+   >:: Stub_tests.test_zero_argument_callbacks;
   ]
 
 
diff --git a/tests/test-macros/test_macros.ml b/tests/test-macros/test_macros.ml
index ae0bd4b..11e8776 100644
--- tests/test-macros/test_macros.ml
+++ tests/test-macros/test_macros.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 module Bindings = Functions.Stubs(Generated_bindings)
@@ -13,7 +13,7 @@ module Bindings = Functions.Stubs(Generated_bindings)
 (*
   Test calling type-generic macros.
 *)
-let test_tg_macros () =
+let test_tg_macros _ =
   let open Bindings in
   assert_bool "calling double version of type-generic exp"
     (exp_double 1.0 = exp 1.0);
diff --git a/tests/test-oo_style/test_oo_style.ml b/tests/test-oo_style/test_oo_style.ml
index 95f78f3..63b07b8 100644
--- tests/test-oo_style/test_oo_style.ml
+++ tests/test-oo_style/test_oo_style.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -18,7 +18,7 @@ struct
      Establish a hierarchy of "classes", create some "objects" and call some
      "methods".
   *)
-  let test_oo_hierarchy () =
+  let test_oo_hierarchy _ =
     let module M = struct
 
       let camel_vtable_singleton = make camel_methods
diff --git a/tests/test-passable/test_passable.ml b/tests/test-passable/test_passable.ml
index 626f69b..5428848 100644
--- tests/test-passable/test_passable.ml
+++ tests/test-passable/test_passable.ml
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Test that primitives are passable.
 *)
-let test_primitives_are_passable () =
+let test_primitives_are_passable _ =
   let _ = void @-> returning void 
   and _ = char @-> returning char
   and _ = schar @-> returning schar
@@ -41,7 +41,7 @@ let test_primitives_are_passable () =
 (*
   Test that unions are not passable
 *)
-let test_unions_are_not_passable () =
+let test_unions_are_not_passable _ =
   let module M = struct
     type u
 
@@ -73,7 +73,7 @@ let test_unions_are_not_passable () =
 (*
   Test the passability of complex values
 *)
-let test_complex_value_passability () =
+let test_complex_value_passability _ =
   (* complex32 can be used as an argument type *)
   ignore (complex32 @-> returning void);
 
@@ -106,7 +106,7 @@ let test_complex_value_passability () =
 (*
   Test that arrays are not passable
 *)
-let test_arrays_are_not_passable () =
+let test_arrays_are_not_passable _ =
   assert_raises ~msg:"Array type rejected as argument"
     (Unsupported "Unsupported argument type")
     (fun () -> array 1 int @-> returning void);
@@ -119,7 +119,7 @@ let test_arrays_are_not_passable () =
 (*
   Test that bigarrays are not passable
 *)
-let test_bigarrays_are_not_passable () =
+let test_bigarrays_are_not_passable _ =
   assert_raises ~msg:"bigarray type rejected as argument"
     (Unsupported "Unsupported argument type")
     (fun () -> bigarray genarray [|1|] Bigarray.int @-> returning void);
@@ -156,7 +156,7 @@ let test_bigarrays_are_not_passable () =
 (*
   Test that pointers are passable
 *)
-let test_pointers_are_passable () =
+let test_pointers_are_passable _ =
   (* Pointers to primitives are passable *)
   let _ = ptr void @-> returning (ptr void)
   and _ = ptr int @-> returning (ptr int)
@@ -186,7 +186,7 @@ let test_pointers_are_passable () =
 (*
   Test that function pointers are passable
 *)
-let test_function_pointers_are_passable () =
+let test_function_pointers_are_passable _ =
   (* Pointers to primitives are passable *)
   ignore (Foreign.funptr (int @-> returning int)
           @-> returning (Foreign.funptr (int @-> returning int)))
@@ -195,7 +195,7 @@ let test_function_pointers_are_passable () =
 (*
   Test that values of abstract types are not passable
 *)
-let test_abstract_values_are_not_passable () = begin
+let test_abstract_values_are_not_passable _ = begin
   assert_raises ~msg:"Abstract type rejected as argument"
     (Unsupported "Unsupported argument type")
     (fun () ->
@@ -212,7 +212,7 @@ end
   Test struct passability.  Structs are passable unless they contain
   unpassable members (unions, arrays, abstract types, or unpassable structs).
 *)
-let test_struct_passability () =
+let test_struct_passability _ =
   let module M = struct
     type s1 and s2 and s3 and s4 and s5 and s6 and u
 
@@ -330,7 +330,7 @@ let test_struct_passability () =
   Test passability of incomplete types.  Trying to use an incomplete type
   in a function specification should give rise to an error.
 *)
-let test_incomplete_passability () =
+let test_incomplete_passability _ =
   let s = structure "incomplete"
   and u = union "incomplete"
   in begin
diff --git a/tests/test-passing-ocaml-values/stubs/functions.ml b/tests/test-passing-ocaml-values/stubs/functions.ml
index 58cb3b4..382b296 100644
--- tests/test-passing-ocaml-values/stubs/functions.ml
+++ tests/test-passing-ocaml-values/stubs/functions.ml
@@ -9,6 +9,11 @@
 
 open Ctypes
 
+let name_strdup =
+  match Sys.os_type with
+    | "Win32" -> "_strdup"
+    | _ -> "strdup"
+
 module Stubs (F: Cstubs.FOREIGN) =
 struct
   open F
@@ -22,6 +27,6 @@ struct
   let memcpy_string_ptr = foreign "memcpy"
     (ocaml_string @-> ptr void @-> size_t @-> returning (ptr void))
 
-  let strdup = foreign "strdup"
+  let strdup = foreign name_strdup
     (ocaml_string @-> returning string)
 end
diff --git a/tests/test-passing-ocaml-values/test_passing_ocaml_values.ml b/tests/test-passing-ocaml-values/test_passing_ocaml_values.ml
index a558373..ce03136 100644
--- tests/test-passing-ocaml-values/test_passing_ocaml_values.ml
+++ tests/test-passing-ocaml-values/test_passing_ocaml_values.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
@@ -20,10 +20,10 @@ struct
   (*
     Test passing OCaml strings directly to C.
   *)
-  let test_passing_strings () =
+  let test_passing_strings _ =
     let input = "abcdefghijklmnopqrstuvwxyz" in
     let len = String.length input in
-    let buf = String.create len in
+    let buf = String.make len 'Z' in
     let _ = memcpy_string_string
       (ocaml_string_start buf)
       (ocaml_string_start input)
@@ -33,7 +33,7 @@ struct
     end;
 
     let bbuf = Bytes.create len in
-    let binput = Bytes.unsafe_of_string (String.copy input) in
+    let binput = Bytes.of_string input in
     let _ = memcpy_bytes_bytes
       (ocaml_bytes_start bbuf)
       (ocaml_bytes_start binput)
@@ -44,7 +44,7 @@ struct
     
     let arr = CArray.make char len in
     let () = String.iteri (CArray.set arr) input in
-    let buf = String.create len in
+    let buf = String.make len 'Z' in
     let _ = memcpy_string_ptr
       (ocaml_string_start buf)
       (coerce (ptr char) (ptr void) (CArray.start arr))
@@ -54,29 +54,29 @@ struct
     end
 
 
-    (*
-      Test pointer arithmetic on OCaml values.
-    *)
-    let test_pointer_arithmetic () =
-      let s = ocaml_string_start "abcdefghijklmnopqrstuvwxyz" in
-      begin
-        assert_equal s (s +@ 0);
+  (*
+    Test pointer arithmetic on OCaml values.
+   *)
+  let test_pointer_arithmetic _ =
+    let s = ocaml_string_start "abcdefghijklmnopqrstuvwxyz" in
+    begin
+      assert_equal s (s +@ 0);
 
-        assert_equal (ptr_diff s (s +@ 10)) 10;
+      assert_equal (ptr_diff s (s +@ 10)) 10;
 
-        assert_equal s ((s +@ 10) -@ 10);
+      assert_equal s ((s +@ 10) -@ 10);
 
-        assert_equal
-          (strdup (ocaml_string_start "klmnopqrstuvwxyz"))
-          (strdup (s +@ 10))
-      end
+      assert_equal
+        (strdup (ocaml_string_start "klmnopqrstuvwxyz"))
+        (strdup (s +@ 10))
+    end
 end
 
 
 (*
   Test that OCaml values do not reside in addressable memory.
 *)
-let test_ocaml_types_rejected_as_pointer_reference_types () =
+let test_ocaml_types_rejected_as_pointer_reference_types _ =
   assert_raises IncompleteType
     (fun () -> allocate ocaml_string (ocaml_string_start ""))
 
@@ -84,15 +84,21 @@ let test_ocaml_types_rejected_as_pointer_reference_types () =
 (*
   Test that OCaml values cannot be used as return types.
 *)
-let test_ocaml_types_rejected_as_return_types () =
+let strdup =
+  if Sys.os_type = "Win32" then
+    "_strdup"
+  else
+    "strdup"
+
+let test_ocaml_types_rejected_as_return_types _ =
   assert_raises IncompleteType
-    (fun () -> Foreign.foreign "strdup" (string @-> returning ocaml_string))
+    (fun () -> Foreign.foreign strdup (string @-> returning ocaml_string))
 
 
 (*
   Test that pointers to OCaml values cannot be dereferenced.
 *)
-let test_pointers_to_ocaml_types_cannot_be_dereferenced () =
+let test_pointers_to_ocaml_types_cannot_be_dereferenced _ =
   let p = allocate_n char 10 in
   let po = coerce (ptr char) (ptr ocaml_string) p in
 
@@ -108,7 +114,7 @@ let test_pointers_to_ocaml_types_cannot_be_dereferenced () =
 (*
   Test that [funptr] does not support ocaml_string return values.
 *)
-let test_no_higher_order_ocaml_string_support () =
+let test_no_higher_order_ocaml_string_support _ =
   begin
     assert_raises IncompleteType
       (fun () -> funptr (void @-> returning ocaml_string))
diff --git a/tests/test-pointers/test_pointers.ml b/tests/test-pointers/test_pointers.ml
index 050cffe..038bb04 100644
--- tests/test-pointers/test_pointers.ml
+++ tests/test-pointers/test_pointers.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
@@ -20,7 +20,7 @@ struct
   (*
     Test passing various types of pointers to a function.
   *)
-  let test_passing_pointers () =
+  let test_passing_pointers _ =
     assert_equal ~msg:"Passing pointers to various numeric types"
       ~printer:string_of_int
       (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 +
@@ -52,7 +52,7 @@ struct
   (*
     Test passing pointers to pointers.
   *)
-  let test_passing_pointers_to_pointers () =
+  let test_passing_pointers_to_pointers _ =
     let p = allocate int 1
     and pp = allocate (ptr int) (allocate int 2)
     and ppp = allocate (ptr (ptr int)) (allocate (ptr int) (allocate int 3))
@@ -67,7 +67,7 @@ struct
   (*
     Passing a callback that accepts pointers as arguments.
   *)
-  let test_callback_receiving_pointers () =
+  let test_callback_receiving_pointers _ =
     assert_equal 7
       (passing_pointers_to_callback (fun lp rp -> !@lp + !@rp))
 
@@ -75,7 +75,7 @@ struct
   (*
     Passing a callback that returns a pointer.
   *)
-  let test_callback_returning_pointers () =
+  let test_callback_returning_pointers _ =
     let p = allocate int 17 in
     begin
       assert_equal 17 !@p;
@@ -90,7 +90,7 @@ struct
   (*
     Test passing a pointer-to-a-function-pointer as an argument.
   *)
-  let test_passing_pointer_to_function_pointer () =
+  let test_passing_pointer_to_function_pointer _ =
     assert_equal ~printer:string_of_int
       5 (accepting_pointer_to_function_pointer 
            (allocate (funptr (int @-> int @-> returning int)) ( / )))
@@ -100,7 +100,7 @@ struct
   (*
     Test returning a pointer to a function pointer
   *)
-  let test_callback_returning_pointer_to_function_pointer () =
+  let test_callback_returning_pointer_to_function_pointer _ =
     assert_equal
       10 (!@(returning_pointer_to_function_pointer ()) 2 5)
 
@@ -108,7 +108,7 @@ struct
   (*
     Test bindings for malloc, realloc and free.
   *)
-  let test_allocation () =
+  let test_allocation _ =
     let open Unsigned in
 
     let pointer = malloc (Size_t.of_int (sizeof int)) in
@@ -139,14 +139,14 @@ struct
   (*
     Test a function that returns the address of a global variable.
   *)
-  let test_reading_returned_global () =
+  let test_reading_returned_global _ =
     assert_equal (!@(return_global_address ())) 100
 
 
   (*
     Test a function that returns a pointer passed as argument.
   *)
-  let test_passing_pointer_through () =
+  let test_passing_pointer_through _ =
     let p1 = allocate int 25 in
     let p2 = allocate int 32 in
     let rv = pass_pointer_through p1 p2 10 in
@@ -172,7 +172,7 @@ struct
     assert_bool
       "returned pointer with positive computed offset compares greater than original"
       (ptr_compare rv p1 > 0);
-    assert_equal !@rv !@p3;
+    assert_equal !@(rv -@ 1) !@(p3 -@ 1);
     let p4 = p1 -@ 1 in
     let rv = pass_pointer_through p1 p4 (-1) in
     assert_bool
@@ -196,7 +196,7 @@ end
 (*
   Tests for reading and writing primitive values through pointers.
 *)
-let test_pointer_assignment_with_primitives () =
+let test_pointer_assignment_with_primitives _ =
   let open Signed in
   let open Unsigned in
   let p_char = allocate char '1'
@@ -300,7 +300,7 @@ let test_pointer_assignment_with_primitives () =
 (*
   Dereferencing pointers to incomplete types
 *)
-let test_dereferencing_pointers_to_incomplete_types () =
+let test_dereferencing_pointers_to_incomplete_types _ =
   begin
     assert_raises IncompleteType
       (fun () -> !@null);
@@ -316,7 +316,7 @@ let test_dereferencing_pointers_to_incomplete_types () =
 (*
   Writing through a pointer to an abstract type
 *)
-let test_writing_through_pointer_to_abstract_type () =
+let test_writing_through_pointer_to_abstract_type _ =
   let module Array = CArray in
   let arra = Array.make int 2 in
   let arrb = Array.make int 2 in
@@ -357,7 +357,7 @@ let test_writing_through_pointer_to_abstract_type () =
    Test for reading and writing global values using the "foreign_value"
    function.
 *)
-let test_reading_and_writing_global_value () =
+let test_reading_and_writing_global_value _ =
   let ptr = foreign_value "global" int ~from:testlib in
   let ptr' = foreign_value "global" int ~from:testlib in
   assert_equal (!@ptr) 100;
@@ -372,7 +372,7 @@ let test_reading_and_writing_global_value () =
 (*
   Tests for reading a string from an address.
 *)
-let test_reading_strings () =
+let test_reading_strings _ =
   let p = allocate_n char 26 in begin
     StringLabels.iteri "abcdefghijklmnoprwstuvwxyz"
       ~f:(fun i c -> (p +@ i) <-@ c);
@@ -387,7 +387,7 @@ let test_reading_strings () =
 (*
   Tests for various aspects of pointer arithmetic.
 *)
-let test_pointer_arithmetic () =
+let test_pointer_arithmetic _ =
   let module Array = CArray in
   let arr = Array.of_list int [1;2;3;4;5;6;7;8] in
 
@@ -428,7 +428,7 @@ let test_pointer_arithmetic () =
 (*
   Test pointer comparisons.
 *)
-let test_pointer_comparison () =
+let test_pointer_comparison _ =
   let canonicalize p =
     (* Ensure that the 'pbyte_offset' component of the pointer is zero by
        writing the pointer to memory and then reading it back. *)
@@ -515,7 +515,7 @@ let test_pointer_comparison () =
 (*
   Test pointer differences.
 *)
-let test_pointer_differences () =
+let test_pointer_differences _ =
   let canonicalize p =
     (* Ensure that the 'pbyte_offset' component of the pointer is zero by
        writing the pointer to memory and then reading it back. *)
@@ -561,13 +561,13 @@ let test_pointer_differences () =
 (*
   Test raw pointers.
 *)
-let test_raw_pointers () =
+let test_raw_pointers _ =
   (* Check that conversions to the raw form commute with arithmetic. *)
   let p : float ptr = allocate double 1.0 in
   let p' = p +@ 3 in
   let praw = raw_address_of_ptr (to_voidp p) in
   let praw' = raw_address_of_ptr (to_voidp p') in
-  assert_equal praw' Int64.(add praw (of_int (3 * sizeof double)))
+  assert_equal praw' Nativeint.(add praw (of_int (3 * sizeof double)))
 
 
 module Foreign_tests = Common_tests(Tests_common.Foreign_binder)
diff --git a/tests/test-raw/test_raw.ml b/tests/test-raw/test_raw.ml
index 0f5376a..afe39cb 100644
--- tests/test-raw/test_raw.ml
+++ tests/test-raw/test_raw.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Memory_stubs
 open Std_view_stubs
 
@@ -18,20 +18,26 @@ open Std_view_stubs
 
         double fabs(double)
 *)
-let test_fabs () =
+let test_fabs _ =
   Ffi_stubs.(
     let double_ffitype = primitive_ffitype Primitives.Double in
-    let callspec = allocate_callspec () in
+    let callspec = allocate_callspec
+      ~check_errno:false
+      ~runtime_lock:false
+    in
     let arg_1_offset = add_argument callspec double_ffitype in
     let () = prep_callspec callspec Libffi_abi.(abi_code default_abi)
       double_ffitype in
     
     let dlfabs = Dl.dlsym "fabs" in
+    let dlfabs_fat = Ctypes_ptr.Fat.make ~reftyp:Static.Void dlfabs in
     
     let fabs x =
-      call dlfabs callspec
-        (fun p _values -> write Primitives.Double ~offset:arg_1_offset x p)
-        (read Primitives.Double ~offset:0)
+      call "fabs" dlfabs_fat callspec
+        (fun p _values ->
+          write Primitives.Double x
+            Ctypes_ptr.(Fat.make ~reftyp:Static.Void (Raw.(add p (of_int arg_1_offset)))))
+        (fun p -> read Primitives.Double (Ctypes_ptr.Fat.make ~reftyp:Static.Void p))
     in
 
     assert_equal 2.0 (fabs (-2.0)) ~printer:string_of_float;
@@ -44,23 +50,29 @@ let test_fabs () =
 
         double pow(double, double)
 *)
-let test_pow () =
+let test_pow _ =
   Ffi_stubs.(
     let double_ffitype = primitive_ffitype Primitives.Double in
-    let callspec = allocate_callspec () in
+    let callspec = allocate_callspec
+      ~check_errno:false
+      ~runtime_lock:false
+    in
     let arg_1_offset = add_argument callspec double_ffitype in
     let arg_2_offset = add_argument callspec double_ffitype in
     let () = prep_callspec callspec Libffi_abi.(abi_code default_abi) 
       double_ffitype in
     
     let dlpow = Dl.dlsym "pow" in
+    let dlpow_fat = Ctypes_ptr.Fat.make ~reftyp:Static.Void dlpow in
     
     let pow x y =
-      call dlpow callspec
+      call "pow" dlpow_fat callspec
         (fun buffer _values ->
-          write Primitives.Double ~offset:arg_1_offset x buffer;
-          write Primitives.Double ~offset:arg_2_offset y buffer)
-        (read ~offset:0 Primitives.Double)
+          write Primitives.Double x
+            Ctypes_ptr.(Fat.make ~reftyp:Static.Void (Raw.(add buffer (of_int arg_1_offset))));
+          write Primitives.Double y
+            Ctypes_ptr.(Fat.make ~reftyp:Static.Void (Raw.(add buffer (of_int arg_2_offset)))))
+        (fun p -> read Primitives.Double (Ctypes_ptr.Fat.make ~reftyp:Static.Void p))
     in
 
     assert_equal 8.0 (pow 2.0 3.0);
diff --git a/tests/test-sizeof/test_sizeof.ml b/tests/test-sizeof/test_sizeof.ml
index ba080b0..8b1fc8d 100644
--- tests/test-sizeof/test_sizeof.ml
+++ tests/test-sizeof/test_sizeof.ml
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Test some relationships between the sizes of primitive types.
 *)
-let test_sizeof_primitives () = begin
+let test_sizeof_primitives _ = begin
   assert_equal ~msg:"sizeof (char) == 1"
     (sizeof char) 1;
 
@@ -73,7 +73,7 @@ end
 (*
   Test some properties of the sizes of unions.
 *)
-let test_sizeof_unions () =
+let test_sizeof_unions _ =
   let int_char = union "int_char" in
   let _ = field int_char "_" int in
   let _ = field int_char "_" char in
@@ -92,7 +92,7 @@ let test_sizeof_unions () =
 (*
   Test some properties of the sizes of structs.
 *)
-let test_sizeof_structs () =
+let test_sizeof_structs _ =
   let module M = struct
     (* We don't expect homogeneous structs consisting of words to have
        any padding. *)
@@ -113,7 +113,7 @@ let test_sizeof_structs () =
 (*
   Test the size of abstract types.
 *)
-let test_sizeof_abstract () =
+let test_sizeof_abstract _ =
   for i = 1 to 10 do
     assert_equal
       i (sizeof (abstract ~name:"abstract" ~size:i ~alignment:(11 - i)))
@@ -123,7 +123,7 @@ let test_sizeof_abstract () =
 (*
   Test that taking the size of an incomplete type is treated as an error.
 *)
-let test_sizeof_incomplete () = begin
+let test_sizeof_incomplete _ = begin
   assert_raises IncompleteType
     (fun () -> sizeof (structure "incomplete"));
 
@@ -135,7 +135,7 @@ end
 (*
   Test that taking the size of void is treated as an error.
 *)
-let test_sizeof_void () =
+let test_sizeof_void _ =
   assert_raises IncompleteType
     (fun () -> sizeof void)
  
@@ -143,7 +143,7 @@ let test_sizeof_void () =
 (*
   Test that [sizeof] treats OCaml types as incomplete.
 *)
-let test_sizeof_ocaml_string () =
+let test_sizeof_ocaml_string _ =
   assert_raises IncompleteType
     (fun () -> sizeof ocaml_string)
 
@@ -151,7 +151,7 @@ let test_sizeof_ocaml_string () =
 (*
   Test the behaviour of sizeof on array types.
 *)
-let test_sizeof_arrays () = begin
+let test_sizeof_arrays _ = begin
   assert_equal ~msg:"The size of an array is the sum of the size of its members"
     (12 * (sizeof int8_t)) (sizeof (array 12 int8_t));
 
@@ -163,7 +163,7 @@ end
 (*
   Test the behaviour of sizeof on bigarray types.
 *)
-let test_sizeof_bigarrays () =
+let test_sizeof_bigarrays _ =
   let module M = struct
     module B = Bigarray
     type k = K : ('a, 'b) Bigarray.kind * int -> k
@@ -211,7 +211,7 @@ let test_sizeof_bigarrays () =
 (*
   Test that all pointers have equal size.
 *)
-let test_sizeof_pointers () = begin
+let test_sizeof_pointers _ = begin
   let pointer_size = sizeof (ptr void) in
   assert_equal pointer_size (sizeof (ptr void));
   assert_equal pointer_size (sizeof (ptr int));
@@ -231,7 +231,7 @@ end
 (*
   Test that the size of a view type is the same as the underlying type.
 *)
-let test_sizeof_views () = begin
+let test_sizeof_views _ = begin
   let const c x = c in
   let vint = view ~read:(const [1]) ~write:(const 0) int
   and vchar = view ~read:(const ["1"]) ~write:(const 'a') char
diff --git a/tests/test-structs/test_structs.ml b/tests/test-structs/test_structs.ml
index b0aa364..2ec7cd8 100644
--- tests/test-structs/test_structs.ml
+++ tests/test-structs/test_structs.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -30,7 +30,7 @@ struct
          struct simple *self;
        };
   *)
-  let test_passing_struct () =
+  let test_passing_struct _ =
     let module M = struct
       let s = make simple
 
@@ -61,7 +61,7 @@ struct
          struct simple *self;
        };
   *)
-  let test_returning_struct () =
+  let test_returning_struct _ =
     let module M = struct
       let s = return_struct ()
 
@@ -83,7 +83,7 @@ end
 (*
   Check that attempts to use incomplete types for struct members are rejected.
 *)
-let test_incomplete_struct_members () =
+let test_incomplete_struct_members _ =
   let s = structure "s" in begin
 
     assert_raises IncompleteType
@@ -100,7 +100,7 @@ let test_incomplete_struct_members () =
 (*
   Test that OCaml types cannot be used as struct or union fields.
 *)
-let test_ocaml_types_rejected_as_fields () =
+let test_ocaml_types_rejected_as_fields _ =
   let module M = struct
     let s = structure "s"
     let () = assert_raises IncompleteType
@@ -109,16 +109,16 @@ let test_ocaml_types_rejected_as_fields () =
     let u = union "u"
     let () = assert_raises IncompleteType
       (fun () ->
-        field u "o" ocaml_string;
-        (* The error is currently only caught on sealing the union *)
-        seal u)
+       let _ =  field u "o" ocaml_string in
+       (* The error is currently only caught on sealing the union *)
+       seal u)
   end in ()
 
 
 (*
   Test reading and writing pointers to struct members.
 *)
-let test_pointers_to_struct_members () =
+let test_pointers_to_struct_members _ =
   let module M = struct
     type s
 
@@ -159,7 +159,7 @@ let test_pointers_to_struct_members () =
 (*
   Test structs with union members.
 *)
-let test_structs_with_union_members () =
+let test_structs_with_union_members _ =
   let module M = struct
     type u and s
 
@@ -221,7 +221,7 @@ let test_structs_with_union_members () =
 (*
   Test structs with array members.
 *)
-let test_structs_with_array_members () =
+let test_structs_with_array_members _ =
   let module M = struct
     type u and s
 
@@ -285,7 +285,7 @@ let test_structs_with_array_members () =
 (*
   Test that attempting to update a sealed struct is treated as an error.
 *)
-let test_updating_sealed_struct () =
+let test_updating_sealed_struct _ =
   let styp = structure "sealed" in
   let _ = field styp "_" int in
   let () = seal styp in
@@ -297,7 +297,7 @@ let test_updating_sealed_struct () =
 (*
   Test that attempting to seal an empty struct is treated as an error.
 *)
-let test_sealing_empty_struct () =
+let test_sealing_empty_struct _ =
   let empty = structure "empty" in
 
   assert_raises (Unsupported "struct with no fields")
@@ -308,7 +308,7 @@ let test_sealing_empty_struct () =
    Check that references to fields aren't garbage collected while they're
    still needed.
 *)
-let test_field_references_not_invalidated () =
+let test_field_references_not_invalidated _ =
   let module M = struct
     type s1 and s2
 
@@ -340,7 +340,7 @@ let test_field_references_not_invalidated () =
    Check that references to ffi_type values for structs aren't collected while
    they're still needed
 *)
-let test_struct_ffi_type_lifetime () =
+let test_struct_ffi_type_lifetime _ =
   let module M = struct
     let f =
       let t = 
@@ -370,7 +370,7 @@ struct
   (*
     Test passing structs with union members.
   *)
-  let test_passing_structs_with_union_members () =
+  let test_passing_structs_with_union_members _ =
     let mkInt v =
       let t = make tagged in
       t @. tag <-@ 'i';
@@ -396,7 +396,7 @@ struct
   (*
     Test passing structs with array members.
   *)
-  let test_passing_structs_with_array_members () =
+  let test_passing_structs_with_array_members _ =
     let mkTriple (x, y, z) =
       let t = make triple in
       t @. elements <-@ CArray.of_list double [x; y; z];
diff --git a/tests/test-stubs/test_stubs.ml b/tests/test-stubs/test_stubs.ml
index 99dc0ba..cc62000 100644
--- tests/test-stubs/test_stubs.ml
+++ tests/test-stubs/test_stubs.ml
@@ -5,13 +5,13 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
 let missing = "_60d2dd04_1b66_4b79_a2ea_8375157da563"
 
-let test_missing () = 
+let test_missing _ = 
   let miss = foreign missing ~stub:true (int @-> int @-> (returning int)) in
   begin try ignore (miss 2 3); assert_failure "should raise" with exn -> () end;
   try
diff --git a/tests/test-threads/stubs/functions.ml b/tests/test-threads/stubs/functions.ml
new file mode 100644
index 0000000..05e1791
--- /dev/null
+++ tests/test-threads/stubs/functions.ml
@@ -0,0 +1,32 @@
+(*
+ * Copyright (c) 2014 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* Foreign function bindings for the threads tests. *)
+
+open Ctypes
+open Foreign
+
+let () =
+  (* temporary workaround due to flexlink limitations *)
+  if Sys.os_type = "Win32" then
+    ignore (Dl.(dlopen ~filename:"clib/libtest_functions.so" ~flags:[RTLD_NOW]))
+
+let initialize_waiters = foreign "initialize_waiters"
+  (void @-> returning void)
+
+let post1_wait2 = foreign "post1_wait2"
+  ~release_runtime_lock:true
+  (void @-> returning void)
+
+let post2_wait1 = foreign "post2_wait1"
+  ~release_runtime_lock:true
+  (void @-> returning void)
+
+let callback_with_pointers = foreign "passing_pointers_to_callback"
+  ~release_runtime_lock:true
+  (funptr ~runtime_lock:true
+     (ptr int @-> ptr int @-> returning int) @-> returning int)
diff --git a/tests/test-threads/test_threads.ml b/tests/test-threads/test_threads.ml
new file mode 100644
index 0000000..62522b1
--- /dev/null
+++ tests/test-threads/test_threads.ml
@@ -0,0 +1,50 @@
+(*
+ * Copyright (c) 2013 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+open Ctypes
+open OUnit2
+open Foreign
+open Functions
+
+
+(*
+  Ensure that passing ~release_runtime_lock releases the runtime lock.
+*)
+let test_release_runtime_lock _ =
+  begin
+    initialize_waiters ();
+    let t1 = Thread.create post1_wait2 () in
+    let t2 = Thread.create post2_wait1 () in
+    Thread.join t1;
+    Thread.join t2;
+  end
+
+
+(*
+  Ensure that passing ~runtime_lock to funptr causes a callbacks to acquire
+  the runtime lock.
+*)
+let test_acquire_runtime_lock _ =
+  begin
+    let f x y = let _ = Gc.major () in !@x + !@y in
+    let t1 = Thread.create Gc.major () in
+    assert (callback_with_pointers f = 7);
+    Thread.join t1
+  end
+
+
+let suite = "Thread tests" >:::
+  ["test_release_runtime_lock (foreign)"
+   >:: test_release_runtime_lock;
+
+   "test_acquire_runtime_lock (foreign)"
+   >:: test_acquire_runtime_lock;
+  ]
+
+
+let _ =
+  run_test_tt_main suite
diff --git a/tests/test-type_printing/test_type_printing.ml b/tests/test-type_printing/test_type_printing.ml
index ecda4f5..804a776 100644
--- tests/test-type_printing/test_type_printing.ml
+++ tests/test-type_printing/test_type_printing.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -28,7 +28,7 @@ let assert_fn_printed_as ?name e f = assert_printed_as ?name string_of_fn e f
   Test the printing of atomic types: void, arithmetic types and abstract
   types.
 *)
-let test_atomic_printing () =
+let test_atomic_printing _ =
   begin
     assert_typ_printed_as "void"
       void;
@@ -112,7 +112,7 @@ let test_atomic_printing () =
 (*
   Test the printing of pointers to object and function types.
 *)
-let test_pointer_printing () =
+let test_pointer_printing _ =
   begin
     (* Pointers to atomic types *)
     assert_typ_printed_as ~name:"a" "void *a"
@@ -208,7 +208,7 @@ let test_pointer_printing () =
 (*
   Test the printing of pointers to object and function types.
 *)
-let test_struct_and_union_printing () =
+let test_struct_and_union_printing _ =
   begin
     (* Incomplete structs and unions *) 
     let s_incomplete = structure "s_incomplete" in 
@@ -362,7 +362,7 @@ let test_struct_and_union_printing () =
 (*
   Test the printing of array types.
 *)
-let test_array_printing () =
+let test_array_printing _ =
   begin
     assert_typ_printed_as ~name:"a" "int a[10]"
       (array 10 int);
@@ -386,7 +386,7 @@ let test_array_printing () =
 (*
   Test the printing of OCaml string types.
 *)
-let test_ocaml_string_printing () =
+let test_ocaml_string_printing _ =
   begin
     assert_typ_printed_as ~name:"p" "char *p"
       ocaml_string;
@@ -397,28 +397,16 @@ let test_ocaml_string_printing () =
 
 
 (*
-  Test the printing of bigarray types.
+  Test the printing of bigarray types with signed elements.
 *)
-let test_bigarray_printing () =
+let test_bigarray_signed_printing _ =
   begin
-    assert_typ_printed_as "float[10][100]"
-      (bigarray genarray [|10; 100|] Bigarray.float32);
-
-    assert_typ_printed_as "double[20][30][40]"
-      (bigarray genarray [|20; 30; 40|] Bigarray.float64);
-
     assert_typ_printed_as "int8_t[1][3]"
       (bigarray genarray [|1; 3|] Bigarray.int8_signed);
 
-    assert_typ_printed_as "uint8_t[2]"
-      (bigarray array1 2 Bigarray.int8_unsigned);
-
     assert_typ_printed_as "int16_t[3]"
       (bigarray array1 3 Bigarray.int16_signed);
 
-    assert_typ_printed_as "uint16_t[4]"
-      (bigarray array1 4 Bigarray.int16_unsigned);
-
     assert_typ_printed_as "int32_t[5][6]"
       (bigarray array2 (5, 6) Bigarray.int32);
 
@@ -430,24 +418,47 @@ let test_bigarray_printing () =
 
     assert_typ_printed_as "intnat[13][14][15]"
       (bigarray array3 (13, 14, 15) Bigarray.nativeint);
+  end
+
+
+(*
+  Test the printing of bigarray types with unsigned elements.
+*)
+let test_bigarray_unsigned_printing _ =
+  skip_if true
+    "Unsigned bigarray elements currently indistinguishable from signed elements";
+  begin
+    assert_typ_printed_as "uint8_t[2]"
+      (bigarray array1 2 Bigarray.int8_unsigned);
+
+    assert_typ_printed_as "uint16_t[4]"
+      (bigarray array1 4 Bigarray.int16_unsigned);
+  end
+
+
+(*
+  Test the printing of bigarray types with floating elements.
+*)
+let test_bigarray_float_printing _ =
+  begin
+    assert_typ_printed_as "float[10][100]"
+      (bigarray genarray [|10; 100|] Bigarray.float32);
+
+    assert_typ_printed_as "double[20][30][40]"
+      (bigarray genarray [|20; 30; 40|] Bigarray.float64);
 
     assert_typ_printed_as "float _Complex[16][17][18]"
       (bigarray array3 (16, 17, 18) Bigarray.complex32);
 
     assert_typ_printed_as "double _Complex[19][20][21]"
       (bigarray array3 (19, 20, 21) Bigarray.complex64);
-
-    assert_typ_printed_as ~name:"b" "int (*b[10])(camlint(*)[5])"
-      (array 10
-         (Foreign.funptr (ptr (bigarray genarray [|5|] Bigarray.int) @->
-                          returning int)));
   end
 
 
 (*
   Test the printing of function types.
 *)
-let test_function_printing () =
+let test_function_printing _ =
   begin
     assert_fn_printed_as ~name:"a" "void a(void)"
       (void @-> returning void);
@@ -471,7 +482,7 @@ let test_function_printing () =
 (*
   Test the printing of view types.
 *)
-let test_view_printing () =
+let test_view_printing _ =
   begin
     (* By default, views are printed as the underlying type *)
 
@@ -516,8 +527,14 @@ let suite = "Type printing tests" >:::
    "printing OCaml string types"
     >:: test_ocaml_string_printing;
 
-   "printing bigarrays"
-    >:: test_bigarray_printing;
+   "printing bigarrays with signed elements"
+    >:: test_bigarray_signed_printing;
+
+   "printing bigarrays with unsigned elements"
+    >:: test_bigarray_unsigned_printing;
+
+   "printing bigarrays with floating elements"
+    >:: test_bigarray_float_printing;
 
    "printing functions"
     >:: test_function_printing;
diff --git a/tests/test-unions/test_unions.ml b/tests/test-unions/test_unions.ml
index 621e407..299a0ef 100644
--- tests/test-unions/test_unions.ml
+++ tests/test-unions/test_unions.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Unsigned
 
@@ -19,7 +19,7 @@ open Unsigned
        int64_t i;
      };
 *)
-let test_inspecting_float () =
+let test_inspecting_float _ =
   let module M = struct
     type u
     let utyp : u union typ = union "u"
@@ -53,7 +53,7 @@ let test_inspecting_float () =
        unsigned char c[sizeof int64_t];
      };
 *)
-let test_endian_detection () =
+let test_endian_detection _ =
   let module M = struct
     type e
     let etyp : e union typ = union "e"
@@ -92,7 +92,7 @@ struct
   (* Check that unions are tail-padded sufficiently to satisfy the alignment
      requirements of all their members.
   *)
-  let test_union_padding () =
+  let test_union_padding _ =
     let module M = struct
       let mkPadded : int64 -> padded union =
         fun x ->
@@ -128,7 +128,7 @@ struct
 
   (* Check that unions can be passed and returned by value.
   *)
-  let test_passing_unions_by_value () =
+  let test_passing_unions_by_value _ =
     let module M = struct
       let mkPadded : int64 -> padded union =
         fun x ->
@@ -148,7 +148,7 @@ end
 (* Check that the address of a union is equal to the addresses of each
    of its members.
 *)
-let test_union_address () =
+let test_union_address _ =
   let module M = struct
     type u
     let u : u union typ = union "u"
@@ -177,7 +177,7 @@ let test_union_address () =
 (*
   Test that attempting to update a sealed union is treated as an error.
 *)
-let test_updating_sealed_union () =
+let test_updating_sealed_union _ =
   let utyp = union "sealed" in
   let _ = field utyp "_" int in
   let () = seal utyp in
@@ -189,7 +189,7 @@ let test_updating_sealed_union () =
 (*
   Test that attempting to seal an empty union is treated as an error.
 *)
-let test_sealing_empty_union () =
+let test_sealing_empty_union _ =
   let empty = union "empty" in
 
   assert_raises (Unsupported "union with no fields")
diff --git a/tests/test-value_printing/stubs/functions.ml b/tests/test-value_printing/stubs/functions.ml
index 0850544..4684f57 100644
--- tests/test-value_printing/stubs/functions.ml
+++ tests/test-value_printing/stubs/functions.ml
@@ -41,12 +41,6 @@ struct
   let retrieve_LONG_MIN = foreign "retrieve_LONG_MIN"
     (void @-> returning long)
 
-  let retrieve_nLONG_MAX = foreign "retrieve_nLONG_MAX"
-    (void @-> returning nativeint)
-
-  let retrieve_nLONG_MIN = foreign "retrieve_nLONG_MIN"
-    (void @-> returning nativeint)
-
   let retrieve_LLONG_MAX = foreign "retrieve_LLONG_MAX"
     (void @-> returning llong)
 
diff --git a/tests/test-value_printing/test_value_printing.ml b/tests/test-value_printing/test_value_printing.ml
index e799ef2..0ff0e2a 100644
--- tests/test-value_printing/test_value_printing.ml
+++ tests/test-value_printing/test_value_printing.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -24,7 +24,7 @@ struct
     Test the printing of atomic values: arithmetic types and values of abstract
     types.
   *)
-  let test_atomic_printing () =
+  let test_atomic_printing _ =
     let open Signed in
     let open Unsigned in
 
@@ -201,16 +201,6 @@ struct
     Size_t.(assert_equal (string_of size_t (of_int 5)) (to_string (of_int 5)));
     Size_t.(assert_equal (string_of size_t _SIZE_MAX) (to_string _SIZE_MAX));
 
-    (* nativeint *)
-    let _nINT_MIN = retrieve_nLONG_MIN () in
-    let _nINT_MAX = retrieve_nLONG_MAX () in
-
-    assert_equal (string_of nativeint _nINT_MIN) (Nativeint.to_string _nINT_MIN);
-    assert_equal (string_of nativeint 0n) (Nativeint.to_string 0n);
-    assert_equal (string_of nativeint (-5n)) (Nativeint.to_string (-5n));
-    assert_equal (string_of nativeint 14n) (Nativeint.to_string 14n);
-    assert_equal (string_of nativeint _nINT_MAX) (Nativeint.to_string _nINT_MAX);
-
     (* float *)
     let _FLT_MIN = retrieve_FLT_MIN () in
     let _FLT_MAX = retrieve_FLT_MAX () in
@@ -241,7 +231,7 @@ end
 (*
   Test the printing of pointers.
 *)
-let test_pointer_printing () =
+let test_pointer_printing _ =
   (* There's not much we can test here, since pointer formatting is
      implementation-dependent.  We can at least run the pointer-formatting
      code, and test that pointers of different types are printed
@@ -257,7 +247,7 @@ let test_pointer_printing () =
 (*
   Test the printing of structs.
 *)
-let test_struct_printing () =
+let test_struct_printing _ =
   let s = structure "s" in
   let (-:) ty label = field s label ty in
   let a = array 3 int -: "arr" in
@@ -292,7 +282,7 @@ let test_struct_printing () =
 (*
   Test the printing of unions.
 *)
-let test_union_printing () =
+let test_union_printing _ =
   let s = structure "s" in
   let (-:) ty label = field s label ty in
   let i = uint16_t -: "i" in
@@ -313,7 +303,7 @@ let test_union_printing () =
 (*
   Test the printing of array types.
 *)
-let test_array_printing () =
+let test_array_printing _ =
   let arr = CArray.of_list int [-1; 0; 1] in
   let arrarr = CArray.of_list (array 3 int) [arr; arr] in
   assert_bool "array printing"
@@ -324,7 +314,7 @@ let test_array_printing () =
 (*
   Test the printing of ocaml_string values.
 *)
-let test_ocaml_string_printing () =
+let test_ocaml_string_printing _ =
   let s = "abc@%^&*[\"" in
   begin
     assert_equal
diff --git a/tests/test-variadic/test_variadic.ml b/tests/test-variadic/test_variadic.ml
index 9a7a522..b2555f3 100644
--- tests/test-variadic/test_variadic.ml
+++ tests/test-variadic/test_variadic.ml
@@ -7,7 +7,7 @@
 
 (* Tests for binding variadic functions. *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -21,7 +21,7 @@ struct
   (*
     Test calling snprintf.
   *)
-  let test_snprintf () =
+  let test_snprintf _ =
     let bufsz = 128 in
     let write snprintf apply =
       let buf = allocate_n char bufsz in
@@ -37,10 +37,21 @@ struct
         (write snprintf_char_unsigned
            (fun k -> k "a char %c and a uint %u." 'A' (UInt.of_int 33)));
 
-      assert_equal "a long long 9223372036854775807 and an int -4."
+      let ref_string =
+        match Sys.word_size with
+          | 32 -> "a long long 2147483647 and an int -4."
+          | 64 -> "a long long 9223372036854775807 and an int -4."
+          | n  -> failwith (Printf.sprintf "This test doesn't yet support word size %d" n)
+      in
+      let format_string =
+        match Sys.os_type with
+          | "Win32" -> "a long long %I64d and an int %d."
+          | _ -> "a long long %lld and an int %d."
+      in
+      assert_equal ref_string
         (write snprintf_longlong_int
-           (fun k -> k "a long long %lld and an int %d."
-             (LLong.of_int64 Int64.max_int) (-4)));
+           (fun k -> k format_string
+             (LLong.of_nativeint Nativeint.max_int) (-4)));
 
       assert_equal "a string abcde and an unsigned short ffd."
         (write snprintf_string_ushort
diff --git a/tests/test-views/test_views.ml b/tests/test-views/test_views.ml
index 6f388ca..d6d30b7 100644
--- tests/test-views/test_views.ml
+++ tests/test-views/test_views.ml
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -22,7 +22,7 @@ struct
     using strings for input parameters and a char array for an output
     parameter.  Examine the output buffer using a cast to a string view.
   *)
-  let test_passing_string_array () =
+  let test_passing_string_array _ =
     let l = ["the "; "quick "; "brown "; "fox "; "etc. "; "etc. "; ] in
     let arr = CArray.of_list string l in
 
@@ -44,7 +44,7 @@ struct
 
     using a custom view that treats chars as ints.
   *)
-  let test_passing_chars_as_ints () =
+  let test_passing_chars_as_ints _ =
     assert_equal ~msg:"toupper('x') = 'X'"
       'X' (toupper 'x');
 
@@ -58,7 +58,7 @@ struct
   (*
     Use views to create a nullable function pointer.
   *)
-  let test_nullable_function_pointer_view () =
+  let test_nullable_function_pointer_view _ =
     begin
       let fromSome = function None -> assert false | Some x -> x in
 
@@ -88,7 +88,7 @@ end
 (*
   Use the nullable pointer view to view nulls as Nones.
 *)
-let test_nullable_pointer_view () =
+let test_nullable_pointer_view _ =
   let p = allocate int 10 in
   let pp = allocate (ptr int) p in
   let npp = from_voidp (ptr_opt int) (to_voidp pp) in
@@ -110,7 +110,7 @@ let test_nullable_pointer_view () =
 (*
   Use a polar form view of complex numbers.
 *)
-let test_polar_form_view () =
+let test_polar_form_view _ =
   let module M =
   struct
     open Complex

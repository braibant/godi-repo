diff -N -u -r ../ocaml-ctypes-0.3.3.orig/.depend ./.depend
--- ../ocaml-ctypes-0.3.3.orig/.depend	2014-08-01 08:23:56.000000000 +0000
+++ ./.depend	2014-10-06 15:23:14.000000000 +0000
@@ -1,86 +1,64 @@
-_build/src/ctypes-foreign-base/ffi.cmo : _build/src/ctypes-foreign-base/weakRef.cmi \
-    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory.cmo \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes-foreign-base/ffi.cmi
-_build/src/ctypes-foreign-base/ffi.cmx : _build/src/ctypes-foreign-base/weakRef.cmx \
-    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes-foreign-base/libffi_abi.cmx \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes/ctypes_raw.cmx \
-    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes-foreign-base/ffi.cmi
-_build/src/ctypes-foreign-base/libffi_abi.cmo : _build/src/ctypes/ctypes.cmi \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi
-_build/src/ctypes-foreign-base/libffi_abi.cmx : _build/src/ctypes/ctypes.cmx \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi
-_build/src/ctypes-foreign-base/ffi.cmi : _build/src/ctypes/static.cmi \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi
-_build/src/ctypes-foreign-base/libffi_abi.cmi :
-_build/src/ctypes-foreign-base/dl.cmo : _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes-foreign-base/dl.cmi
-_build/src/ctypes-foreign-base/dl.cmx : _build/src/ctypes/ctypes_raw.cmx \
-    _build/src/ctypes-foreign-base/dl.cmi
-_build/src/ctypes-foreign-base/closure_properties.cmo : \
-    _build/src/ctypes-foreign-base/closure_properties.cmi
-_build/src/ctypes-foreign-base/closure_properties.cmx : \
-    _build/src/ctypes-foreign-base/closure_properties.cmi
-_build/src/ctypes-foreign-base/weakRef.cmi :
-_build/src/ctypes-foreign-base/dl.cmi : _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes-foreign-base/foreign_basis.cmo : _build/src/ctypes/type_printing.cmi \
-    _build/src/ctypes/std_views.cmo _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes-foreign-base/ffi.cmi \
-    _build/src/ctypes-foreign-base/dl.cmi _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes/ctypes.cmi _build/src/ctypes/coerce.cmi
-_build/src/ctypes-foreign-base/foreign_basis.cmx : _build/src/ctypes/type_printing.cmx \
-    _build/src/ctypes/std_views.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes-foreign-base/libffi_abi.cmx \
-    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes-foreign-base/ffi.cmx \
-    _build/src/ctypes-foreign-base/dl.cmx _build/src/ctypes/ctypes_raw.cmx \
-    _build/src/ctypes/ctypes.cmx _build/src/ctypes/coerce.cmx
-_build/src/ctypes-foreign-base/ffi_stubs.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes-foreign-base/ffi_stubs.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes-foreign-base/weakRef.cmo : _build/src/ctypes-foreign-base/weakRef.cmi
-_build/src/ctypes-foreign-base/weakRef.cmx : _build/src/ctypes-foreign-base/weakRef.cmi
-_build/src/ctypes-foreign-base/closure_properties.cmi :
-_build/src/discover/discover.cmo :
-_build/src/discover/discover.cmx :
-_build/src/cstubs/cstubs_public_name.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_path.cmi \
-    _build/src/cstubs/cstubs_public_name.cmi
-_build/src/cstubs/cstubs_public_name.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_path.cmx \
-    _build/src/cstubs/cstubs_public_name.cmi
-_build/src/cstubs/cstubs_generate_c.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes.cmi \
-    _build/src/cstubs/cstubs_errors.cmi _build/src/cstubs/cstubs_generate_c.cmi
-_build/src/cstubs/cstubs_generate_c.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes.cmx \
-    _build/src/cstubs/cstubs_errors.cmx _build/src/cstubs/cstubs_generate_c.cmi
+_build/src/cstubs/cstubs_emit_c.cmo : _build/src/ctypes/type_printing.cmi \
+    _build/src/ctypes/static.cmi _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_c_language.cmo
+_build/src/cstubs/cstubs_emit_c.cmx : _build/src/ctypes/type_printing.cmx \
+    _build/src/ctypes/static.cmx _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_c_language.cmx
+_build/src/cstubs/cstubs.cmi : _build/src/ctypes/ctypes.cmi
 _build/src/cstubs/cstubs_analysis.cmo : _build/src/ctypes/unsigned.cmi \
     _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/primitives.cmi \
     _build/src/ctypes/ctypes_bigarray.cmi _build/src/cstubs/cstubs_analysis.cmi
 _build/src/cstubs/cstubs_analysis.cmx : _build/src/ctypes/unsigned.cmx \
     _build/src/ctypes/static.cmx _build/src/ctypes/signed.cmx _build/src/ctypes/primitives.cmx \
     _build/src/ctypes/ctypes_bigarray.cmx _build/src/cstubs/cstubs_analysis.cmi
+_build/src/cstubs/cstubs_internals.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory_stubs.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_internals.cmi
+_build/src/cstubs/cstubs_internals.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory_stubs.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_internals.cmi
+_build/src/cstubs/cstubs_internals.cmi : _build/src/ctypes/unsigned.cmi \
+    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/primitives.cmi \
+    _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes/ctypes_bigarray.cmi _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_generate_c.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_emit_c.cmo _build/src/cstubs/cstubs_c_language.cmo \
+    _build/src/cstubs/cstubs_generate_c.cmi
+_build/src/cstubs/cstubs_generate_c.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_emit_c.cmx _build/src/cstubs/cstubs_c_language.cmx \
+    _build/src/cstubs/cstubs_generate_c.cmi
+_build/src/cstubs/cstubs_generate_c.cmi : _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_generate_ml.cmi : _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_errors.cmi :
+_build/src/cstubs/cstubs_c_language.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_errors.cmi
+_build/src/cstubs/cstubs_c_language.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_errors.cmx
+_build/src/cstubs/cstubs_inverted.cmi : _build/src/ctypes/ctypes.cmi
 _build/src/cstubs/cstubs.cmo : _build/src/ctypes/ctypes.cmi \
     _build/src/cstubs/cstubs_generate_ml.cmi _build/src/cstubs/cstubs_generate_c.cmi \
     _build/src/cstubs/cstubs.cmi
 _build/src/cstubs/cstubs.cmx : _build/src/ctypes/ctypes.cmx \
     _build/src/cstubs/cstubs_generate_ml.cmx _build/src/cstubs/cstubs_generate_c.cmx \
     _build/src/cstubs/cstubs.cmi
-_build/src/cstubs/cstubs_generate_ml.cmi : _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_errors.cmi :
-_build/src/cstubs/cstubs.cmi : _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_internals.cmi : _build/src/ctypes/unsigned.cmi \
-    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/ctypes_raw.cmo \
-    _build/src/ctypes/ctypes_bigarray.cmi _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_inverted.cmi : _build/src/ctypes/ctypes.cmi
-_build/src/cstubs/cstubs_generate_c.cmi : _build/src/ctypes/ctypes.cmi
+_build/src/cstubs/cstubs_public_name.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_path.cmi \
+    _build/src/cstubs/cstubs_public_name.cmi
+_build/src/cstubs/cstubs_public_name.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_path.cmx \
+    _build/src/cstubs/cstubs_public_name.cmi
+_build/src/cstubs/cstubs_errors.cmo : _build/src/cstubs/cstubs_errors.cmi
+_build/src/cstubs/cstubs_errors.cmx : _build/src/cstubs/cstubs_errors.cmi
+_build/src/cstubs/cstubs_inverted.cmo : _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_generate_ml.cmi _build/src/cstubs/cstubs_generate_c.cmi \
+    _build/src/cstubs/cstubs_inverted.cmi
+_build/src/cstubs/cstubs_inverted.cmx : _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_generate_ml.cmx _build/src/cstubs/cstubs_generate_c.cmx \
+    _build/src/cstubs/cstubs_inverted.cmi
 _build/src/cstubs/cstubs_generate_ml.cmo : _build/src/ctypes/static.cmi \
     _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_path.cmi \
     _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_public_name.cmi \
@@ -91,128 +69,95 @@
     _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_public_name.cmx \
     _build/src/cstubs/cstubs_errors.cmx _build/src/cstubs/cstubs_analysis.cmx \
     _build/src/cstubs/cstubs_generate_ml.cmi
+_build/src/cstubs/cstubs_analysis.cmi : _build/src/ctypes/static.cmi
 _build/src/cstubs/cstubs_public_name.cmi : _build/src/ctypes/primitives.cmi \
     _build/src/ctypes/ctypes_path.cmi
-_build/src/cstubs/cstubs_inverted.cmo : _build/src/ctypes/ctypes.cmi \
-    _build/src/cstubs/cstubs_inverted.cmi
-_build/src/cstubs/cstubs_inverted.cmx : _build/src/ctypes/ctypes.cmx \
-    _build/src/cstubs/cstubs_inverted.cmi
-_build/src/cstubs/cstubs_internals.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory_stubs.cmo \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/cstubs/cstubs_internals.cmi
-_build/src/cstubs/cstubs_internals.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory_stubs.cmx \
-    _build/src/ctypes/ctypes_raw.cmx _build/src/cstubs/cstubs_internals.cmi
-_build/src/cstubs/cstubs_analysis.cmi : _build/src/ctypes/static.cmi
-_build/src/cstubs/cstubs_errors.cmo : _build/src/cstubs/cstubs_errors.cmi
-_build/src/cstubs/cstubs_errors.cmx : _build/src/cstubs/cstubs_errors.cmi
-_build/src/configure/make_primitive_details.cmo :
-_build/src/configure/make_primitive_details.cmx :
 _build/src/libffi-abigen/libffi_abigen.cmo :
 _build/src/libffi-abigen/libffi_abigen.cmx :
-_build/src/ctypes-top/ctypes_printers.cmi : _build/src/ctypes/unsigned.cmi \
-    _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
-_build/src/ctypes-top/install_printers.cmo :
-_build/src/ctypes-top/install_printers.cmx :
-_build/src/ctypes-top/ctypes_printers.cmo : _build/src/ctypes/unsigned.cmi \
-    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes/ctypes.cmi _build/src/ctypes-top/ctypes_printers.cmi
-_build/src/ctypes-top/ctypes_printers.cmx : _build/src/ctypes/unsigned.cmx \
-    _build/src/ctypes/static.cmx _build/src/ctypes/signed.cmx _build/src/ctypes/posixTypes.cmx \
-    _build/src/ctypes/ctypes.cmx _build/src/ctypes-top/ctypes_printers.cmi
-_build/src/ctypes/primitives.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi \
-    _build/src/ctypes/primitives.cmi
-_build/src/ctypes/primitives.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/signed.cmx \
-    _build/src/ctypes/primitives.cmi
-_build/src/ctypes/type_printing.cmi : _build/src/ctypes/static.cmi
+_build/src/discover/discover.cmo :
+_build/src/discover/discover.cmx :
+_build/src/ctypes_config.cmo :
+_build/src/ctypes_config.cmx :
+_build/src/ctypes/std_views.cmo : _build/src/ctypes/std_view_stubs.cmo \
+    _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/memory.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/coerce.cmi
+_build/src/ctypes/std_views.cmx : _build/src/ctypes/std_view_stubs.cmx \
+    _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/coerce.cmx
 _build/src/ctypes/signed.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi
 _build/src/ctypes/signed.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/signed.cmi
-_build/src/ctypes/unsigned.cmi :
-_build/src/ctypes/ctypes_path.cmi :
-_build/src/ctypes/type_printing.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes/ctypes_bigarray.cmi \
-    _build/src/ctypes/common.cmo _build/src/ctypes/type_printing.cmi
-_build/src/ctypes/type_printing.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes/ctypes_bigarray.cmx \
-    _build/src/ctypes/common.cmx _build/src/ctypes/type_printing.cmi
-_build/src/ctypes/ctypes_bigarray.cmi : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/ctypes/ctypes_path.cmi
-_build/src/ctypes/posixTypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/ctypes.cmi
-_build/src/ctypes/value_printing.cmo : _build/src/ctypes/value_printing_stubs.cmo \
-    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
-    _build/src/ctypes/common.cmo
-_build/src/ctypes/value_printing.cmx : _build/src/ctypes/value_printing_stubs.cmx \
-    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes/common.cmx
-_build/src/ctypes/primitives.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi
-_build/src/ctypes/ctypes_path.cmo : _build/src/ctypes/ctypes_path.cmi
-_build/src/ctypes/ctypes_path.cmx : _build/src/ctypes/ctypes_path.cmi
-_build/src/ctypes/ctypes_primitives.cmo : _build/src/ctypes/primitives.cmi
-_build/src/ctypes/ctypes_primitives.cmx : _build/src/ctypes/primitives.cmx
-_build/src/ctypes/structs_computed.cmi : _build/src/ctypes/structs.cmi \
-    _build/src/ctypes/static.cmi
-_build/src/ctypes/structs.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/structs.cmi
-_build/src/ctypes/structs.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/structs.cmi
 _build/src/ctypes/value_printing_stubs.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo
+    _build/src/ctypes/ctypes_ptr.cmo
 _build/src/ctypes/value_printing_stubs.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes/structs_computed.cmo : _build/src/ctypes/static.cmi \
-    _build/src/ctypes/structs_computed.cmi
-_build/src/ctypes/structs_computed.cmx : _build/src/ctypes/static.cmx \
-    _build/src/ctypes/structs_computed.cmi
+    _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/common.cmo :
+_build/src/ctypes/common.cmx :
+_build/src/ctypes/structs.cmi : _build/src/ctypes/static.cmi
+_build/src/ctypes/ctypes_path.cmi :
 _build/src/ctypes/memory_stubs.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo
+    _build/src/ctypes/ctypes_ptr.cmo
 _build/src/ctypes/memory_stubs.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes/signed.cmi : _build/src/ctypes/unsigned.cmi
-_build/src/ctypes/ctypes_raw.cmo : _build/src/ctypes/signed.cmi \
-    _build/src/ctypes/ctypes_primitives.cmo
-_build/src/ctypes/ctypes_raw.cmx : _build/src/ctypes/signed.cmx \
-    _build/src/ctypes/ctypes_primitives.cmx
-_build/src/ctypes/std_views.cmo : _build/src/ctypes/std_view_stubs.cmo \
-    _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/memory.cmo \
-    _build/src/ctypes/coerce.cmi
-_build/src/ctypes/std_views.cmx : _build/src/ctypes/std_view_stubs.cmx \
-    _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx _build/src/ctypes/memory.cmx \
-    _build/src/ctypes/coerce.cmx
-_build/src/ctypes/structs.cmi : _build/src/ctypes/static.cmi
-_build/src/ctypes/static.cmo : _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_raw.cmo \
+    _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/primitives.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi
+_build/src/ctypes/static.cmo : _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_ptr.cmo \
     _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes/ctypes_bigarray.cmi \
     _build/src/ctypes/static.cmi
-_build/src/ctypes/static.cmx : _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_raw.cmx \
+_build/src/ctypes/static.cmx : _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_ptr.cmx \
     _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes/ctypes_bigarray.cmx \
     _build/src/ctypes/static.cmi
+_build/src/ctypes/primitives.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi \
+    _build/src/ctypes/primitives.cmi
+_build/src/ctypes/primitives.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/signed.cmx \
+    _build/src/ctypes/primitives.cmi
+_build/src/ctypes/ctypes_ptr.cmo : _build/src/ctypes/signed.cmi \
+    _build/src/ctypes/ctypes_primitives.cmo
+_build/src/ctypes/ctypes_ptr.cmx : _build/src/ctypes/signed.cmx \
+    _build/src/ctypes/ctypes_primitives.cmx
+_build/src/ctypes/ctypes_primitives.cmo : _build/src/ctypes/primitives.cmi
+_build/src/ctypes/ctypes_primitives.cmx : _build/src/ctypes/primitives.cmx
+_build/src/ctypes/posixTypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/ctypes.cmi
 _build/src/ctypes/static.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/signed.cmi \
-    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_raw.cmo \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_ptr.cmo \
     _build/src/ctypes/ctypes_bigarray.cmi
+_build/src/ctypes/bigarray_stubs.cmo : _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes/bigarray_stubs.cmx : _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/structs.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/structs.cmi
+_build/src/ctypes/structs.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/structs.cmi
+_build/src/ctypes/coerce.cmi : _build/src/ctypes/static.cmi
+_build/src/ctypes/value_printing.cmo : _build/src/ctypes/value_printing_stubs.cmo \
+    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/common.cmo
+_build/src/ctypes/value_printing.cmx : _build/src/ctypes/value_printing_stubs.cmx \
+    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/common.cmx
+_build/src/ctypes/ctypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/static.cmi \
+    _build/src/ctypes/signed.cmi
+_build/src/ctypes/ctypes_path.cmo : _build/src/ctypes/ctypes_path.cmi
+_build/src/ctypes/ctypes_path.cmx : _build/src/ctypes/ctypes_path.cmi
+_build/src/ctypes/unsigned.cmo : _build/src/ctypes/unsigned.cmi
+_build/src/ctypes/unsigned.cmx : _build/src/ctypes/unsigned.cmi
 _build/src/ctypes/ctypes_bigarray.cmo : _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/ctypes/ctypes_primitives.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes_primitives.cmo \
     _build/src/ctypes/ctypes_path.cmi _build/src/ctypes/bigarray_stubs.cmo \
     _build/src/ctypes/ctypes_bigarray.cmi
 _build/src/ctypes/ctypes_bigarray.cmx : _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/ctypes_raw.cmx _build/src/ctypes/ctypes_primitives.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/ctypes_primitives.cmx \
     _build/src/ctypes/ctypes_path.cmx _build/src/ctypes/bigarray_stubs.cmx \
     _build/src/ctypes/ctypes_bigarray.cmi
-_build/src/ctypes/bigarray_stubs.cmo : _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes/bigarray_stubs.cmx : _build/src/ctypes/ctypes_raw.cmx
+_build/src/ctypes/unsigned.cmi :
+_build/src/ctypes/signed.cmi : _build/src/ctypes/unsigned.cmi
 _build/src/ctypes/coerce.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/primitives.cmi \
-    _build/src/ctypes/coerce.cmi
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/coerce.cmi
 _build/src/ctypes/coerce.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/primitives.cmx \
-    _build/src/ctypes/coerce.cmi
-_build/src/ctypes/std_view_stubs.cmo : _build/src/ctypes/memory_stubs.cmo \
-    _build/src/ctypes/ctypes_raw.cmo
-_build/src/ctypes/std_view_stubs.cmx : _build/src/ctypes/memory_stubs.cmx \
-    _build/src/ctypes/ctypes_raw.cmx
-_build/src/ctypes/unsigned.cmo : _build/src/ctypes/unsigned.cmi
-_build/src/ctypes/unsigned.cmx : _build/src/ctypes/unsigned.cmi
-_build/src/ctypes/common.cmo :
-_build/src/ctypes/common.cmx :
-_build/src/ctypes/memory.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo \
-    _build/src/ctypes/ctypes_raw.cmo _build/src/ctypes/ctypes_bigarray.cmi
-_build/src/ctypes/memory.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx \
-    _build/src/ctypes/ctypes_raw.cmx _build/src/ctypes/ctypes_bigarray.cmx
-_build/src/ctypes/coerce.cmi : _build/src/ctypes/static.cmi
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/coerce.cmi
+_build/src/ctypes/structs_computed.cmi : _build/src/ctypes/structs.cmi \
+    _build/src/ctypes/static.cmi
+_build/src/ctypes/ctypes_bigarray.cmi : _build/src/ctypes/primitives.cmi \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes_path.cmi
+_build/src/ctypes/structs_computed.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/structs_computed.cmi
+_build/src/ctypes/structs_computed.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/structs_computed.cmi
 _build/src/ctypes/posixTypes.cmo : _build/src/ctypes/unsigned.cmi _build/src/ctypes/ctypes.cmi \
     _build/src/ctypes/posixTypes.cmi
 _build/src/ctypes/posixTypes.cmx : _build/src/ctypes/unsigned.cmx _build/src/ctypes/ctypes.cmx \
@@ -225,13 +170,97 @@
     _build/src/ctypes/type_printing.cmx _build/src/ctypes/structs_computed.cmx \
     _build/src/ctypes/std_views.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
     _build/src/ctypes/coerce.cmx _build/src/ctypes/ctypes.cmi
-_build/src/ctypes/ctypes.cmi : _build/src/ctypes/unsigned.cmi _build/src/ctypes/static.cmi \
-    _build/src/ctypes/signed.cmi
-_build/src/ctypes-foreign-unthreaded/foreign.cmi : \
+_build/src/ctypes/std_view_stubs.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/memory_stubs.cmo _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes/std_view_stubs.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/memory_stubs.cmx _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes/memory.cmo : _build/src/ctypes/static.cmi _build/src/ctypes/memory_stubs.cmo \
+    _build/src/ctypes/ctypes_ptr.cmo _build/src/ctypes/ctypes_bigarray.cmi
+_build/src/ctypes/memory.cmx : _build/src/ctypes/static.cmx _build/src/ctypes/memory_stubs.cmx \
+    _build/src/ctypes/ctypes_ptr.cmx _build/src/ctypes/ctypes_bigarray.cmx
+_build/src/ctypes/type_printing.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes/ctypes_bigarray.cmi \
+    _build/src/ctypes/common.cmo _build/src/ctypes/type_printing.cmi
+_build/src/ctypes/type_printing.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes/ctypes_bigarray.cmx \
+    _build/src/ctypes/common.cmx _build/src/ctypes/type_printing.cmi
+_build/src/ctypes/type_printing.cmi : _build/src/ctypes/static.cmi
+_build/src/ctypes-top/install_printers.cmo :
+_build/src/ctypes-top/install_printers.cmx :
+_build/src/ctypes-top/ctypes_printers.cmi : _build/src/ctypes/unsigned.cmi \
+    _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
+_build/src/ctypes-top/ctypes_printers.cmo : _build/src/ctypes/unsigned.cmi \
+    _build/src/ctypes/static.cmi _build/src/ctypes/signed.cmi _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes/ctypes.cmi _build/src/ctypes-top/ctypes_printers.cmi
+_build/src/ctypes-top/ctypes_printers.cmx : _build/src/ctypes/unsigned.cmx \
+    _build/src/ctypes/static.cmx _build/src/ctypes/signed.cmx _build/src/ctypes/posixTypes.cmx \
+    _build/src/ctypes/ctypes.cmx _build/src/ctypes-top/ctypes_printers.cmi
+_build/src/ctypes-foreign-threaded/foreign.cmi : \
     _build/src/ctypes-foreign-base/libffi_abi.cmi _build/src/ctypes-foreign-base/dl.cmi \
     _build/src/ctypes/ctypes.cmi
+_build/src/ctypes-foreign-threaded/foreign.cmo : \
+    _build/src/ctypes-foreign-base/foreign_basis.cmo \
+    _build/src/ctypes-foreign-base/closure_properties.cmi \
+    _build/src/ctypes-foreign-threaded/foreign.cmi
+_build/src/ctypes-foreign-threaded/foreign.cmx : \
+    _build/src/ctypes-foreign-base/foreign_basis.cmx \
+    _build/src/ctypes-foreign-base/closure_properties.cmx \
+    _build/src/ctypes-foreign-threaded/foreign.cmi
+_build/src/configure/make_primitive_details.cmo :
+_build/src/configure/make_primitive_details.cmx :
+_build/src/ctypes-foreign-base/dl.cmi : _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes-foreign-base/libffi_abi.cmo : _build/src/ctypes/ctypes.cmi \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi
+_build/src/ctypes-foreign-base/libffi_abi.cmx : _build/src/ctypes/ctypes.cmx \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi
+_build/src/ctypes-foreign-base/ffi.cmo : _build/src/ctypes-foreign-base/weakRef.cmi \
+    _build/src/ctypes/type_printing.cmi _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/memory.cmo \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes/ctypes_primitives.cmo _build/src/ctypes-foreign-base/ffi.cmi
+_build/src/ctypes-foreign-base/ffi.cmx : _build/src/ctypes-foreign-base/weakRef.cmx \
+    _build/src/ctypes/type_printing.cmx _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes-foreign-base/libffi_abi.cmx \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes/ctypes_ptr.cmx \
+    _build/src/ctypes/ctypes_primitives.cmx _build/src/ctypes-foreign-base/ffi.cmi
+_build/src/ctypes-foreign-base/closure_properties.cmi :
+_build/src/ctypes-foreign-base/ffi_stubs.cmo : _build/src/ctypes/static.cmi \
+    _build/src/ctypes/primitives.cmi _build/src/ctypes/ctypes_ptr.cmo
+_build/src/ctypes-foreign-base/ffi_stubs.cmx : _build/src/ctypes/static.cmx \
+    _build/src/ctypes/primitives.cmx _build/src/ctypes/ctypes_ptr.cmx
+_build/src/ctypes-foreign-base/dl.cmo : _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes-foreign-base/dl.cmi
+_build/src/ctypes-foreign-base/dl.cmx : _build/src/ctypes/ctypes_ptr.cmx \
+    _build/src/ctypes-foreign-base/dl.cmi
+_build/src/ctypes-foreign-base/foreign_basis.cmo : _build/src/ctypes/type_printing.cmi \
+    _build/src/ctypes/std_views.cmo _build/src/ctypes/static.cmi _build/src/ctypes/memory.cmo \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmo _build/src/ctypes-foreign-base/ffi.cmi \
+    _build/src/ctypes-foreign-base/dl.cmi _build/src/ctypes/ctypes_ptr.cmo \
+    _build/src/ctypes/ctypes.cmi _build/src/ctypes/coerce.cmi
+_build/src/ctypes-foreign-base/foreign_basis.cmx : _build/src/ctypes/type_printing.cmx \
+    _build/src/ctypes/std_views.cmx _build/src/ctypes/static.cmx _build/src/ctypes/memory.cmx \
+    _build/src/ctypes-foreign-base/libffi_abi.cmx \
+    _build/src/ctypes-foreign-base/ffi_stubs.cmx _build/src/ctypes-foreign-base/ffi.cmx \
+    _build/src/ctypes-foreign-base/dl.cmx _build/src/ctypes/ctypes_ptr.cmx \
+    _build/src/ctypes/ctypes.cmx _build/src/ctypes/coerce.cmx
+_build/src/ctypes-foreign-base/weakRef.cmo : _build/src/ctypes-foreign-base/weakRef.cmi
+_build/src/ctypes-foreign-base/weakRef.cmx : _build/src/ctypes-foreign-base/weakRef.cmi
+_build/src/ctypes-foreign-base/weakRef.cmi :
+_build/src/ctypes-foreign-base/libffi_abi.cmi :
+_build/src/ctypes-foreign-base/closure_properties.cmo : \
+    _build/src/ctypes-foreign-base/closure_properties.cmi
+_build/src/ctypes-foreign-base/closure_properties.cmx : \
+    _build/src/ctypes-foreign-base/closure_properties.cmi
+_build/src/ctypes-foreign-base/ffi.cmi : _build/src/ctypes/static.cmi \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi
 _build/src/ctypes-foreign-unthreaded/gc_mutex.cmo :
 _build/src/ctypes-foreign-unthreaded/gc_mutex.cmx :
+_build/src/ctypes-foreign-unthreaded/foreign.cmi : \
+    _build/src/ctypes-foreign-base/libffi_abi.cmi _build/src/ctypes-foreign-base/dl.cmi \
+    _build/src/ctypes/ctypes.cmi
 _build/src/ctypes-foreign-unthreaded/foreign.cmo : \
     _build/src/ctypes-foreign-unthreaded/gc_mutex.cmo \
     _build/src/ctypes-foreign-base/foreign_basis.cmo \
@@ -242,33 +271,34 @@
     _build/src/ctypes-foreign-base/foreign_basis.cmx \
     _build/src/ctypes-foreign-base/closure_properties.cmx \
     _build/src/ctypes-foreign-unthreaded/foreign.cmi
-_build/src/ctypes-foreign-threaded/foreign.cmi : \
-    _build/src/ctypes-foreign-base/libffi_abi.cmi _build/src/ctypes-foreign-base/dl.cmi \
-    _build/src/ctypes/ctypes.cmi
-_build/src/ctypes-foreign-threaded/foreign.cmo : \
-    _build/src/ctypes-foreign-base/foreign_basis.cmo \
-    _build/src/ctypes-foreign-base/closure_properties.cmi \
-    _build/src/ctypes-foreign-threaded/foreign.cmi
-_build/src/ctypes-foreign-threaded/foreign.cmx : \
-    _build/src/ctypes-foreign-base/foreign_basis.cmx \
-    _build/src/ctypes-foreign-base/closure_properties.cmx \
-    _build/src/ctypes-foreign-threaded/foreign.cmi
-_build/src/ctypes_config.cmo :
-_build/src/ctypes_config.cmx :
-_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmo : \
-    _build/examples/fts/stub-generation/bindings/fts_bindings.cmo \
+_build/examples/date/stub-generation/date_cmd.cmo : _build/src/ctypes/posixTypes.cmi \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
+    _build/examples/date/stub-generation/date_generated.cmo _build/src/ctypes/ctypes.cmi
+_build/examples/date/stub-generation/date_cmd.cmx : _build/src/ctypes/posixTypes.cmx \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
+    _build/examples/date/stub-generation/date_generated.cmx _build/src/ctypes/ctypes.cmx
+_build/examples/date/stub-generation/bindings/date_stubs.cmo : \
+    _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
+_build/examples/date/stub-generation/bindings/date_stubs.cmx : \
+    _build/src/ctypes/posixTypes.cmx _build/src/ctypes/ctypes.cmx
+_build/examples/date/stub-generation/date_generated.cmo : _build/src/ctypes/ctypes.cmi \
+    _build/src/cstubs/cstubs_internals.cmi
+_build/examples/date/stub-generation/date_generated.cmx : _build/src/ctypes/ctypes.cmx \
+    _build/src/cstubs/cstubs_internals.cmx
+_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmo : \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
     _build/src/cstubs/cstubs.cmi
-_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmx : \
-    _build/examples/fts/stub-generation/bindings/fts_bindings.cmx \
+_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmx : \
+    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
     _build/src/cstubs/cstubs.cmx
-_build/examples/fts/stub-generation/fts_cmd.cmo : \
-    _build/examples/fts/stub-generation/bindings/fts_types.cmo \
-    _build/examples/fts/stub-generation/fts_if.cmo _build/src/ctypes/ctypes.cmi
-_build/examples/fts/stub-generation/fts_cmd.cmx : \
-    _build/examples/fts/stub-generation/bindings/fts_types.cmx \
-    _build/examples/fts/stub-generation/fts_if.cmx _build/src/ctypes/ctypes.cmx
-_build/examples/fts/stub-generation/bindings/fts.cmi : \
-    _build/examples/fts/stub-generation/bindings/fts_types.cmo _build/src/ctypes/ctypes.cmi
+_build/examples/date/foreign/date.cmi : _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes/ctypes.cmi
+_build/examples/date/foreign/date.cmo : _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
+    _build/examples/date/foreign/date.cmi
+_build/examples/date/foreign/date.cmx : _build/src/ctypes/posixTypes.cmx \
+    _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
+    _build/examples/date/foreign/date.cmi
 _build/examples/fts/stub-generation/bindings/fts_types.cmo : \
     _build/src/ctypes/unsigned.cmi _build/src/ctypes/posixTypes.cmi \
     _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
@@ -283,6 +313,8 @@
 _build/examples/fts/stub-generation/bindings/fts_bindings.cmx : \
     _build/examples/fts/stub-generation/bindings/fts_types.cmx _build/src/ctypes/ctypes.cmx \
     _build/src/cstubs/cstubs.cmx
+_build/examples/fts/stub-generation/bindings/fts.cmi : \
+    _build/examples/fts/stub-generation/bindings/fts_types.cmo _build/src/ctypes/ctypes.cmi
 _build/examples/fts/stub-generation/fts_generated.cmo : _build/src/ctypes/ctypes.cmi \
     _build/src/cstubs/cstubs_internals.cmi
 _build/examples/fts/stub-generation/fts_generated.cmx : _build/src/ctypes/ctypes.cmx \
@@ -297,32 +329,44 @@
     _build/examples/fts/stub-generation/fts_generated.cmx \
     _build/examples/fts/stub-generation/bindings/fts_bindings.cmx \
     _build/src/ctypes/ctypes.cmx
-_build/examples/fts/foreign/fts_cmd.cmo : _build/examples/fts/foreign/fts.cmi \
-    _build/src/ctypes/ctypes.cmi
-_build/examples/fts/foreign/fts_cmd.cmx : _build/examples/fts/foreign/fts.cmx \
-    _build/src/ctypes/ctypes.cmx
-_build/examples/fts/foreign/fts.cmi : _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes/ctypes.cmi
+_build/examples/fts/stub-generation/fts_cmd.cmo : \
+    _build/examples/fts/stub-generation/bindings/fts_types.cmo \
+    _build/examples/fts/stub-generation/fts_if.cmo _build/src/ctypes/ctypes.cmi
+_build/examples/fts/stub-generation/fts_cmd.cmx : \
+    _build/examples/fts/stub-generation/bindings/fts_types.cmx \
+    _build/examples/fts/stub-generation/fts_if.cmx _build/src/ctypes/ctypes.cmx
+_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmo : \
+    _build/examples/fts/stub-generation/bindings/fts_bindings.cmo \
+    _build/src/cstubs/cstubs.cmi
+_build/examples/fts/stub-generation/stub-generator/fts_stub_generator.cmx : \
+    _build/examples/fts/stub-generation/bindings/fts_bindings.cmx \
+    _build/src/cstubs/cstubs.cmx
 _build/examples/fts/foreign/fts.cmo : _build/src/ctypes/unsigned.cmi \
     _build/src/ctypes/posixTypes.cmi _build/src/ctypes-foreign-threaded/foreign.cmi \
     _build/src/ctypes/ctypes.cmi _build/src/ctypes/coerce.cmi _build/examples/fts/foreign/fts.cmi
 _build/examples/fts/foreign/fts.cmx : _build/src/ctypes/unsigned.cmx \
     _build/src/ctypes/posixTypes.cmx _build/src/ctypes-foreign-threaded/foreign.cmx \
     _build/src/ctypes/ctypes.cmx _build/src/ctypes/coerce.cmx _build/examples/fts/foreign/fts.cmi
+_build/examples/fts/foreign/fts.cmi : _build/src/ctypes/posixTypes.cmi \
+    _build/src/ctypes/ctypes.cmi
+_build/examples/fts/foreign/fts_cmd.cmo : _build/examples/fts/foreign/fts.cmi \
+    _build/src/ctypes/ctypes.cmi
+_build/examples/fts/foreign/fts_cmd.cmx : _build/examples/fts/foreign/fts.cmx \
+    _build/src/ctypes/ctypes.cmx
 _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmo : \
     _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs.cmi
 _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmx : \
     _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs.cmx
+_build/examples/ncurses/stub-generation/ncurses_generated.cmo : \
+    _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_internals.cmi
+_build/examples/ncurses/stub-generation/ncurses_generated.cmx : \
+    _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_internals.cmx
 _build/examples/ncurses/stub-generation/ncurses_stub_cmd.cmo : \
     _build/examples/ncurses/stub-generation/ncurses_generated.cmo \
     _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmo
 _build/examples/ncurses/stub-generation/ncurses_stub_cmd.cmx : \
     _build/examples/ncurses/stub-generation/ncurses_generated.cmx \
     _build/examples/ncurses/stub-generation/bindings/ncurses_bindings.cmx
-_build/examples/ncurses/stub-generation/ncurses_generated.cmo : \
-    _build/src/ctypes/ctypes.cmi _build/src/cstubs/cstubs_internals.cmi
-_build/examples/ncurses/stub-generation/ncurses_generated.cmx : \
-    _build/src/ctypes/ctypes.cmx _build/src/cstubs/cstubs_internals.cmx
 _build/examples/ncurses/foreign/ncurses_cmd.cmo : \
     _build/examples/ncurses/foreign/ncurses.cmi
 _build/examples/ncurses/foreign/ncurses_cmd.cmx : \
@@ -334,38 +378,10 @@
     _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
     _build/examples/ncurses/foreign/ncurses.cmi
 _build/examples/ncurses/foreign/ncurses.cmi :
-_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmo : \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
-    _build/src/cstubs/cstubs.cmi
-_build/examples/date/stub-generation/stub-generator/date_stub_generator.cmx : \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
-    _build/src/cstubs/cstubs.cmx
-_build/examples/date/stub-generation/bindings/date_stubs.cmo : \
-    _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
-_build/examples/date/stub-generation/bindings/date_stubs.cmx : \
-    _build/src/ctypes/posixTypes.cmx _build/src/ctypes/ctypes.cmx
-_build/examples/date/stub-generation/date_cmd.cmo : _build/src/ctypes/posixTypes.cmi \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmo \
-    _build/examples/date/stub-generation/date_generated.cmo _build/src/ctypes/ctypes.cmi
-_build/examples/date/stub-generation/date_cmd.cmx : _build/src/ctypes/posixTypes.cmx \
-    _build/examples/date/stub-generation/bindings/date_stubs.cmx \
-    _build/examples/date/stub-generation/date_generated.cmx _build/src/ctypes/ctypes.cmx
-_build/examples/date/stub-generation/date_generated.cmo : _build/src/ctypes/ctypes.cmi \
-    _build/src/cstubs/cstubs_internals.cmi
-_build/examples/date/stub-generation/date_generated.cmx : _build/src/ctypes/ctypes.cmx \
-    _build/src/cstubs/cstubs_internals.cmx
-_build/examples/date/foreign/date.cmo : _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
-    _build/examples/date/foreign/date.cmi
-_build/examples/date/foreign/date.cmx : _build/src/ctypes/posixTypes.cmx \
-    _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
-    _build/examples/date/foreign/date.cmi
-_build/examples/date/foreign/date.cmi : _build/src/ctypes/posixTypes.cmi \
-    _build/src/ctypes/ctypes.cmi
+_build/examples/sigset/sigset.cmi : _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
 _build/examples/sigset/sigset.cmo : _build/src/ctypes/posixTypes.cmi \
     _build/src/ctypes-foreign-threaded/foreign.cmi _build/src/ctypes/ctypes.cmi \
     _build/examples/sigset/sigset.cmi
 _build/examples/sigset/sigset.cmx : _build/src/ctypes/posixTypes.cmx \
     _build/src/ctypes-foreign-threaded/foreign.cmx _build/src/ctypes/ctypes.cmx \
     _build/examples/sigset/sigset.cmi
-_build/examples/sigset/sigset.cmi : _build/src/ctypes/posixTypes.cmi _build/src/ctypes/ctypes.cmi
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/.gitignore ./.gitignore
--- ../ocaml-ctypes-0.3.3.orig/.gitignore	2014-08-01 08:23:56.000000000 +0000
+++ ./.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,15 +0,0 @@
-_build
-setup.data
-src/ctypes/ctypes_primitives.ml
-src/ctypes_config.h
-src/ctypes_config.ml
-*~
-generated_stubs.c
-generated_bindings.ml
-ncurses_generated.ml
-ncurses_stubs.c
-date_generated.ml
-date_stubs.c
-fts_generated.ml
-fts_stubs.c
-libffi_abi.ml
\ No newline at end of file
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/examples/fts/stub-generation/bindings/fts_types.ml ./examples/fts/stub-generation/bindings/fts_types.ml
--- ../ocaml-ctypes-0.3.3.orig/examples/fts/stub-generation/bindings/fts_types.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./examples/fts/stub-generation/bindings/fts_types.ml	2014-10-06 15:23:14.000000000 +0000
@@ -69,35 +69,39 @@
   | FTS_FOLLOW -> 2
   | FTS_SKIP   -> 4
 
+let id x = x
+
 module FTSENT =
 struct
   open PosixTypes
   open Unsigned
 
   type ftsent
-  let ftsent : ftsent structure typ = structure "FTSENT"
-  let ( -: ) ty label = field ftsent label ty
-  let fts_cycle   = ptr ftsent -: "fts_cycle"
-  let fts_parent  = ptr ftsent -: "fts_parent"
-  let fts_link    = ptr ftsent -: "fts_link"
-  let fts_number  = int        -: "fts_number"
-  let fts_pointer = ptr void   -: "fts_pointer"
-  let fts_accpath = string     -: "fts_accpath"
-  let fts_path    = string     -: "fts_path"
-  let fts_errno   = int        -: "fts_errno"
-  let fts_symfd   = int        -: "fts_symfd"
-  let fts_pathlen = ushort     -: "fts_pathlen"
-  let fts_namelen = ushort     -: "fts_namelen"
-  let fts_ino     = ino_t      -: "fts_ino"
-  let fts_dev     = dev_t      -: "fts_dev"
-  let fts_nlink   = nlink_t    -: "fts_nlink"
-  let fts_level   = short      -: "fts_level"
-  let fts_info    = ushort     -: "fts_info"
-  let fts_flags   = ushort     -: "fts_flags"
-  let fts_instr   = ushort     -: "fts_instr"
-  let fts_statp   = ptr void   -: "fts_statp" (* really a struct stat * *)
-  let fts_name    = char       -: "fts_name"
-  let () = seal ftsent
+  let struct_ftsent : ftsent structure typ = structure "FTSENT"
+  let ( -: ) ty label = field struct_ftsent label ty
+  let fts_cycle   = ptr struct_ftsent -: "fts_cycle"
+  let fts_parent  = ptr struct_ftsent -: "fts_parent"
+  let fts_link    = ptr struct_ftsent -: "fts_link"
+  let fts_number  = int               -: "fts_number"
+  let fts_pointer = ptr void          -: "fts_pointer"
+  let fts_accpath = string            -: "fts_accpath"
+  let fts_path    = string            -: "fts_path"
+  let fts_errno   = int               -: "fts_errno"
+  let fts_symfd   = int               -: "fts_symfd"
+  let fts_pathlen = ushort            -: "fts_pathlen"
+  let fts_namelen = ushort            -: "fts_namelen"
+  let fts_ino     = ino_t             -: "fts_ino"
+  let fts_dev     = dev_t             -: "fts_dev"
+  let fts_nlink   = nlink_t           -: "fts_nlink"
+  let fts_level   = short             -: "fts_level"
+  let fts_info    = ushort            -: "fts_info"
+  let fts_flags   = ushort            -: "fts_flags"
+  let fts_instr   = ushort            -: "fts_instr"
+  let fts_statp   = ptr void          -: "fts_statp" (* really a struct stat * *)
+  let fts_name    = char              -: "fts_name"
+  let () = seal struct_ftsent
+  let ftsent = view struct_ftsent
+    ~read:id ~write:id ~format_typ:(fun k fmt -> Format.pp_print_string fmt "FTSENT"; k fmt)
 
   type t = ftsent structure ptr
   let t = ptr ftsent
@@ -155,8 +159,8 @@
     Foreign.funptr_opt (ptr FTSENT.t @-> ptr FTSENT.t @-> returning int)
 
   type fts
-  let fts : fts structure typ = structure "FTS"
-  let ( -: ) ty label = field fts label ty
+  let struct_fts : fts structure typ = structure "FTS"
+  let ( -: ) ty label = field struct_fts label ty
   let fts_cur     = ptr ftsent       -: "fts_cur"
   let fts_child   = ptr ftsent       -: "fts_child"
   let fts_array   = ptr (ptr ftsent) -: "fts_array"
@@ -168,7 +172,9 @@
   let fts_compar  = compar_typ       -: "fts_compar"
   (* fts_options would work well as a view *)
   let fts_options = int              -: "fts_options"
-  let () = seal fts
+  let () = seal struct_fts
+  let fts = view struct_fts
+    ~read:id ~write:id ~format_typ:(fun k fmt -> Format.pp_print_string fmt "FTS"; k fmt)
 
   type t = { ptr : fts structure ptr;
              (* The compar field ties the lifetime of the comparison function
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/examples/ncurses/stub-generation/bindings/ncurses_bindings.ml ./examples/ncurses/stub-generation/bindings/ncurses_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/examples/ncurses/stub-generation/bindings/ncurses_bindings.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./examples/ncurses/stub-generation/bindings/ncurses_bindings.ml	2014-10-06 15:23:14.000000000 +0000
@@ -50,8 +50,6 @@
 
 let c_headers = "#include <ncurses.h>"
 
-let make_stubname cname = "ncurses_stub_" ^ cname
-
 let main () =
   let ml_out = open_out "examples/ncurses/stub-generation/ncurses_generated.ml" in
   let c_out = open_out "examples/ncurses/stub-generation/ncurses_stubs.c" in
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/Makefile.examples ./Makefile.examples
--- ../ocaml-ctypes-0.3.3.orig/Makefile.examples	2014-08-01 08:23:56.000000000 +0000
+++ ./Makefile.examples	2014-10-06 15:23:14.000000000 +0000
@@ -12,7 +12,7 @@
 fts-stub-generator.dir = examples/fts/stub-generation/stub-generator
 fts-stub-generator.subproject_deps = ctypes cstubs \
   ctypes-foreign-base ctypes-foreign-unthreaded fts-stubs
-fts-stub-generator.deps = str bigarray
+fts-stub-generator.deps = bytes str unix bigarray
 fts-stub-generator: PROJECT=fts-stub-generator
 fts-stub-generator: $$(NATIVE_TARGET)
 
@@ -20,7 +20,7 @@
 fts-cmd.dir = examples/fts/stub-generation
 fts-cmd.subproject_deps = ctypes cstubs \
   ctypes-foreign-base ctypes-foreign-unthreaded fts-stubs
-fts-cmd.deps = str bigarray
+fts-cmd.deps = bytes str unix bigarray
 fts-cmd.extra_mls = fts_generated.ml
 fts-cmd: CFLAGS+=-D_FILE_OFFSET_BITS=32
 fts-cmd: PROJECT=fts-cmd
@@ -33,7 +33,7 @@
 # subproject: fts using dynamic linking (foreign)
 fts.install = no
 fts.dir = examples/fts/foreign
-fts.deps = bigarray str
+fts.deps = bytes unix bigarray str
 fts.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
 fts: PROJECT=fts
 fts: $$(NATIVE_TARGET)
@@ -48,14 +48,14 @@
 date-stub-generator.install = no
 date-stub-generator.dir = examples/date/stub-generation/stub-generator
 date-stub-generator.subproject_deps = ctypes cstubs date-stubs
-date-stub-generator.deps = str bigarray
+date-stub-generator.deps = bytes str unix bigarray
 date-stub-generator: PROJECT=date-stub-generator
 date-stub-generator: $$(NATIVE_TARGET)
 
 date-cmd.install = no
 date-cmd.dir = examples/date/stub-generation
 date-cmd.subproject_deps = ctypes cstubs date-stubs
-date-cmd.deps = str bigarray
+date-cmd.deps = bytes str unix bigarray
 date-cmd.extra_mls = date_generated.ml
 date-cmd: PROJECT=date-cmd
 date-cmd: $$(NATIVE_TARGET)
@@ -68,7 +68,7 @@
 date.install = no
 date.dir = examples/date/foreign
 date.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
-date.deps = bigarray str
+date.deps = bytes unix bigarray str
 date: PROJECT=date
 date: $$(NATIVE_TARGET)
 
@@ -76,14 +76,14 @@
 ncurses-stubs.install = no
 ncurses-stubs.dir = examples/ncurses/stub-generation/bindings
 ncurses-stubs.subproject_deps = ctypes cstubs
-ncurses-stubs.deps = str bigarray
+ncurses-stubs.deps = bytes str unix bigarray
 ncurses-stubs: PROJECT=ncurses-stubs
 ncurses-stubs: $$(NATIVE_TARGET) $$(LIB_TARGETS)
 
 ncurses-cmd.install = no
 ncurses-cmd.dir = examples/ncurses/stub-generation
 ncurses-cmd.subproject_deps = ctypes cstubs ncurses-stubs
-ncurses-cmd.deps = str bigarray
+ncurses-cmd.deps = bytes str unix bigarray
 ncurses-cmd.extra_mls = ncurses_generated.ml
 ncurses-cmd.link_flags = -lncurses
 ncurses-cmd: PROJECT=ncurses-cmd
@@ -97,7 +97,7 @@
 ncurses.install = no
 ncurses.dir = examples/ncurses/foreign
 ncurses.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
-ncurses.deps = bigarray str
+ncurses.deps = bytes unix bigarray str
 ncurses.link_flags = -Wl,-no-as-needed -lncurses
 ncurses: PROJECT=ncurses
 ncurses: $$(NATIVE_TARGET)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/Makefile.tests ./Makefile.tests
--- ../ocaml-ctypes-0.3.3.orig/Makefile.tests	2014-08-01 08:23:56.000000000 +0000
+++ ./Makefile.tests	2014-10-07 19:55:47.000000000 +0000
@@ -268,6 +268,13 @@
 test-sizeof: PROJECT=test-sizeof
 test-sizeof: $$(NATIVE_TARGET)
 
+test-foreign_values.dir = tests/test-foreign_values
+test-foreign_values.threads = yes
+test-foreign_values.deps = str bigarray oUnit bytes
+test-foreign_values.subproject_deps = ctypes ctypes-foreign-base ctypes-foreign-unthreaded
+test-foreign_values: PROJECT=test-foreign_values
+test-foreign_values: $$(NATIVE_TARGET)
+
 test-unions-stubs.dir  = tests/test-unions/stubs
 test-unions-stubs.threads = yes
 test-unions-stubs.subproject_deps = ctypes cstubs \
@@ -639,6 +646,22 @@
 tests/test-passing-ocaml-values/generated_bindings.ml: $(BUILDDIR)/test-passing-ocaml-values-stub-generator.native
 	$< --ml-file $@
 
+test-threads-stubs.dir  = tests/test-threads/stubs
+test-threads-stubs.threads = yes
+test-threads-stubs.subproject_deps = ctypes cstubs \
+   ctypes-foreign-base ctypes-foreign-unthreaded tests-common
+test-threads-stubs: PROJECT=test-threads-stubs
+test-threads-stubs: $$(LIB_TARGETS)
+
+test-threads.dir = tests/test-threads
+test-threads.threads = yes
+test-threads.deps = str bigarray oUnit bytes
+test-threads.subproject_deps = ctypes ctypes-foreign-base \
+   ctypes-foreign-unthreaded cstubs tests-common test-threads-stubs
+test-threads.link_flags = -L$(BUILDDIR)/clib -ltest_functions
+test-threads: PROJECT=test-threads
+test-threads: $$(NATIVE_TARGET)
+
 TESTS =
 TESTS += test-raw
 TESTS += test-pointers-stubs test-pointers-stub-generator test-pointers-generated test-pointers
@@ -650,6 +673,7 @@
 TESTS += test-finalisers
 TESTS += test-cstdlib-stubs test-cstdlib-stub-generator test-cstdlib-generated test-cstdlib
 TESTS += test-sizeof
+TESTS += test-foreign_values
 TESTS += test-unions-stubs test-unions-stub-generator test-unions-generated test-unions
 TESTS += test-custom_ops
 TESTS += test-arrays-stubs test-arrays-stub-generator test-arrays-generated test-arrays
@@ -666,6 +690,7 @@
 TESTS += test-bigarrays-stubs test-bigarrays-stub-generator test-bigarrays-generated test-bigarrays
 TESTS += test-coercions-stubs test-coercions-stub-generator test-coercions-generated test-coercions
 TESTS += test-passing-ocaml-values-stubs test-passing-ocaml-values-stub-generator test-passing-ocaml-values-generated test-passing-ocaml-values
+TESTS += test-threads-stubs test-threads
 
 testlib: $(BUILDDIR)/clib/libtest_functions.so
 $(BUILDDIR)/clib/libtest_functions.so: $(BUILDDIR)/clib/test_functions.o
@@ -685,4 +710,4 @@
 run-%:	$*
 	@echo running $*
 	@cd $(BUILDDIR) && LD_LIBRARY_PATH=clib DYLD_LIBRARY_PATH=clib ./$*.native
-	@echo
+
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/META ./META
--- ../ocaml-ctypes-0.3.3.orig/META	2014-08-01 08:23:56.000000000 +0000
+++ ./META	2014-10-07 19:55:47.000000000 +0000
@@ -1,4 +1,4 @@
-version = "0.3.3"
+version = "0.3"
 description = "Combinators for binding to C libraries without writing any C."
 requires = "unix bigarray str bytes"
 archive(byte) = "ctypes.cma"
@@ -8,7 +8,7 @@
 exists_if = "ctypes.cma"
 
 package "top" (
-  version = "0.3.3"
+  version = "0.3"
   description = "Toplevel printers for C types"
   requires = "ctypes"
   archive(byte) = "ctypes-top.cma"
@@ -19,7 +19,7 @@
 )
 
 package "stubs" (
-  version = "0.3.3"
+  version = "0.3"
   description = "Stub generation from C types"
   requires = "ctypes"
   archive(byte) = "cstubs.cma"
@@ -29,29 +29,42 @@
   exists_if = "cstubs.cma"
 )
 
-package "foreign-base" (
- version = "0.3.3"
- description = "Dynamic linking of C functions"
- requires = "ctypes"
- archive(byte) = "ctypes-foreign-base.cma"
- archive(byte, plugin) = "ctypes-foreign-base.cma"
- archive(native) = "ctypes-foreign-base.cmxa"
- archive(native, plugin) = "ctypes-foreign-base.cmxs"
- exists_if = "ctypes-foreign-base.cma"
-)
-
 package "foreign" (
- version = "0.3.3"
+ version = "0.3"
  description = "Dynamic linking of C functions"
- requires = "ctypes ctypes.foreign-base"
- requires(mt) = "threads ctypes ctypes.foreign-base"
- archive(byte, mt) = "ctypes-foreign-threaded.cma"
- archive(byte, plugin, mt) = "ctypes-foreign-threaded.cma"
- archive(native, mt) = "ctypes-foreign-threaded.cmxa"
- archive(native, plugin, mt) = "ctypes-foreign-threaded.cmxs"
- archive(byte) = "ctypes-foreign-unthreaded.cma"
- archive(byte, plugin) = "ctypes-foreign-unthreaded.cma"
- archive(native) = "ctypes-foreign-unthreaded.cmxa"
- archive(native, plugin) = "ctypes-foreign-unthreaded.cmxs"
- exists_if = "ctypes-foreign-threaded.cma"
+ requires(-mt) = "ctypes.foreign.unthreaded"
+ requires(mt) = "ctypes.foreign.threaded"
+
+ package "base" (
+  version = "0.3"
+  description = "Dynamic linking of C functions (base package)"
+  requires = "ctypes"
+  archive(byte) = "ctypes-foreign-base.cma"
+  archive(byte, plugin) = "ctypes-foreign-base.cma"
+  archive(native) = "ctypes-foreign-base.cmxa"
+  archive(native, plugin) = "ctypes-foreign-base.cmxs"
+  exists_if = "ctypes-foreign-base.cma"
+ )
+
+ package "threaded" (
+  version = "0.3"
+  description = "Dynamic linking of C functions (for use in threaded programs)"
+  requires = "threads ctypes ctypes.foreign.base"
+  archive(byte) = "ctypes-foreign-threaded.cma"
+  archive(byte, plugin) = "ctypes-foreign-threaded.cma"
+  archive(native) = "ctypes-foreign-threaded.cmxa"
+  archive(native, plugin) = "ctypes-foreign-threaded.cmxs"
+  exists_if = "ctypes-foreign-threaded.cma"
+ )
+
+ package "unthreaded" (
+  version = "0.3"
+  description = "Dynamic linking of C functions (for use in unthreaded programs)"
+  requires = "ctypes ctypes.foreign.base"
+  archive(byte) = "ctypes-foreign-unthreaded.cma"
+  archive(byte, plugin) = "ctypes-foreign-unthreaded.cma"
+  archive(native) = "ctypes-foreign-unthreaded.cmxa"
+  archive(native, plugin) = "ctypes-foreign-unthreaded.cmxs"
+  exists_if = "ctypes-foreign-unthreaded.cma"
+ )
 )
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/README.md ./README.md
--- ../ocaml-ctypes-0.3.3.orig/README.md	2014-08-01 08:23:56.000000000 +0000
+++ ./README.md	2014-10-06 15:23:14.000000000 +0000
@@ -38,6 +38,20 @@
 
 ## Links
 
-* [Tutorial](https://github.com/ocamllabs/ocaml-ctypes/wiki/ctypes-tutorial)
-* [API documentation](http://ocamllabs.github.io/ocaml-ctypes)
-* [Mailing list](http://lists.ocaml.org/listinfo/ctypes)
+* [Chapter 19: Foreign Function Interface][rwo-19] of [Real World OCaml][rwo] describes ctypes
+* [Modular Foreign Function Bindings][mirage-blogpost] introduces ctypes in the context of the [Mirage][mirage] library operating system
+* [Tutorial][tutorial]
+* [API documentation][apidoc]
+* [Mailing list][mailing-list]
+* [FAQ][faq]
+
+[![Build Status](https://travis-ci.org/ocamllabs/ocaml-ctypes.svg?branch=master)](https://travis-ci.org/ocamllabs/ocaml-ctypes)
+
+[rwo-19]: https://realworldocaml.org/v1/en/html/foreign-function-interface.html
+[rwo]: http://realworldocaml.org/
+[mirage-blogpost]: http://openmirage.org/blog/modular-foreign-function-bindings
+[tutorial]: https://github.com/ocamllabs/ocaml-ctypes/wiki/ctypes-tutorial
+[apidoc]: http://ocamllabs.github.io/ocaml-ctypes
+[mailing-list]: http://lists.ocaml.org/listinfo/ctypes
+[faq]: https://github.com/ocamllabs/ocaml-ctypes/wiki/FAQ
+[mirage]: http://openmirage.org
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/setup.data ./setup.data
--- ../ocaml-ctypes-0.3.3.orig/setup.data	1970-01-01 00:00:00.000000000 +0000
+++ ./setup.data	2014-10-07 17:44:26.000000000 +0000
@@ -0,0 +1,5 @@
+libdl_opt=
+libdl_lib=
+as_needed_flags=-Wl,--no-as-needed
+libffi_opt=
+libffi_lib=-lffi
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_c_language.ml ./src/cstubs/cstubs_c_language.ml
--- ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_c_language.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./src/cstubs/cstubs_c_language.ml	2014-10-06 15:23:14.000000000 +0000
@@ -0,0 +1,105 @@
+(*
+ * Copyright (c) 2014 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* C code representation. *)
+
+open Static
+
+let fresh_var =
+  let var_counter = ref 0 in
+  fun () ->
+    incr var_counter;
+    Printf.sprintf "x%d" !var_counter
+
+type ty = Ty : _ typ -> ty
+type tfn = Fn : _ fn -> tfn
+
+type cfunction = {
+  fname: string;
+  allocates: bool;
+  reads_ocaml_heap: bool;
+  fn: tfn;
+}
+
+type cglobal = {
+  name: string;
+  typ: ty;
+  references_ocaml_heap: bool;
+}
+
+type clocal = [ `Local of string * ty ]
+type cvar = [ clocal | `Global of cglobal ]
+type cconst = [ `Int of int ]
+type cexp = [ cconst
+            | clocal
+            | `Cast of ty * cexp
+            | `Addr of cexp ]
+type clvalue = [ clocal | `Index of clvalue * cexp ]
+type camlop = [ `CAMLparam0
+              | `CAMLlocalN of cexp * cexp ]
+type ceff = [ cexp
+            | camlop
+            | `Global of cglobal
+            | `App of cfunction * cexp list
+            | `Index of ceff * cexp
+            | `Deref of cexp
+            | `Assign of clvalue * ceff ]
+type cbind = clocal * ceff
+type ccomp = [ ceff
+             | `LetConst of clocal * cconst * ccomp
+             | `CAMLreturnT of ty * cexp
+             | `Let of cbind * ccomp ]
+type cfundec = [ `Fundec of string * (string * ty) list * ty ]
+type cfundef = [ `Function of cfundec * ccomp ]
+
+let rec return_type : type a. a fn -> ty = function
+  | Function (_, f) -> return_type f
+  | Returns t -> Ty t
+
+let args : type a. a fn -> (string * ty) list = fun fn ->
+  let rec loop : type a. a Ctypes.fn -> (string * ty) list = function
+    | Static.Function (ty, fn) -> (fresh_var (), Ty ty) :: loop fn
+    | Static.Returns _ -> []
+  in loop fn
+
+module Type_C =
+struct
+  let rec cexp : cexp -> ty = function
+    | `Int _ -> Ty int
+    | `Local (_, ty) -> ty
+    | `Cast (Ty ty, _) -> Ty ty
+    | `Addr e -> let Ty ty = cexp e in Ty (Pointer ty)
+
+  let camlop : camlop -> ty = function
+    | `CAMLparam0
+    | `CAMLlocalN _ -> Ty Void
+
+  let rec ceff : ceff -> ty = function
+    | #cexp as e -> cexp e
+    | #camlop as o -> camlop o
+    | `Global { typ } -> typ
+    | `App ({ fn = Fn f }, _) -> return_type f
+    | `Index (e, _) -> reference_ceff e
+    | `Deref e -> reference_ceff (e :> ceff)
+    | `Assign (_, rv) -> ceff rv
+  and reference_ceff : ceff -> ty =
+    fun e ->
+      begin match ceff e with
+      | Ty (Pointer ty) -> Ty ty
+      | Ty (Array (ty, _)) -> Ty ty
+      | Ty t -> Cstubs_errors.internal_error
+        "dereferencing expression of non-pointer type %s"
+        (Ctypes.string_of_typ t)
+      end
+
+  let rec ccomp : ccomp -> ty = function
+    | #cexp as e -> cexp e
+    | #ceff as e -> ceff e
+    | `Let (_, c)
+    | `LetConst (_, _, c) -> ccomp c
+    | `CAMLreturnT (ty, _) -> ty
+end
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_emit_c.ml ./src/cstubs/cstubs_emit_c.ml
--- ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_emit_c.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./src/cstubs/cstubs_emit_c.ml	2014-10-06 15:23:14.000000000 +0000
@@ -0,0 +1,127 @@
+(*
+ * Copyright (c) 2014 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* C pretty printing. *)
+
+open Static
+open Cstubs_c_language
+open Format
+
+let format_seq lbr fmt_item sep rbr fmt items =
+  let open Format in
+  fprintf fmt "%s@[@[" lbr;
+    ListLabels.iteri items ~f:(fun i item ->
+      if i <> 0 then fprintf fmt "@]%s@ @[" sep;
+      fmt_item fmt item);
+  fprintf fmt "@]%s@]" rbr
+
+let format_ty fmt (Ty ty) = Ctypes.format_typ fmt ty
+
+let cvar_name = function
+  | `Local (name, _) | `Global { name } -> name
+
+let cvar fmt v = fprintf fmt "%s" (cvar_name v)
+
+let cconst fmt (`Int i) = fprintf fmt "%d" i
+
+(* Determine whether the C expression [(ty)e] is equivalent to [e] *)
+let cast_unnecessary : ty -> cexp -> bool =
+  let rec harmless l r = match l, r with
+  | Ty (Pointer Void), Ty (Pointer _) -> true
+  | Ty (View { ty }), t -> harmless (Ty ty) t
+  | t, Ty (View { ty }) -> harmless t (Ty ty)
+  | (Ty (Primitive _) as l), (Ty (Primitive _) as r) -> l = r
+  | _ -> false
+  in
+  fun ty e -> harmless ty (Type_C.cexp e)
+
+let rec cexp fmt : cexp -> unit = function
+  | #cconst as c -> cconst fmt c
+  | `Local _ as x -> cvar fmt x
+  | `Cast (ty, e) when cast_unnecessary ty e -> cexp fmt e
+  | `Cast (ty, e) -> fprintf fmt "@[@[(%a)@]%a@]" format_ty ty cexp e
+  | `Addr e -> fprintf fmt "@[&@[%a@]@]" cexp e
+
+let rec clvalue fmt : clvalue -> unit = function
+  | `Local _ as x -> cvar fmt x
+  | `Index (lv, i) ->
+    fprintf fmt "@[@[%a@]@[[%a]@]@]" clvalue lv cexp i
+
+let camlop fmt : camlop -> unit = function
+  | `CAMLparam0 -> Format.fprintf fmt "CAMLparam0()"
+  | `CAMLlocalN (e, c) -> Format.fprintf fmt "CAMLlocalN(@[%a@],@ @[%a@])"
+    cexp e cexp c
+
+let rec ceff fmt : ceff -> unit = function
+  | #cexp as e -> cexp fmt e
+  | #camlop as o -> camlop fmt o
+  | `Global _ as x -> cvar fmt x
+  | `App ({fname}, es) ->
+    fprintf fmt "@[%s(@[" fname;
+    let last_exp = List.length es - 1 in
+    List.iteri
+      (fun i e ->
+        fprintf fmt "@[%a@]%(%)" cexp e
+          (if i <> last_exp then ",@ " else ""))
+      es;
+    fprintf fmt ")@]@]";
+  | `Index (e, i) ->
+    fprintf fmt "@[@[%a@]@[[%a]@]@]" ceff e cexp i
+  | `Deref e -> fprintf fmt "@[*@[%a@]@]" cexp e
+  | `Assign (lv, e) ->
+    fprintf fmt "@[@[%a@]@;=@;@[%a@]@]" clvalue lv ceff e
+
+let rec ccomp fmt : ccomp -> unit = function
+  | #cexp as e -> fprintf fmt "@[<2>return@;@[%a@]@];" cexp e
+  | #ceff as e -> fprintf fmt "@[<2>return@;@[%a@]@];" ceff e
+  | `CAMLreturnT (Ty Void, e) ->
+    fprintf fmt "@[CAMLreturn0@];"
+  | `CAMLreturnT (Ty ty, e) ->
+    fprintf fmt "@[<2>CAMLreturnT(@[%a@],@;@[%a@])@];"
+      (fun t -> Ctypes.format_typ t) ty
+      cexp e
+  | `Let (xe, `Cast (ty, (#cexp as e'))) when cast_unnecessary ty e' ->
+    ccomp fmt (`Let (xe, e'))
+  | `Let ((`Local (x, _), e), `Local (y, _)) when x = y ->
+    ccomp fmt (e :> ccomp)
+  | `Let ((`Local (name, Ty Void), e), s) ->
+    fprintf fmt "@[%a;@]@ %a" ceff e ccomp s
+  | `Let ((`Local (name, Ty (Struct { tag })), e), s) ->
+    fprintf fmt "@[struct@;%s@;%s@;=@;@[%a;@]@]@ %a"
+      tag name ceff e ccomp s
+  | `Let ((`Local (name, Ty (Union { utag })), e), s) ->
+    fprintf fmt "@[union@;%s@;%s@;=@;@[%a;@]@]@ %a"
+      utag name ceff e ccomp s
+  | `Let ((`Local (name, Ty ty), e), s) ->
+    fprintf fmt "@[@[%a@]@;=@;@[%a;@]@]@ %a"
+      (Ctypes.format_typ ~name) ty ceff e ccomp s
+  | `LetConst (`Local (x, _), `Int c, s) ->
+    fprintf fmt "@[enum@ {@[@ %s@ =@ %d@ };@]@]@ %a"
+      x c ccomp s
+
+let format_parameter_list parameters k fmt =
+  let format_arg fmt (name, Ty t) =
+    Type_printing.format_typ ~name fmt t
+  in
+  match parameters with
+  | [] ->
+    Format.fprintf fmt "%t(void)" k
+  | _ ->
+    Format.fprintf fmt "@[%t@[%a@]@]" k
+      (format_seq "(" format_arg "," ")")
+      parameters
+
+let cfundec : Format.formatter -> cfundec -> unit =
+  fun fmt (`Fundec (name, args, Ty return)) ->
+    Type_printing.format_typ' return
+      (fun context fmt ->
+        format_parameter_list args (Type_printing.format_name ~name) fmt)
+      `nonarray fmt
+
+let cfundef fmt (`Function (dec, body) : cfundef) =
+  fprintf fmt "%a@\n{@[<v 2>@\n%a@]@\n}@\n" 
+    cfundec dec ccomp body
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_generate_c.ml ./src/cstubs/cstubs_generate_c.ml
--- ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_generate_c.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/cstubs/cstubs_generate_c.ml	2014-10-06 15:23:14.000000000 +0000
@@ -8,230 +8,16 @@
 (* C stub generation *)
 
 open Static
-open Cstubs_errors
-
-type ty = Ty : _ typ -> ty
-type _ tfn =
-  Typ : _ typ -> [`Typ] tfn
-| Fn : _ fn -> [`Fn] tfn
-
-type 'a id_properties = {
-  name: string;
-  allocates: bool;
-  reads_ocaml_heap: bool;
-  tfn: 'a tfn;
-}
-
-type 'a cglobal = [ `Global of 'a id_properties ]
-type clocal = [ `Local of string * ty ]
-type cvar = [ clocal | [`Typ] cglobal ]
-type cconst = [ `Int of int ]
-type cexp = [ cconst
-            | cvar
-            | `Cast of ty * cexp
-            | `Addr of cexp ]
-type clvalue = [ clocal | `Index of clvalue * cexp ]
-type camlop = [ `CAMLparam0
-              | `CAMLlocalN of cexp * cexp ]
-type ceff = [ cexp
-            | camlop
-            | `App of [`Fn] cglobal * cexp list
-            | `Index of cexp * cexp
-            | `Deref of cexp
-            | `Assign of clvalue * ceff ]
-type cbind = clocal * ceff
-type ccomp = [ ceff
-             | `LetConst of clocal * cconst * ccomp
-             | `CAMLreturnT of ty * cexp
-             | `Let of cbind * ccomp ]
-type cfundec = [ `Fundec of string * (string * ty) list * ty ]
-type cfundef = [ `Function of cfundec * ccomp ]
+open Cstubs_c_language
 
 let max_byte_args = 5
 
-let var_counter = ref 0
-let fresh_var () =
-  incr var_counter;
-  Printf.sprintf "x%d" !var_counter
-
-let rec return_type : type a. a fn -> ty = function
-  | Function (_, f) -> return_type f
-  | Returns t -> Ty t
-
-let args : type a. a fn -> (string * ty) list = fun fn ->
-  let rec loop : type a. a Ctypes.fn -> (string * ty) list = function
-    | Static.Function (ty, fn) -> (fresh_var (), Ty ty) :: loop fn
-    | Static.Returns _ -> []
-  in loop fn
-
-module Type_C =
-struct
-  let rec cexp : cexp -> ty = function
-    | `Int _ -> Ty int
-    | `Local (_, ty) -> ty
-    | `Global { tfn = Typ t } -> Ty t
-    | `Cast (Ty ty, _) -> Ty ty
-    | `Addr e -> let Ty ty = cexp e in Ty (Pointer ty)
-
-  let camlop : camlop -> ty = function
-    | `CAMLparam0
-    | `CAMLlocalN _ -> Ty Void
-
-  let rec ceff : ceff -> ty = function
-    | #cexp as e -> cexp e
-    | #camlop as o -> camlop o
-    | `App (`Global  { tfn = Fn f; name }, _) -> return_type f
-    | `Index (e, _)
-    | `Deref e ->
-      begin match cexp e with
-      | Ty (Pointer ty) -> Ty ty
-      | Ty (Array (ty, _)) -> Ty ty
-      | Ty t -> internal_error
-        "dereferencing expression of non-pointer type %s"
-        (Ctypes.string_of_typ t)
-      end
-    | `Assign (_, rv) -> ceff rv
-
-  let rec ccomp : ccomp -> ty = function
-    | #cexp as e -> cexp e
-    | #ceff as e -> ceff e
-    | `Let (_, c)
-    | `LetConst (_, _, c) -> ccomp c
-    | `CAMLreturnT (ty, _) -> ty
-end
-
 (* We're using an abstract type ([value]) as an argument and return type, so
    we'll use the [Function] and [Return] constructors directly.  The smart
    constructors [@->] and [returning] would reject the abstract type. *)
 let (@->) f t = Function (f, t)
 let returning t = Returns t
 
-module Emit_C =
-struct
-  open Format
-
-  let format_seq lbr fmt_item sep rbr fmt items =
-    let open Format in
-    fprintf fmt "%s@[@[" lbr;
-      ListLabels.iteri items ~f:(fun i item ->
-        if i <> 0 then fprintf fmt "@]%s@ @[" sep;
-        fmt_item fmt item);
-    fprintf fmt "@]%s@]" rbr
-
-  let format_ty fmt (Ty ty) = Ctypes.format_typ fmt ty
-
-  let cvar_name = function
-    | `Local (name, _) | `Global { name } -> name
-
-  let cvar fmt v = fprintf fmt "%s" (cvar_name v)
-
-  let cconst fmt (`Int i) = fprintf fmt "%d" i
-
-  (* Determine whether the C expression [(ty)e] is equivalent to [e] *)
-  let cast_unnecessary : ty -> cexp -> bool =
-    let rec harmless l r = match l, r with
-    | Ty (Pointer Void), Ty (Pointer _) -> true
-    | Ty (View { ty }), t -> harmless (Ty ty) t
-    | t, Ty (View { ty }) -> harmless t (Ty ty)
-    | (Ty (Primitive _) as l), (Ty (Primitive _) as r) -> l = r
-    | _ -> false
-    in
-    fun ty e -> harmless ty (Type_C.cexp e)
-
-  let rec cexp env fmt : cexp -> unit = function
-    | #cconst as c -> cconst fmt c
-    | `Local (y, _) as x ->
-      begin
-        try cexp env fmt (List.assoc y env)
-        with Not_found -> cvar fmt x
-      end
-    | #cvar as x -> cvar fmt x
-    | `Cast (ty, e) when cast_unnecessary ty e -> cexp env fmt e
-    | `Cast (ty, e) -> fprintf fmt "@[@[(%a)@]%a@]" format_ty ty (cexp env) e
-    | `Addr e -> fprintf fmt "@[&@[%a@]@]" (cexp env) e
-
-  let rec clvalue env fmt : clvalue -> unit = function
-    | `Local _ as x -> cvar fmt x
-    | `Index (lv, i) ->
-      fprintf fmt "@[@[%a@]@[[%a]@]@]" (clvalue env) lv (cexp env) i
-
-  let camlop env fmt : camlop -> unit = function
-    | `CAMLparam0 -> Format.fprintf fmt "CAMLparam0()"
-    | `CAMLlocalN (e, c) -> Format.fprintf fmt "CAMLlocalN(@[%a@],@ @[%a@])"
-      (cexp env) e (cexp env) c
-
-  let rec ceff env fmt : ceff -> unit = function
-    | #cexp as e -> cexp env fmt e
-    | #camlop as o -> camlop env fmt o
-    | `App (v, es) ->
-      fprintf fmt "@[%s(@[" (cvar_name v);
-      let last_exp = List.length es - 1 in
-      List.iteri
-        (fun i e ->
-          fprintf fmt "@[%a@]%(%)" (cexp env) e
-            (if i <> last_exp then ",@ " else ""))
-        es;
-      fprintf fmt ")@]@]";
-    | `Index (e, i) ->
-      fprintf fmt "@[@[%a@]@[[%a]@]@]"
-        (cexp env) e (cexp env) i
-    | `Deref e -> fprintf fmt "@[*@[%a@]@]" (cexp env) e
-    | `Assign (lv, e) ->
-      fprintf fmt "@[@[%a@]@;=@;@[%a@]@]"
-        (clvalue env) lv (ceff env) e
-
-  let rec ccomp env fmt : ccomp -> unit = function
-    | #cexp as e -> fprintf fmt "@[<2>return@;@[%a@]@];" (cexp env) e
-    | #ceff as e -> fprintf fmt "@[<2>return@;@[%a@]@];" (ceff env) e
-    | `CAMLreturnT (Ty Void, e) ->
-      fprintf fmt "@[CAMLreturn0@];"
-    | `CAMLreturnT (Ty ty, e) ->
-      fprintf fmt "@[<2>CAMLreturnT(@[%a@],@;@[%a@])@];"
-        (fun t -> Ctypes.format_typ t) ty
-        (cexp env) e
-    | `Let (xe, `Cast (ty, (#cexp as e'))) when cast_unnecessary ty e' ->
-      ccomp env fmt (`Let (xe, e'))
-    | `Let ((`Local (x, _), e), `Local (y, _)) when x = y ->
-      ccomp env fmt (e :> ccomp)
-    | `Let ((`Local (name, Ty Void), e), s) ->
-      fprintf fmt "@[%a;@]@ %a" (ceff env) e (ccomp env) s
-    | `Let ((`Local (name, Ty (Struct { tag })), e), s) ->
-      fprintf fmt "@[struct@;%s@;%s@;=@;@[%a;@]@]@ %a"
-        tag name (ceff env) e (ccomp env) s
-    | `Let ((`Local (name, Ty (Union { utag })), e), s) ->
-      fprintf fmt "@[union@;%s@;%s@;=@;@[%a;@]@]@ %a"
-        utag name (ceff env) e (ccomp env) s
-    | `Let ((`Local (name, Ty ty), e), s) ->
-      fprintf fmt "@[@[%a@]@;=@;@[%a;@]@]@ %a"
-        (Ctypes.format_typ ~name) ty (ceff env) e (ccomp env) s
-    | `LetConst (`Local (x, _), `Int c, s) ->
-      fprintf fmt "@[enum@ {@[@ %s@ =@ %d@ };@]@]@ %a"
-        x c (ccomp env) s
-
-  let format_parameter_list parameters k fmt =
-    let format_arg fmt (name, Ty t) =
-      Type_printing.format_typ ~name fmt t
-    in
-    match parameters with
-    | [] ->
-      Format.fprintf fmt "%t(void)" k
-    | _ ->
-      Format.fprintf fmt "@[%t@[%a@]@]" k
-        (format_seq "(" format_arg "," ")")
-        parameters
-
-  let cfundec : Format.formatter -> cfundec -> unit =
-    fun fmt (`Fundec (name, args, Ty return)) ->
-      Type_printing.format_typ' return
-        (fun context fmt ->
-          format_parameter_list args (Type_printing.format_name ~name) fmt)
-        `nonarray fmt
-
-  let cfundef fmt (`Function (dec, body) : cfundef) =
-    fprintf fmt "%a@\n{@[<v 2>@\n%a@]@\n}@\n" 
-      cfundec dec (ccomp []) body
-end
-
 let value = abstract ~name:"value" ~size:0 ~alignment:0
 
 module Generate_C =
@@ -240,9 +26,9 @@
     let msg = Printf.sprintf "cstubs does not support passing %s" what in
     raise (Unsupported msg)
 
-  let reader name fn = { name; allocates = false; reads_ocaml_heap = true; tfn = Fn fn }
-  let conser name fn = { name; allocates = true; reads_ocaml_heap = false; tfn = Fn fn }
-  let immediater name fn = { name; allocates = false; reads_ocaml_heap = false; tfn = Fn fn }
+  let reader fname fn = { fname; allocates = false; reads_ocaml_heap = true; fn = Fn fn }
+  let conser fname fn = { fname; allocates = true; reads_ocaml_heap = false; fn = Fn fn }
+  let immediater fname fn = { fname; allocates = false; reads_ocaml_heap = false; fn = Fn fn }
 
   let local name ty = `Local (name, Ty ty)
 
@@ -331,46 +117,46 @@
     | Complex32 -> conser "ctypes_copy_float_complex" (complex32 @-> returning value)
     | Complex64 -> conser "ctypes_copy_double_complex" (complex64 @-> returning value)
 
-  let to_ptr : cexp -> ccomp =
-    fun x -> `App (`Global (reader "CTYPES_TO_PTR" (value @-> returning (ptr void))),
+  let of_fatptr : cexp -> ccomp =
+    fun x -> `App (reader "CTYPES_ADDR_OF_FATPTR"
+                          (value @-> returning (ptr void)),
                    [x])
 
   let string_to_ptr : cexp -> ccomp =
-    fun x -> `App (`Global (reader "CTYPES_PTR_OF_OCAML_STRING"
-                              (value @-> returning (ptr void))),
+    fun x -> `App (reader "CTYPES_PTR_OF_OCAML_STRING"
+                          (value @-> returning (ptr void)),
                    [x])
 
   let float_array_to_ptr : cexp -> ccomp =
-    fun x -> `App (`Global (reader "CTYPES_PTR_OF_FLOAT_ARRAY"
-                              (value @-> returning (ptr void))),
+    fun x -> `App (reader "CTYPES_PTR_OF_FLOAT_ARRAY"
+                          (value @-> returning (ptr void)),
                    [x])
 
   let from_ptr : cexp -> ceff =
-    fun x -> `App (`Global (conser "CTYPES_FROM_PTR" (ptr void @-> returning value)),
+    fun x -> `App (conser "CTYPES_FROM_PTR"
+                          (ptr void @-> returning value),
                    [x])
 
   let val_unit : ceff = `Global { name = "Val_unit";
-                                  allocates = false;
-                                  reads_ocaml_heap = false;
-                                  tfn = Typ value; }
+                                  references_ocaml_heap = true;
+                                  typ = Ty value }
 
-  let functions : cexp = `Global
+  let functions : ceff = `Global
     { name = "functions";
-      allocates = false;
-      reads_ocaml_heap = true;
-      tfn = Typ (ptr value) }
+      references_ocaml_heap = true;
+      typ = Ty (ptr value) }
 
-  let caml_callbackN : [ `Fn] cglobal = `Global
-    { name = "caml_callbackN";
+  let caml_callbackN : cfunction =
+    { fname = "caml_callbackN";
       allocates = true;
       reads_ocaml_heap = true;
-      tfn = Fn (value @-> int @-> ptr value @-> returning value) }
+      fn = Fn (value @-> int @-> ptr value @-> returning value) }
 
-  let copy_bytes : [`Fn] cglobal =
-    `Global { name = "ctypes_copy_bytes";
-              allocates = true;
-              reads_ocaml_heap = true;
-              tfn = Fn (ptr void @-> size_t @-> returning value) }
+  let copy_bytes : cfunction =
+    { fname = "ctypes_copy_bytes";
+      allocates = true;
+      reads_ocaml_heap = true;
+      fn = Fn (ptr void @-> size_t @-> returning value) }
 
   let cast : type a b. from:ty -> into:ty -> ccomp -> ccomp =
     fun ~from:(Ty from) ~into e ->
@@ -381,15 +167,15 @@
     fun ty x -> match ty with
     | Void -> None
     | Primitive p ->
-      let { tfn = Fn fn } as prj = prim_prj p in
+      let { fn = Fn fn } as prj = prim_prj p in
       let rt = return_type fn in
-      Some (cast ~from:rt ~into:(Ty (Primitive p)) (`App (`Global prj, [x])))
-    | Pointer _ -> Some (to_ptr x)
+      Some (cast ~from:rt ~into:(Ty (Primitive p)) (`App (prj, [x])))
+    | Pointer _ -> Some (of_fatptr x)
     | Struct s ->
-      Some ((to_ptr x, ptr void) >>= fun y ->
+      Some ((of_fatptr x, ptr void) >>= fun y ->
             `Deref (`Cast (Ty (ptr ty), y)))
     | Union u -> 
-      Some ((to_ptr x, ptr void) >>= fun y ->
+      Some ((of_fatptr x, ptr void) >>= fun y ->
             `Deref (`Cast (Ty (ptr ty), y)))
     | Abstract _ -> report_unpassable "values of abstract type"
     | View { ty } -> prj ty x
@@ -402,7 +188,7 @@
   let rec inj : type a. a typ -> cexp -> ceff =
     fun ty x -> match ty with
     | Void -> val_unit
-    | Primitive p -> `App (`Global (prim_inj p), [`Cast (Ty (Primitive p), x)])
+    | Primitive p -> `App (prim_inj p, [`Cast (Ty (Primitive p), x)])
     | Pointer _ -> from_ptr x
     | Struct s -> `App (copy_bytes, [`Addr x; `Int (sizeof ty)])
     | Union u -> `App (copy_bytes, [`Addr x; `Int (sizeof ty)])
@@ -429,10 +215,10 @@
 
   let fn : type a. cname:string -> stub_name:string -> a Static.fn -> cfundef =
     fun ~cname ~stub_name f ->
-      let fvar = `Global { name = cname;
-                           allocates = false;
-                           reads_ocaml_heap = false;
-                           tfn = Fn f; } in
+      let fvar = { fname = cname;
+                   allocates = false;
+                   reads_ocaml_heap = false;
+                   fn = Fn f; } in
       let rec body : type a. _ -> a fn -> _ =
          fun vars -> function 
          | Returns t ->
@@ -451,20 +237,20 @@
                  body [] f')
 
   let byte_fn : type a. string -> a Static.fn -> int -> cfundef =
-    fun name fn nargs ->
+    fun fname fn nargs ->
       let argv = ("argv", Ty (ptr value)) in
       let argc = ("argc", Ty int) in
-      let f = `Global { name ;
-                        allocates = true;
-                        reads_ocaml_heap = true;
-                        tfn = Fn fn }
+      let f = { fname ;
+                allocates = true;
+                reads_ocaml_heap = true;
+                fn = Fn fn }
       in
       let rec build_call ?(args=[]) = function
         | 0 -> `App (f, args)
         | n -> (`Index (`Local argv, `Int (n - 1)), value) >>= fun x ->
                build_call ~args:(x :: args) (n - 1)
       in
-      let bytename = Printf.sprintf "%s_byte%d" name nargs in
+      let bytename = Printf.sprintf "%s_byte%d" fname nargs in
       `Function (`Fundec (bytename, [argv; argc], Ty value),
                  build_call nargs)
 
@@ -524,15 +310,15 @@
   in
   let nargs = List.length xs in
   if nargs > max_byte_args then begin
-    Emit_C.cfundef fmt dec;
-    Emit_C.cfundef fmt (Generate_C.byte_fn f fn nargs)
+    Cstubs_emit_c.cfundef fmt dec;
+    Cstubs_emit_c.cfundef fmt (Generate_C.byte_fn f fn nargs)
   end
   else
-    Emit_C.cfundef fmt dec
+    Cstubs_emit_c.cfundef fmt dec
 
 let inverse_fn ~stub_name fmt fn : unit =
-  Emit_C.cfundef fmt (Generate_C.inverse_fn ~stub_name fn)
+  Cstubs_emit_c.cfundef fmt (Generate_C.inverse_fn ~stub_name fn)
 
 let inverse_fn_decl ~stub_name fmt fn =
   Format.fprintf fmt "@[%a@];@\n"
-    Emit_C.cfundec (Generate_C.fundec stub_name fn)
+    Cstubs_emit_c.cfundec (Generate_C.fundec stub_name fn)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_generate_ml.ml ./src/cstubs/cstubs_generate_ml.ml
--- ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_generate_ml.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/cstubs/cstubs_generate_ml.ml	2014-10-06 15:23:14.000000000 +0000
@@ -191,6 +191,7 @@
 
 let managed_buffer = `Ident (path_of_string "Memory_stubs.managed_buffer")
 let voidp = `Ident (path_of_string "CI.voidp")
+let fatptr = `Appl (path_of_string "CI.fatptr", [`Ident (path_of_string "_")])
 let string = `Ident (path_of_string "string")
 let float_array = `Appl (path_of_string "array",
                          [`Ident (path_of_string "float")])
@@ -220,10 +221,10 @@
 let rec ml_typ_of_arg_typ : type a. a typ -> ml_type = function
   | Void -> `Ident (path_of_string "unit")
   | Primitive p -> `Ident (Cstubs_public_name.ident_of_ml_prim (Primitives.ml_prim p))
-  | Pointer _   -> voidp
-  | Struct _    -> voidp
-  | Union _     -> voidp
-  | Abstract _  -> voidp
+  | Pointer _   -> fatptr
+  | Struct _    -> fatptr
+  | Union _     -> fatptr
+  | Abstract _  -> fatptr
   | View { ty } -> ml_typ_of_arg_typ ty
   | Array _    as a -> internal_error
     "Unexpected array in an argument type: %s" (Ctypes.string_of_typ a)
@@ -240,11 +241,22 @@
            [`Appl (path_of_string "array",
                    [`Ident (path_of_string "float")])])
 
-let rec ml_external_type_of_fn : type a. a fn -> ml_external_type = function
-  | Returns t -> `Prim ([], ml_typ_of_return_typ t)
+type polarity = In | Out
+
+let flip = function
+  | In -> Out
+  | Out -> In
+
+let ml_typ_of_typ = function
+    In -> ml_typ_of_arg_typ
+  | Out -> ml_typ_of_return_typ
+
+let rec ml_external_type_of_fn : type a. a fn -> polarity -> ml_external_type =
+  fun fn polarity -> match fn with
+  | Returns t -> `Prim ([], ml_typ_of_typ polarity t)
   | Function (f, t) ->
-    let `Prim (l, t) = ml_external_type_of_fn t in
-    `Prim (ml_typ_of_arg_typ f :: l, t)
+    let `Prim (l, t) = ml_external_type_of_fn t polarity in
+    `Prim (ml_typ_of_typ (flip polarity) f :: l, t)
 
 let var_counter = ref 0
 let fresh_var () =
@@ -253,7 +265,7 @@
 
 let extern ~stub_name ~external_name fmt fn =
   let ext =
-    let typ = ml_external_type_of_fn fn in
+    let typ = ml_external_type_of_fn fn Out in
     ({ ident = external_name;
        typ = typ;
        primname = stub_name;
@@ -264,12 +276,6 @@
 let static_con c args =
   `Con (Ctypes_path.path_of_string ("CI." ^ c), args)
 
-type polarity = In | Out
-
-let flip = function
-  | In -> Out
-  | Out -> In
-
 let rec pattern_and_exp_of_typ :
   type a. a typ -> ml_exp -> polarity -> ml_pat * ml_exp option =
   fun typ e pol -> match typ with
@@ -282,14 +288,14 @@
     let x = fresh_var () in
     let pat = static_con "Pointer" [`Var x] in
     begin match pol with
-    | In -> (pat, Some (`Appl (`Ident (path_of_string "CI.raw_ptr"), e)))
+    | In -> (pat, Some (`Appl (`Ident (path_of_string "CI.cptr"), e)))
     | Out -> (pat, Some (`MakePtr (`Ident (path_of_string x), e)))
     end
   | Struct _ ->
     begin match pol with
     | In ->
       let pat = static_con "Struct" [`Underscore] in
-      (pat, Some (`Appl (`Ident (path_of_string "CI.raw_ptr"),
+      (pat, Some (`Appl (`Ident (path_of_string "CI.cptr"),
                          `Appl (`Ident (path_of_string "Ctypes.addr"), e))))
     | Out ->
       let x = fresh_var () in
@@ -300,7 +306,7 @@
     begin match pol with
     | In ->
       let pat = static_con "Union" [`Underscore] in
-      (pat, Some (`Appl (`Ident (path_of_string "CI.raw_ptr"),
+      (pat, Some (`Appl (`Ident (path_of_string "CI.cptr"),
                          `Appl (`Ident (path_of_string "Ctypes.addr"), e))))
     | Out ->
       let x = fresh_var () in
@@ -397,7 +403,7 @@
 let constructor_decl : type a. string -> a fn -> Format.formatter -> unit =
   fun name fn fmt ->
     Format.fprintf fmt "@[|@ %s@ : (@[%a@])@ name@]@\n" name
-      Emit_ML.ml_external_type (ml_external_type_of_fn fn)
+      Emit_ML.ml_external_type (ml_external_type_of_fn fn In)
 
 let inverse_case ~register_name ~constructor name fmt fn : unit =
   let p, e = match wrapper fn "f" Out with
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_internals.ml ./src/cstubs/cstubs_internals.ml
--- ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_internals.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/cstubs/cstubs_internals.ml	2014-10-06 15:23:14.000000000 +0000
@@ -8,21 +8,19 @@
 (* Types and functions used by generated ML code.  This is an internal
    interface and subject to change. *)
 
-type voidp = Ctypes_raw.voidp
+type voidp = Ctypes_ptr.voidp
 type managed_buffer = Memory_stubs.managed_buffer
+type 'a fatptr = 'a Ctypes.typ Ctypes_ptr.Fat.t
 
-let make_structured reftype buf =
+let make_structured reftyp buf =
   let open Static in
-  let pmanaged = Some (Obj.repr buf) in
+  let managed = Obj.repr buf in
   let raw_ptr = Memory_stubs.block_address buf in
-  let pbyte_offset = 0 in
-  { structured = CPointer { reftype; pmanaged; pbyte_offset; raw_ptr; } }
+  { structured = CPointer (Ctypes_ptr.Fat.make ~managed ~reftyp raw_ptr) }
 
 include Static
 include Primitives
 
-let make_ptr reftype raw_ptr =
-  CPointer { reftype; raw_ptr; pmanaged = None; pbyte_offset = 0; }
+let make_ptr reftyp raw_ptr = CPointer (Ctypes_ptr.Fat.make ~reftyp raw_ptr)
 
-let raw_ptr (CPointer { raw_ptr; pbyte_offset }) =
-  Ctypes_raw.PtrType.(add raw_ptr (of_int pbyte_offset))
+let cptr (CPointer p) = p
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_internals.mli ./src/cstubs/cstubs_internals.mli
--- ../ocaml-ctypes-0.3.3.orig/src/cstubs/cstubs_internals.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/cstubs/cstubs_internals.mli	2014-10-06 15:23:14.000000000 +0000
@@ -12,15 +12,16 @@
 open Signed
 open Unsigned
 
-type voidp = Ctypes_raw.voidp
+type voidp = Ctypes_ptr.voidp
 type managed_buffer = Memory_stubs.managed_buffer
+type 'a fatptr = 'a typ Ctypes_ptr.Fat.t
 
 val make_structured :
   ('a, 's) structured typ -> managed_buffer -> ('a, 's) structured
 
 val make_ptr : 'a typ -> voidp -> 'a ptr
 
-val raw_ptr : 'a ptr -> voidp
+val cptr : 'a ptr -> 'a typ Ctypes_ptr.Fat.t
 
 type 'a ocaml_type = 'a Static.ocaml_type =
   String     : string ocaml_type
@@ -38,13 +39,8 @@
   | Array           : 'a typ * int              -> 'a Static.carray typ
   | Bigarray        : (_, 'a) Ctypes_bigarray.t -> 'a typ
   | OCaml           : 'a ocaml_type             -> 'a ocaml typ
-and 'a cptr = 'a Static.cptr
-  = { reftype      : 'a typ;
-      raw_ptr      : voidp;
-      pmanaged     : Obj.t option;
-      pbyte_offset : int; }
 and ('a, 'b) pointer = ('a, 'b) Static.pointer =
-  CPointer : 'a cptr -> ('a, [`C]) pointer
+  CPointer : 'a typ Ctypes_ptr.Fat.t -> ('a, [`C]) pointer
 | OCamlRef : int * 'a * 'a ocaml_type -> ('a, [`OCaml]) pointer
 and 'a ptr = ('a, [`C]) pointer
 and 'a ocaml = ('a, [`OCaml]) pointer
@@ -52,6 +48,7 @@
   read : 'b -> 'a;
   write : 'a -> 'b;
   format_typ: ((Format.formatter -> unit) -> Format.formatter -> unit) option;
+  format: (Format.formatter -> 'a -> unit) option;
   ty: 'b typ;
 }
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/bigarray_stubs.ml ./src/ctypes/bigarray_stubs.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/bigarray_stubs.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/bigarray_stubs.ml	2014-10-06 15:23:14.000000000 +0000
@@ -25,27 +25,26 @@
      starting from zero, so we can directly transform its values to a variant
      with appropriately-ordered constructors.
 
-     Unfortunately, Bigarray.char and Bigarray.int8_unsigned are currently
+     In OCaml <= 4.01.0, Bigarray.char and Bigarray.int8_unsigned are
      indistinguishable, so the 'kind' function will never return Kind_char.
-     Mantis bug 6064 has a patch that gives char and int8_unsigned distinct
-     representations. *)
+     OCaml 4.02.0 gives the types distinct representations. *)
   = "%identity"
 
-external address : 'b -> Ctypes_raw.voidp
+external address : 'b -> Ctypes_ptr.voidp
   = "ctypes_bigarray_address"
 
-external view : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t
   = "ctypes_bigarray_view"
 
-external view1 : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view1 : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Array1.t
   = "ctypes_bigarray_view"
 
-external view2 : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view2 : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Array2.t
   = "ctypes_bigarray_view"
 
-external view3 : 'a kind -> dims:int array -> Ctypes_raw.voidp -> offset:int ->
+external view3 : 'a kind -> dims:int array -> _ Ctypes_ptr.Fat.t ->
   ('a, 'b, Bigarray.c_layout) Bigarray.Array3.t
   = "ctypes_bigarray_view"
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/coerce.ml ./src/ctypes/coerce.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/coerce.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/coerce.ml	2014-10-06 15:23:14.000000000 +0000
@@ -62,10 +62,11 @@
       try
         begin match coercion a b with
         | Id -> Id
-        | Coercion _ -> Coercion (fun (CPointer p) -> CPointer { p with reftype = b })
+        | Coercion _ ->
+          Coercion (fun (CPointer p) -> CPointer (Ctypes_ptr.Fat.coerce p b))
         end
       with Uncoercible ->
-        Coercion (fun (CPointer p) -> CPointer { p with reftype = b })
+        Coercion (fun (CPointer p) -> CPointer (Ctypes_ptr.Fat.coerce p b))
     end
   | _ -> raise Uncoercible
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes.mli ./src/ctypes/ctypes.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/ctypes.mli	2014-10-06 15:23:14.000000000 +0000
@@ -351,6 +351,7 @@
 (** {3 View types} *)
 
 val view : ?format_typ:((Format.formatter -> unit) -> Format.formatter -> unit) ->
+           ?format:(Format.formatter -> 'b -> unit) ->
            read:('a -> 'b) -> write:('b -> 'a) -> 'a typ -> 'b typ
 (** [view ~read:r ~write:w t] creates a C type representation [t'] which
     behaves like [t] except that values read using [t'] are subsequently
@@ -370,6 +371,11 @@
     {!string_of_typ} functions to print the type at the top level and
     elsewhere.  If [format_typ] is not supplied the printer for [t] is used
     instead.
+
+    The optional argument [format] is used by the {!Ctypes.format}
+    and {!string_of} functions to print the values. If [format_val]
+    is not supplied the printer for [t] is used instead.
+
 *)
 
 (** {3 Abstract types} *)
@@ -477,11 +483,16 @@
 val reference_type : 'a ptr -> 'a typ
 (** Retrieve the reference type of a pointer. *)
 
-val ptr_of_raw_address : int64 -> unit ptr
+val ptr_of_raw_address : nativeint -> unit ptr
 (** Convert the numeric representation of an address to a pointer *)
 
-val raw_address_of_ptr : unit ptr -> int64
-(** Return the numeric representation of an address *)
+val raw_address_of_ptr : unit ptr -> nativeint
+(** [raw_address_of_ptr p] returns the numeric representation of p.
+
+    Note that the return value remains valid only as long as the pointed-to
+    object is alive.  If [p] is a managed object (e.g. a value returned by
+    {!make}) then unless the caller retains a reference to [p], the object may
+    be collected, invalidating the returned address. *)
 
 val string_from_ptr : char ptr -> length:int -> string
 (** [string_from_ptr p ~length] creates a string initialized with the [length]
@@ -634,6 +645,9 @@
 val field_type : ('a, _) field -> 'a typ
 (** [field_type f] returns the type of the field [f]. *)
 
+val field_name : (_, _) field -> string
+(** [field_name f] returns the name of the field [f]. *)
+
 val addr : ((_, _) structured as 's) -> 's ptr
 (** [addr s] returns the address of the structure or union [s]. *)
 
@@ -704,4 +718,3 @@
 
 exception Uncoercible
 (** An attempt was made to coerce between uncoercible types.  *)
-
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_bigarray.ml ./src/ctypes/ctypes_bigarray.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_bigarray.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/ctypes_bigarray.ml	2014-10-06 15:23:14.000000000 +0000
@@ -134,15 +134,15 @@
 
 let prim_of_kind k = prim_of_kind (kind k)
 
-let address _ b = Bigarray_stubs.address b
+let unsafe_address b = Bigarray_stubs.address b
 
-let view : type a b. (a, b) t -> ?ref:Obj.t -> Ctypes_raw.voidp -> offset:int -> b =
+let view : type a b. (a, b) t -> _ Ctypes_ptr.Fat.t -> b =
   let open Bigarray_stubs in
-  fun (dims, kind) ?ref ptr ~offset -> let ba : b = match dims with
-  | DimsGen ds -> view kind ds ptr offset
-  | Dims1 d -> view1 kind [| d |] ptr offset
-  | Dims2 (d1, d2) -> view2 kind [| d1; d2 |] ptr offset
-  | Dims3 (d1, d2, d3) -> view3 kind [| d1; d2; d3 |] ptr offset in
-  match ref with
+  fun (dims, kind) ptr -> let ba : b = match dims with
+  | DimsGen ds -> view kind ds ptr
+  | Dims1 d -> view1 kind [| d |] ptr
+  | Dims2 (d1, d2) -> view2 kind [| d1; d2 |] ptr
+  | Dims3 (d1, d2, d3) -> view3 kind [| d1; d2; d3 |] ptr in
+  match Ctypes_ptr.Fat.managed ptr with
   | None -> ba
   | Some src -> Gc.finalise (fun _ -> ignore src; ()) ba; ba
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_bigarray.mli ./src/ctypes/ctypes_bigarray.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_bigarray.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/ctypes_bigarray.mli	2014-10-06 15:23:14.000000000 +0000
@@ -30,7 +30,7 @@
 (** Create a {!t} value for the {!Bigarray.Array3.t} type. *)
 
 val prim_of_kind : ('a, _) Bigarray.kind -> 'a Primitives.prim
-(** Create a {!Ctypes_raw.Types.ctype} for a {!Bigarray.kind}. *)
+(** Create a {!Ctypes_ptr.Types.ctype} for a {!Bigarray.kind}. *)
 
 (** {3 Type eliminators *)
 
@@ -52,12 +52,16 @@
 
 (** {2 Values *)
 
-val address : (_, 'a) t -> 'a -> Ctypes_raw.voidp
-(** Return the address of a bigarray value. *)
-
-val view : (_, 'a) t -> ?ref:Obj.t -> Ctypes_raw.voidp -> offset:int -> 'a
-(** Create a bigarray view onto existing memory.
-
-    The optional [ref] argument is an OCaml object that controls the lifetime
-    of the memory; if [ref] is present, [view] will ensure that it is not
-    collected before the bigarray returned by [view]. *)
+val unsafe_address : 'a -> Ctypes_ptr.voidp
+(** Return the address of a bigarray value.  This function is unsafe because
+    it dissociates the raw address of the C array from the OCaml object that
+    manages the lifetime of the array.  If the caller does not hold a
+    reference to the OCaml object then the array might be freed, invalidating
+    the address. *)
+
+val view : (_, 'a) t -> _ Ctypes_ptr.Fat.t -> 'a
+(** [view b ptr] creates a bigarray view onto existing memory.
+
+    If [ptr] references an OCaml object then [view] will ensure that
+    that object is not collected before the bigarray returned by
+    [view]. *)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_bigarray_stubs.c ./src/ctypes/ctypes_bigarray_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_bigarray_stubs.c	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/ctypes_bigarray_stubs.c	2014-10-06 15:23:14.000000000 +0000
@@ -16,19 +16,18 @@
   return CTYPES_FROM_PTR(Caml_ba_data_val(ba));
 }
 
-/* _view : ('a, 'b) kind -> dims:int array -> ptr -> offset:int ->
+/* _view : ('a, 'b) kind -> dims:int array -> fatptr ->
            ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t */
-value ctypes_bigarray_view(value kind_, value dims_, value ptr_, value offset_)
+value ctypes_bigarray_view(value kind_, value dims_, value ptr_)
 {
   int kind = Int_val(kind_);
   int ndims = Wosize_val(dims_);
-  int offset = Int_val(offset_);
   intnat dims[CAML_BA_MAX_NUM_DIMS];
   int i;
   for (i = 0; i < ndims; i++) {
     dims[i] = Int_val(Field(dims_, i));
   }
   int flags = kind | CAML_BA_C_LAYOUT | CAML_BA_EXTERNAL;
-  void *data = offset + (char *)CTYPES_TO_PTR(ptr_);
+  void *data = CTYPES_ADDR_OF_FATPTR(ptr_);
   return caml_ba_alloc(flags, ndims, data, dims);
 }
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_primitives.ml ./src/ctypes/ctypes_primitives.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_primitives.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./src/ctypes/ctypes_primitives.ml	2014-10-07 17:44:27.000000000 +0000
@@ -0,0 +1,84 @@
+open Primitives
+let sizeof : type a. a prim -> int = function
+ | Char -> 1
+ | Schar -> 1
+ | Uchar -> 1
+ | Short -> 2
+ | Int -> 4
+ | Long -> 8
+ | Llong -> 8
+ | Ushort -> 2
+ | Uint -> 4
+ | Ulong -> 8
+ | Ullong -> 8
+ | Size_t -> 8
+ | Int8_t -> 1
+ | Int16_t -> 2
+ | Int32_t -> 4
+ | Int64_t -> 8
+ | Uint8_t -> 1
+ | Uint16_t -> 2
+ | Uint32_t -> 4
+ | Uint64_t -> 8
+ | Camlint -> 8
+ | Nativeint -> 8
+ | Float -> 4
+ | Double -> 8
+ | Complex32 -> 8
+ | Complex64 -> 16
+let alignment : type a. a prim -> int = function
+ | Char -> 1
+ | Schar -> 1
+ | Uchar -> 1
+ | Short -> 2
+ | Int -> 4
+ | Long -> 8
+ | Llong -> 8
+ | Ushort -> 2
+ | Uint -> 4
+ | Ulong -> 8
+ | Ullong -> 8
+ | Size_t -> 8
+ | Int8_t -> 1
+ | Int16_t -> 2
+ | Int32_t -> 4
+ | Int64_t -> 8
+ | Uint8_t -> 1
+ | Uint16_t -> 2
+ | Uint32_t -> 4
+ | Uint64_t -> 8
+ | Camlint -> 8
+ | Nativeint -> 8
+ | Float -> 4
+ | Double -> 8
+ | Complex32 -> 4
+ | Complex64 -> 8
+let name : type a. a prim -> string = function
+ | Char -> "char"
+ | Schar -> "signed char"
+ | Uchar -> "unsigned char"
+ | Short -> "short"
+ | Int -> "int"
+ | Long -> "long"
+ | Llong -> "long long"
+ | Ushort -> "unsigned short"
+ | Uint -> "unsigned int"
+ | Ulong -> "unsigned long"
+ | Ullong -> "unsigned long long"
+ | Size_t -> "size_t"
+ | Int8_t -> "int8_t"
+ | Int16_t -> "int16_t"
+ | Int32_t -> "int32_t"
+ | Int64_t -> "int64_t"
+ | Uint8_t -> "uint8_t"
+ | Uint16_t -> "uint16_t"
+ | Uint32_t -> "uint32_t"
+ | Uint64_t -> "uint64_t"
+ | Camlint -> "camlint"
+ | Nativeint -> "intnat"
+ | Float -> "float"
+ | Double -> "double"
+ | Complex32 -> "float _Complex"
+ | Complex64 -> "double _Complex"
+let pointer_size = 8
+let pointer_alignment = 8
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_ptr.ml ./src/ctypes/ctypes_ptr.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_ptr.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./src/ctypes/ctypes_ptr.ml	2014-10-06 15:23:14.000000000 +0000
@@ -0,0 +1,94 @@
+(*
+ * Copyright (c) 2013 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* Boxed pointers to C memory locations . *)
+
+module Raw :
+sig
+  include Signed.S
+  val null : t
+end =
+struct
+  include Nativeint
+
+  module Infix =
+  struct
+    let (+) = add
+    let (-) = sub
+    let ( * ) = mul
+    let (/) = div
+    let (mod) = rem
+    let (land) = logand
+    let (lor) = logor
+    let (lxor) = logxor
+    let (lsl) = shift_left
+    let (lsr) = shift_right_logical
+  end
+
+  let of_nativeint x = x
+  let to_nativeint x = x
+
+  let null = zero
+end
+
+type voidp = Raw.t
+
+module Fat :
+sig
+  (** A fat pointer, which holds a reference to the reference type, the C memory
+      location, and an OCaml object. *)
+  type _ t
+
+  (** [make ?managed ~reftyp raw] builds a fat pointer from the reference
+      type [reftyp], the C memory location [raw], and (optionally) an OCaml
+      value, [managed].  The [managed] argument may be used to manage the
+      lifetime of the C object; a typical use it to attach a finaliser to
+      [managed] which releases the memory associated with the C object whose
+      address is stored in [raw_ptr]. *)
+  val make : ?managed:_ -> reftyp:'typ -> voidp -> 'typ t
+
+  val reftype : 'typ t -> 'typ
+
+  val managed : _ t -> Obj.t option
+
+  val coerce : _ t -> 'typ -> 'typ t
+
+  (** Return the raw pointer address.  The function is unsafe in the sense
+      that it dissociates the address from the value which manages the memory,
+      which may trigger associated finalisers, invalidating the address. *)
+  val unsafe_raw_addr : _ t -> voidp
+
+  val add_bytes : 'typ t -> int -> 'typ t
+
+  val compare : 'typ t -> 'typ t -> int
+
+  val diff_bytes : 'typ t -> 'typ t -> int
+end =
+struct
+  type 'typ t =
+    { reftyp  : 'typ;
+      raw     : voidp;
+      managed : Obj.t option; }
+
+  let make ?managed ~reftyp raw = match managed with
+    | None   -> { reftyp; raw; managed = None }
+    | Some v -> { reftyp; raw; managed = Some (Obj.repr v) }
+
+  let reftype { reftyp } = reftyp
+
+  let managed { managed } = managed
+
+  let coerce p reftyp = { p with reftyp }
+    
+  let unsafe_raw_addr { raw } = raw
+
+  let add_bytes p bytes = { p with raw = Raw.(add p.raw (of_int bytes)) }
+
+  let compare l r = Raw.compare l.raw r.raw
+
+  let diff_bytes l r = Raw.(to_int (sub r.raw l.raw))
+end
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_raw.ml ./src/ctypes/ctypes_raw.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/ctypes_raw.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/ctypes_raw.ml	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-(*
- * Copyright (c) 2013 Jeremy Yallop.
- *
- * This file is distributed under the terms of the MIT License.
- * See the file LICENSE for details.
- *)
-
-(* Boxed pointers to C memory locations . *)
-
-module PtrType = (val match Ctypes_primitives.pointer_size with
-  4 -> (module Signed.Int32 : Signed.S)
-| 8 -> (module Signed.Int64 : Signed.S)
-| _ -> failwith "No suitable type available to represent pointers.")
-
-type voidp = PtrType.t
-
-let null = PtrType.zero
-
-
-
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/managed_buffer_stubs.c ./src/ctypes/managed_buffer_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/managed_buffer_stubs.c	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/managed_buffer_stubs.c	2014-10-06 15:23:14.000000000 +0000
@@ -28,10 +28,10 @@
   return (l > r) - (l < r);
 }
 
-static long hash_address(value l)
+static intnat hash_address(value l)
 {
   /* address hashing */
-  return (long)*(void **)Data_custom_val(l);
+  return (intnat)*(void **)Data_custom_val(l);
 }
 
 static struct custom_operations managed_buffer_custom_ops = {
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/managed_buffer_stubs.h ./src/ctypes/managed_buffer_stubs.h
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/managed_buffer_stubs.h	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/managed_buffer_stubs.h	2014-10-06 15:23:14.000000000 +0000
@@ -19,4 +19,7 @@
 /* block_address : managed_buffer -> immediate_pointer */
 extern value ctypes_block_address(value managed_buffer);
 
+/* CTYPES_FROM_FAT_PTR : _ Ctypes_ptr.Fat.t -> void * */
+
+
 #endif /* MANAGED_BUFFER_STUBS_H */
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/memory.ml ./src/ctypes/memory.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/memory.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/memory.ml	2014-10-06 15:23:14.000000000 +0000
@@ -8,36 +8,31 @@
 open Static
 
 module Stubs = Memory_stubs
-module Raw = Ctypes_raw
+module Raw = Ctypes_ptr.Raw
+module Fat = Ctypes_ptr.Fat
+
+let castp reftype (CPointer p) = CPointer (Fat.coerce p reftype)
 
 (* Describes how to read a value, e.g. from a return buffer *)
-let rec build : type a. a typ -> offset:int -> Raw.voidp -> a
+let rec build : type a b. a typ -> b typ Fat.t -> a
  = function
     | Void ->
-      fun ~offset _ -> ()
+      fun _ -> ()
     | Primitive p -> Stubs.read p
     | Struct { spec = Incomplete _ } ->
       raise IncompleteType
-    | Struct { spec = Complete { size } } as reftype ->
-      (fun ~offset buf ->
-        let m = Stubs.allocate size in
-        let raw_ptr = Stubs.block_address m in
-        let () = Stubs.memcpy ~size
-          ~dst:raw_ptr ~dst_offset:0
-          ~src:buf ~src_offset:offset in
-        { structured =
-            CPointer { pmanaged = Some (Obj.repr m); reftype; raw_ptr; pbyte_offset = 0; } })
-    | Pointer reftype ->
-      (fun ~offset buf ->
-        CPointer {
-          raw_ptr = Stubs.Pointer.read ~offset buf;
-          pbyte_offset = 0;
-          reftype;
-          pmanaged = None; })
+    | Struct { spec = Complete { size } } as reftyp ->
+      (fun buf ->
+        let managed = Stubs.allocate size in
+        let dst = Fat.make ~managed ~reftyp (Stubs.block_address managed) in
+        let () = Stubs.memcpy ~size ~dst ~src:buf in
+        { structured = CPointer dst})
+    | Pointer reftyp ->
+      (fun buf -> CPointer (Fat.make ~reftyp (Stubs.Pointer.read buf)))
     | View { read; ty } ->
       let buildty = build ty in
-      (fun ~offset buf -> read (buildty ~offset buf))
-    | OCaml _ -> (fun ~offset buf -> assert false)
+      (fun buf -> read (buildty buf))
+    | OCaml _ -> (fun buf -> assert false)
     (* The following cases should never happen; non-struct aggregate
        types are excluded during type construction. *)
     | Union _ -> assert false
@@ -45,17 +40,15 @@
     | Bigarray _ -> assert false
     | Abstract _ -> assert false
 
-let rec write : type a. a typ -> offset:int -> a -> Raw.voidp -> unit
-  = let write_aggregate size =
-      (fun ~offset { structured = CPointer { raw_ptr; pbyte_offset = src_offset } } dst ->
-        Stubs.memcpy ~size ~dst ~dst_offset:offset ~src:raw_ptr ~src_offset) in
+let rec write : type a b. a typ -> a -> b Fat.t -> unit
+  = let write_aggregate size { structured = CPointer src } dst =
+      Stubs.memcpy ~size ~dst ~src
+    in
     function
-    | Void -> (fun ~offset _ _ -> ())
+    | Void -> (fun _ _ -> ())
     | Primitive p -> Stubs.write p
     | Pointer _ ->
-      (fun ~offset (CPointer { raw_ptr; pbyte_offset }) dst ->
-        Stubs.Pointer.write ~offset
-          (Raw.PtrType.(add raw_ptr (of_int pbyte_offset))) dst)
+      (fun (CPointer p) dst -> Stubs.Pointer.write p dst)
     | Struct { spec = Incomplete _ } -> raise IncompleteType
     | Struct { spec = Complete _ } as s -> write_aggregate (sizeof s)
     | Union { uspec = None } -> raise IncompleteType
@@ -63,53 +56,47 @@
     | Abstract { asize } -> write_aggregate asize
     | Array _ as a ->
       let size = sizeof a in
-      (fun ~offset { astart = CPointer { raw_ptr; pbyte_offset = src_offset } } dst ->
-        Stubs.memcpy ~size ~dst ~dst_offset:offset ~src:raw_ptr ~src_offset)
+      (fun { astart = CPointer src } dst ->
+        Stubs.memcpy ~size ~dst ~src)
     | Bigarray b as t ->
       let size = sizeof t in
-      (fun ~offset ba dst ->
-        let src = Ctypes_bigarray.address b ba in
-        Stubs.memcpy ~size ~dst ~dst_offset:offset ~src ~src_offset:0)
+      (fun ba dst ->
+        let src = Fat.make ~managed:ba ~reftyp:Void
+          (Ctypes_bigarray.unsafe_address ba)
+        in
+        Stubs.memcpy ~size ~dst ~src)
     | View { write = w; ty } ->
       let writety = write ty in
-      (fun ~offset v -> writety ~offset (w v))
+      (fun v -> writety (w v))
     | OCaml _ -> raise IncompleteType
 
-let null : unit ptr = CPointer {
-                        raw_ptr = Raw.null;
-                        reftype = Void;
-                        pbyte_offset = 0;
-                        pmanaged = None; }
+let null : unit ptr = CPointer (Fat.make Void Raw.null)
 
 let rec (!@) : type a. a ptr -> a
-  = fun (CPointer ({ raw_ptr; reftype; pbyte_offset = offset; pmanaged = ref } as cptr) as ptr) ->
-    match reftype with
+  = fun (CPointer cptr as ptr) ->
+    match Fat.reftype cptr with
       | Void -> raise IncompleteType
       | Union { uspec = None } -> raise IncompleteType
       | Struct { spec = Incomplete _ } -> raise IncompleteType
-      | View { read; ty = reftype } -> read (!@ (CPointer { cptr with reftype }))
+      | View { read; ty } -> read (!@ (CPointer (Fat.coerce cptr ty)))
       (* If it's a reference type then we take a reference *)
       | Union _ -> { structured = ptr }
       | Struct _ -> { structured = ptr }
       | Array (elemtype, alength) ->
-        { astart = CPointer { cptr with reftype = elemtype }; alength }
-      | Bigarray b -> Ctypes_bigarray.view b ?ref ~offset raw_ptr
+        { astart = CPointer (Fat.coerce cptr elemtype); alength }
+      | Bigarray b -> Ctypes_bigarray.view b cptr
       | Abstract _ -> { structured = ptr }
       | OCaml _ -> raise IncompleteType
       (* If it's a value type then we cons a new value. *)
-      | _ -> build reftype ~offset raw_ptr
+      | _ -> build (Fat.reftype cptr) cptr
 
 let ptr_diff : type a b. (a, b) pointer -> (a, b) pointer -> int
   = fun l r ->
     match l, r with
-    | CPointer { raw_ptr = lp; pbyte_offset = loff; reftype },
-      CPointer { raw_ptr = rp; pbyte_offset = roff } ->
+    | CPointer lp, CPointer rp ->
       (* We assume the pointers are properly aligned, or at least that
          the difference is a multiple of sizeof reftype. *)
-      let open Raw.PtrType in
-        let l = add lp (of_int loff)
-        and r = add rp (of_int roff) in
-        to_int (sub r l) / sizeof reftype
+      Fat.diff_bytes lp rp / sizeof (Fat.reftype lp)
     | OCamlRef (lo, l, _), OCamlRef (ro, r, _) ->
       if l != r then invalid_arg "Ctypes.ptr_diff";
       ro - lo
@@ -117,33 +104,30 @@
 let (+@) : type a b. (a, b) pointer -> int -> (a, b) pointer
   = fun p x ->
     match p with
-    | CPointer ({ pbyte_offset; reftype } as p) ->
-      CPointer { p with pbyte_offset = pbyte_offset + (x * sizeof reftype) }
+    | CPointer p ->
+      CPointer (Fat.add_bytes p (x * sizeof (Fat.reftype p)))
     | OCamlRef (offset, obj, ty) ->
       OCamlRef (offset + x, obj, ty)
 
 let (-@) p x = p +@ (-x)
 
 let (<-@) : type a. a ptr -> a -> unit
-  = fun (CPointer { reftype; raw_ptr; pbyte_offset = offset }) ->
-    fun v -> write reftype ~offset v raw_ptr
-
-let from_voidp : type a. a typ -> unit ptr -> a ptr
-  = fun reftype (CPointer p) -> CPointer { p with reftype }
+  = fun (CPointer p) ->
+    fun v -> write (Fat.reftype p) v p
 
-let to_voidp : type a. a ptr -> unit ptr
-  = fun (CPointer p) -> CPointer { p with reftype = Void }
+let from_voidp = castp
+let to_voidp p = castp Void p
 
 let allocate_n : type a. ?finalise:(a ptr -> unit) -> a typ -> count:int -> a ptr
-  = fun ?finalise reftype ~count ->
+  = fun ?finalise reftyp ~count ->
     let package p =
-      CPointer { reftype; pbyte_offset = 0; raw_ptr = Stubs.block_address p;
-                 pmanaged = Some (Obj.repr p); } in
+      CPointer (Fat.make ~managed:p ~reftyp (Stubs.block_address p))
+    in
     let finalise = match finalise with
       | Some f -> Gc.finalise (fun p -> f (package p))
       | None -> ignore
     in
-    let p = Stubs.allocate (count * sizeof reftype) in begin
+    let p = Stubs.allocate (count * sizeof reftyp) in begin
       finalise p;
       package p
     end
@@ -155,19 +139,19 @@
       p
     end
 
-let ptr_compare (CPointer {raw_ptr = lp; pbyte_offset = loff})
-                (CPointer {raw_ptr = rp; pbyte_offset = roff})
-    = Raw.PtrType.(compare (add lp (of_int loff)) (add rp (of_int roff)))
+let ptr_compare (CPointer l) (CPointer r) = Fat.(compare l r)
 
-let reference_type (CPointer { reftype }) = reftype
+let reference_type (CPointer p) = Fat.reftype p
 
 let ptr_of_raw_address addr =
-  CPointer {
-    reftype = Void; raw_ptr = Raw.PtrType.of_int64 addr;
-    pmanaged = None; pbyte_offset = 0; }
+  CPointer (Fat.make ~reftyp:Void (Raw.of_nativeint addr))
 
-let raw_address_of_ptr (CPointer { raw_ptr; pbyte_offset }) =
-  Int64.(add (Raw.PtrType.to_int64 raw_ptr) (of_int pbyte_offset))
+let raw_address_of_ptr (CPointer p) =
+  (* This is unsafe by definition: if the object to which [p] refers
+     is collected at this point then the returned address is invalid.
+     If there is an OCaml object associated with [p] then it is vital
+     that the caller retains a reference to it. *)
+  Raw.to_nativeint (Fat.unsafe_raw_addr p)
 
 module CArray =
 struct
@@ -227,8 +211,9 @@
     | Some f -> Some (fun structured -> f { structured })
     | None -> None in
   { structured = allocate_n ?finalise s ~count:1 }
-let (|->) (CPointer p) { ftype = reftype; foffset } =
-  CPointer { p with reftype; pbyte_offset = p.pbyte_offset + foffset }
+let (|->) (CPointer p) { ftype; foffset } =
+  CPointer (Fat.(add_bytes (Fat.coerce p ftype) foffset))
+
 let (@.) { structured = p } f = p |-> f
 let setf s field v = (s @. field) <-@ v
 let getf s field = !@(s @. field)
@@ -237,40 +222,24 @@
 
 open Bigarray
 
-let _bigarray_start kind typ ba =
-  let raw_address = Ctypes_bigarray.address typ ba in
-  let reftype = Primitive (Ctypes_bigarray.prim_of_kind kind) in
-  CPointer {
-    reftype      = reftype ;
-    raw_ptr      = raw_address ;
-    pmanaged     = Some (Obj.repr ba) ;
-    pbyte_offset = 0; }
+let _bigarray_start kind ba =
+  let raw_address = Ctypes_bigarray.unsafe_address ba in
+  let reftyp = Primitive (Ctypes_bigarray.prim_of_kind kind) in
+  CPointer (Fat.make ~managed:ba ~reftyp raw_address)
 
-let bigarray_start : type a b c d f.
+let bigarray_kind : type a b c d f.
   < element: a;
     ba_repr: f;
     bigarray: b;
     carray: c;
-    dims: d > bigarray_class -> b -> a ptr
-  = fun spec ba -> match spec with
-  | Genarray ->
-    let kind = Genarray.kind ba in
-    let dims = Genarray.dims ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray dims kind) ba
-  | Array1 ->
-    let kind = Array1.kind ba in
-    let d = Array1.dim ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray1 d kind) ba
-  | Array2 ->
-    let kind = Array2.kind ba in
-    let d1 = Array2.dim1 ba and d2 = Array2.dim2 ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray2 d1 d2 kind) ba
-  | Array3 ->
-    let kind = Array3.kind ba in
-    let d1 = Array3.dim1 ba and d2 = Array3.dim2 ba and d3 = Array3.dim3 ba in
-    _bigarray_start kind (Ctypes_bigarray.bigarray3 d1 d2 d3 kind) ba
+    dims: d > bigarray_class -> b -> (a, f) Bigarray.kind =
+  function
+  | Genarray -> Genarray.kind
+  | Array1 -> Array1.kind
+  | Array2 -> Array2.kind
+  | Array3 -> Array3.kind
 
-let castp reftype (CPointer p) = CPointer { p with reftype }
+let bigarray_start spec ba = _bigarray_start (bigarray_kind spec ba) ba
 
 let array_of_bigarray : type a b c d e.
   < element: a;
@@ -279,7 +248,8 @@
     carray: c;
     dims: d > bigarray_class -> b -> c
   = fun spec ba ->
-    let CPointer { reftype } as element_ptr = bigarray_start spec ba in
+    let CPointer p as element_ptr =
+      bigarray_start spec ba in
     match spec with
   | Genarray ->
     let ds = Genarray.dims ba in
@@ -289,10 +259,10 @@
     CArray.from_ptr element_ptr d
   | Array2 ->
     let d1 = Array2.dim1 ba and d2 = Array2.dim2 ba in
-    CArray.from_ptr (castp (array d2 reftype) element_ptr) d1
+    CArray.from_ptr (castp (array d2 (Fat.reftype p)) element_ptr) d1
   | Array3 ->
     let d1 = Array3.dim1 ba and d2 = Array3.dim2 ba and d3 = Array3.dim3 ba in
-    CArray.from_ptr (castp (array d2 (array d3 reftype)) element_ptr) d1
+    CArray.from_ptr (castp (array d2 (array d3 (Fat.reftype p))) element_ptr) d1
 
 let bigarray_elements : type a b c d f.
    < element: a;
@@ -315,18 +285,27 @@
      bigarray: b;
      carray: c carray;
      dims: d > bigarray_class -> c carray -> d =
+   let unsupported () = raise (Unsupported "taking dimensions of non-array type") in
    fun spec a -> match spec with
    | Genarray -> [| a.alength |]
    | Array1 -> a.alength
    | Array2 ->
      begin match a.astart with
-     | CPointer {reftype = Array (_, n)} -> (a.alength, n)
-     | _ -> raise (Unsupported "taking dimensions of non-array type")
+     | CPointer p ->
+       begin match Fat.reftype p with
+       | Array (_, n) -> (a.alength, n)
+       | _ -> unsupported ()
+       end
+     | _ -> unsupported ()
     end
    | Array3 ->
      begin match a.astart with
-     | CPointer {reftype = Array (Array (_, m), n)} -> (a.alength, n, m)
-     | _ -> raise (Unsupported "taking dimensions of non-array type")
+     | CPointer p ->
+       begin match Fat.reftype p with
+       |  Array (Array (_, m), n) -> (a.alength, n, m)
+       | _ -> unsupported ()
+       end
+     | _ -> unsupported ()
      end
 
 let bigarray_of_array spec kind a =
@@ -339,9 +318,9 @@
 let array3 = Array3
 let typ_of_bigarray_kind k = Primitive (Ctypes_bigarray.prim_of_kind k)
 
-let string_from_ptr (CPointer { raw_ptr; pbyte_offset = offset }) ~length:len =
+let string_from_ptr (CPointer p) ~length:len =
   if len < 0 then invalid_arg "Ctypes.string_from_ptr"
-  else Stubs.string_of_array raw_ptr ~offset ~len
+  else Stubs.string_of_array p ~len
 
 let ocaml_string_start str =
   OCamlRef (0, str, String)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/memory_stubs.ml ./src/ctypes/memory_stubs.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/memory_stubs.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/memory_stubs.ml	2014-10-06 15:23:14.000000000 +0000
@@ -7,6 +7,8 @@
 
 (* Stubs for reading and writing memory. *)
 
+open Ctypes_ptr
+
 (* A reference, managed by the garbage collector, to a region of memory in the
    C heap. *)
 type managed_buffer
@@ -16,33 +18,30 @@
   = "ctypes_allocate"
 
 (* Obtain the address of the managed block. *)
-external block_address : managed_buffer -> Ctypes_raw.voidp
+external block_address : managed_buffer -> voidp
   = "ctypes_block_address"
 
 (* Read a C value from a block of memory *)
-external read : 'a Primitives.prim -> offset:int -> Ctypes_raw.voidp -> 'a
+external read : 'a Primitives.prim -> _ Fat.t -> 'a
   = "ctypes_read"
 
 (* Write a C value to a block of memory *)
-external write :  'a Primitives.prim -> offset:int -> 'a -> Ctypes_raw.voidp -> unit
+external write : 'a Primitives.prim -> 'a -> _ Fat.t -> unit
   = "ctypes_write"
 
 module Pointer =
 struct
-  external read : offset:int -> Ctypes_raw.voidp -> Ctypes_raw.voidp
+  external read : _ Fat.t -> voidp
     = "ctypes_read_pointer"
 
-  external write : offset:int -> Ctypes_raw.voidp -> Ctypes_raw.voidp -> unit
+  external write : _ Fat.t -> _ Fat.t -> unit
   = "ctypes_write_pointer"
 end
 
-(* Copy [size] bytes from [src + src_offset] to [dst + dst_offset]. *)
-external memcpy :
-  dst:Ctypes_raw.voidp -> dst_offset:int ->
-  src:Ctypes_raw.voidp -> src_offset:int ->
-    size:int -> unit
+(* Copy [size] bytes from [src] to [dst]. *)
+external memcpy : dst:_ Fat.t -> src:_ Fat.t -> size:int -> unit
   = "ctypes_memcpy"
 
 (* Read a fixed length OCaml string from memory *)
-external string_of_array : Ctypes_raw.voidp -> offset:int -> len:int -> string
+external string_of_array : _ Fat.t -> len:int -> string
   = "ctypes_string_of_array"
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/raw_pointer.h ./src/ctypes/raw_pointer.h
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/raw_pointer.h	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/raw_pointer.h	2014-10-06 15:23:14.000000000 +0000
@@ -12,16 +12,10 @@
 #include <caml/alloc.h>
 #include <stdint.h>
 
-#if SIZEOF_PTR == 4
-#define CTYPES_FROM_PTR(P) caml_copy_int32((intptr_t)P)
-#define CTYPES_TO_PTR(I32) ((void *)Int32_val(I32))
-#define CTYPES_PTR_PLUS(I32, I) caml_copy_int32(Int32_val(I32) + I)
-#elif SIZEOF_PTR == 8
-#define CTYPES_FROM_PTR(P) caml_copy_int64((intptr_t)P)
-#define CTYPES_TO_PTR(I64) ((void *)Int64_val(I64))
-#define CTYPES_PTR_PLUS(I64, I) caml_copy_int64(Int64_val(I64) + I)
-#else
-#error "No suitable type available to represent pointers."
-#endif
+#define CTYPES_FROM_PTR(P) caml_copy_nativeint((intptr_t)P)
+#define CTYPES_TO_PTR(I) ((void *)Nativeint_val(I))
+
+/* CTYPES_ADDR_OF_FATPTR : _ Ctypes_ptr.Fat.t -> void * */
+#define CTYPES_ADDR_OF_FATPTR(P) CTYPES_TO_PTR(Field(P, 1))
 
 #endif /* RAW_POINTER_STUBS_H */
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/raw_pointer_stubs.c ./src/ctypes/raw_pointer_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/raw_pointer_stubs.c	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/raw_pointer_stubs.c	2014-10-06 15:23:14.000000000 +0000
@@ -14,40 +14,32 @@
 #include "type_info_stubs.h"
 #include "raw_pointer.h"
 
-/* memcpy : dest:raw_pointer -> dest_offset:int ->
-            src:raw_pointer -> src_offset:int ->
-            size:int -> unit */
-value ctypes_memcpy(value dst, value dst_offset,
-                    value src, value src_offset, value size)
+/* memcpy : dst:fat_pointer -> src:fat_pointer -> size:int -> unit */
+value ctypes_memcpy(value dst, value src, value size)
 {
-  CAMLparam5(dst, dst_offset, src, src_offset, size);
-  memcpy((char *)CTYPES_TO_PTR(dst) + Int_val(dst_offset),
-         (char *)CTYPES_TO_PTR(src) + Int_val(src_offset),
-         Int_val(size));
+  CAMLparam3(dst, src, size);
+  memcpy(CTYPES_ADDR_OF_FATPTR(dst), CTYPES_ADDR_OF_FATPTR(src), Int_val(size));
   CAMLreturn(Val_unit);
 }
 
 
 /* string_of_cstring : raw_ptr -> int -> string */
-value ctypes_string_of_cstring(value p, value offset)
+value ctypes_string_of_cstring(value p)
 {
-  return caml_copy_string(((char *)CTYPES_TO_PTR(p))
-                          + Int_val(offset));
+  return caml_copy_string(CTYPES_ADDR_OF_FATPTR(p));
 }
 
 
-/* string_of_array : raw_ptr -> off:int -> len:int -> string */
-value ctypes_string_of_array(value p, value offset, value vlen)
+/* string_of_array : fat_ptr -> len:int -> string */
+value ctypes_string_of_array(value p, value vlen)
 {
-  CAMLparam3(p, offset, vlen);
+  CAMLparam2(p, vlen);
   CAMLlocal1(dst);
   int len = Int_val(vlen);
   if (len < 0)
     caml_invalid_argument("ctypes_string_of_array");
   dst = caml_alloc_string(len);
-  memcpy(String_val(dst),
-         (char *)CTYPES_TO_PTR(p) + Int_val(offset),
-         len);
+  memcpy(String_val(dst), CTYPES_ADDR_OF_FATPTR(p), len);
   CAMLreturn(dst);
 }
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/signed.ml ./src/ctypes/signed.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/signed.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/signed.ml	2014-10-06 15:23:14.000000000 +0000
@@ -13,8 +13,8 @@
   val minus_one : t
   val min_int : t
   val shift_right_logical : t -> int -> t
-  val of_int64 : int64 -> t
-  val to_int64 : t -> int64
+  val of_nativeint : nativeint -> t
+  val to_nativeint : t -> nativeint
 end
 
 module type Basics = sig
@@ -53,8 +53,8 @@
 struct
   include Int32
   module Infix = MakeInfix(Int32)
-  let of_int64 = Int64.to_int32
-  let to_int64 = Int64.of_int32
+  let of_nativeint = Nativeint.to_int32
+  let to_nativeint = Nativeint.of_int32
 end
 
 module Int64 = 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/signed.mli ./src/ctypes/signed.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/signed.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/signed.mli	2014-10-06 15:23:14.000000000 +0000
@@ -26,11 +26,11 @@
   (** {!shift_right_logical} [x] [y] shifts [x] to the right by [y] bits.  See
       {!Int32.shift_right_logical}. *)
 
-  val of_int64 : int64 -> t
-  (** Convert the given int64 value to a signed integer. *)
+  val of_nativeint : nativeint -> t
+  (** Convert the given nativeint value to a signed integer. *)
 
-  val to_int64 : t -> int64
-  (** Convert the given signed integer to an int64 value. *)
+  val to_nativeint : t -> nativeint
+  (** Convert the given signed integer to a nativeint value. *)
 end
 (** Signed integer operations *)
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/static.ml ./src/ctypes/static.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/static.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/static.ml	2014-10-06 15:23:14.000000000 +0000
@@ -44,17 +44,13 @@
   | Bigarray        : (_, 'a) Ctypes_bigarray.t
                                          -> 'a typ
   | OCaml           : 'a ocaml_type      -> 'a ocaml typ
-and 'a cptr = { reftype      : 'a typ;
-                raw_ptr      : Ctypes_raw.voidp;
-                pmanaged     : Obj.t option;
-                pbyte_offset : int; }
 and 'a carray = { astart : 'a ptr; alength : int }
 and ('a, 'kind) structured = { structured : ('a, 'kind) structured ptr }
 and 'a union = ('a, [`Union]) structured
 and 'a structure = ('a, [`Struct]) structured
 and 'a abstract = ('a, [`Abstract]) structured
 and (_, _) pointer =
-  CPointer : 'a cptr -> ('a, [`C]) pointer
+  CPointer : 'a typ Ctypes_ptr.Fat.t -> ('a, [`C]) pointer
 | OCamlRef : int * 'a * 'a ocaml_type -> ('a, [`OCaml]) pointer
 and 'a ptr = ('a, [`C]) pointer
 and 'a ocaml = ('a, [`OCaml]) pointer
@@ -62,6 +58,7 @@
   read : 'b -> 'a;
   write : 'a -> 'b;
   format_typ: ((Format.formatter -> unit) -> Format.formatter -> unit) option;
+  format: (Format.formatter -> 'a -> unit) option;
   ty: 'b typ;
 }
 and ('a, 's) field = {
@@ -199,7 +196,8 @@
     Function (f, t)
 let abstract ~name ~size ~alignment =
   Abstract { aname = name; asize = size; aalignment = alignment }
-let view ?format_typ ~read ~write ty = View { read; write; format_typ; ty }
+let view ?format_typ ?format ~read ~write ty =
+  View { read; write; format_typ; format; ty }
 let bigarray : type a b c d e.
   < element: a;
     dims: b;
@@ -227,3 +225,4 @@
 
 let offsetof { foffset } = foffset
 let field_type { ftype } = ftype
+let field_name { fname } = fname
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/static.mli ./src/ctypes/static.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/static.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/static.mli	2014-10-06 15:23:14.000000000 +0000
@@ -38,17 +38,13 @@
   | Bigarray        : (_, 'a) Ctypes_bigarray.t
                                          -> 'a typ
   | OCaml           : 'a ocaml_type      -> 'a ocaml typ
-and 'a cptr = { reftype      : 'a typ;
-                raw_ptr      : Ctypes_raw.voidp;
-                pmanaged     : Obj.t option;
-                pbyte_offset : int; }
 and 'a carray = { astart : 'a ptr; alength : int }
 and ('a, 'kind) structured = { structured : ('a, 'kind) structured ptr }
 and 'a union = ('a, [`Union]) structured
 and 'a structure = ('a, [`Struct]) structured
 and 'a abstract = ('a, [`Abstract]) structured
 and (_, _) pointer =
-  CPointer : 'a cptr -> ('a, [`C]) pointer
+  CPointer : 'a typ Ctypes_ptr.Fat.t -> ('a, [`C]) pointer
 | OCamlRef : int * 'a * 'a ocaml_type -> ('a, [`OCaml]) pointer
 and 'a ptr = ('a, [`C]) pointer
 and 'a ocaml = ('a, [`OCaml]) pointer
@@ -56,6 +52,7 @@
   read : 'b -> 'a;
   write : 'a -> 'b;
   format_typ: ((Format.formatter -> unit) -> Format.formatter -> unit) option;
+  format: (Format.formatter -> 'a -> unit) option;
   ty: 'b typ;
 }
 and ('a, 's) field = {
@@ -147,6 +144,7 @@
 val abstract : name:string -> size:int -> alignment:int -> 'a abstract typ
 val view : ?format_typ:((Format.formatter -> unit) ->
                         Format.formatter -> unit) ->
+           ?format: (Format.formatter -> 'b -> unit) ->
            read:('a -> 'b) -> write:('b -> 'a) -> 'a typ -> 'b typ
 val bigarray : < ba_repr : 'c;
                  bigarray : 'd;
@@ -159,6 +157,7 @@
 val union : string -> 'a union typ
 val offsetof : ('a, 'b) field -> int
 val field_type : ('a, 'b) field -> 'a typ
+val field_name : ('a, 'b) field -> string
 
 exception IncompleteType
 exception ModifyingSealedType of string
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/std_view_stubs.ml ./src/ctypes/std_view_stubs.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/std_view_stubs.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/std_view_stubs.ml	2014-10-06 15:23:14.000000000 +0000
@@ -8,7 +8,7 @@
 (* Stubs for standard views. *)
 
 (* Convert a C string to an OCaml string *)
-external string_of_cstring : Ctypes_raw.voidp -> int -> string
+external string_of_cstring : char Static.typ Ctypes_ptr.Fat.t -> string
   = "ctypes_string_of_cstring"
 
 (* Convert an OCaml string to a C string *)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/std_views.ml ./src/ctypes/std_views.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/std_views.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/std_views.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,22 +5,17 @@
  * See the file LICENSE for details.
  *)
 
-let string_of_char_ptr (Static.CPointer {Static.raw_ptr; pbyte_offset}) =
-  Std_view_stubs.string_of_cstring raw_ptr pbyte_offset
+let string_of_char_ptr (Static.CPointer p) =
+  Std_view_stubs.string_of_cstring p
 
 let char_ptr_of_string s =
-  let buf = Std_view_stubs.cstring_of_string s in
-  Static.CPointer {
-    Static.reftype = Static.char;
-    pmanaged = Some (Obj.repr buf);
-    raw_ptr = Memory_stubs.block_address buf;
-    pbyte_offset = 0; }
+  let managed = Std_view_stubs.cstring_of_string s in
+  Static.CPointer (Ctypes_ptr.Fat.make ~managed ~reftyp:Static.char
+                     (Memory_stubs.block_address managed))
 
 let string = Static.(view (ptr char))
   ~read:string_of_char_ptr ~write:char_ptr_of_string
 
-let castp typ p = Memory.(from_voidp typ (to_voidp p))
-
 let read_nullable t =
   let coerce = Coerce.coerce Static.(ptr void) t in
   fun p -> Memory.(if p = null then None else Some (coerce p))
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/type_info_stubs.c ./src/ctypes/type_info_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/type_info_stubs.c	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/type_info_stubs.c	2014-10-07 19:55:47.000000000 +0000
@@ -14,19 +14,19 @@
 #include <caml/memory.h>
 #include <caml/alloc.h>
 
+#include "type_info_stubs.h"
 #include "unsigned_stubs.h"
 #include "complex_stubs.h"
 #include "raw_pointer.h"
 #include "primitives.h"
 
 /* Read a C value from a block of memory */
-/* read : 'a prim -> offset:int -> raw_pointer -> 'a */
-value ctypes_read(value prim_, value offset_, value buffer_)
+/* read : 'a prim -> fat_pointer -> 'a */
+value ctypes_read(value prim_, value buffer_)
 {
-  CAMLparam3(prim_, offset_, buffer_);
+  CAMLparam2(prim_, buffer_);
   CAMLlocal1(b);
-  int offset = Int_val(offset_);
-  void *buf = (char *)CTYPES_TO_PTR(buffer_) + offset;
+  void *buf = CTYPES_ADDR_OF_FATPTR(buffer_);
   switch (Int_val(prim_))
   {
    case Char: b = Val_int(*(char *)buf); break;
@@ -62,12 +62,11 @@
 }
 
 /* Read a C value from a block of memory */
-/* write : 'a prim -> offset:int -> 'a -> raw_pointer -> unit */
-value ctypes_write(value prim_, value offset_, value v, value buffer_)
+/* write : 'a prim -> 'a -> fat_pointer -> unit */
+value ctypes_write(value prim_, value v, value buffer_)
 {
-  CAMLparam4(prim_, offset_, v, buffer_);
-  int offset = Int_val(offset_);
-  void *buf = (char *)CTYPES_TO_PTR(buffer_) + offset;
+  CAMLparam3(prim_, v, buffer_);
+  void *buf = CTYPES_ADDR_OF_FATPTR(buffer_);
   switch (Int_val(prim_))
   {
    case Char: *(char *)buf = Int_val(v); break;
@@ -156,28 +155,28 @@
   CAMLreturn (s);
 }
 
-/* read_pointer : offset:int -> raw_pointer -> raw_pointer */
-value ctypes_read_pointer(value offset_, value src_)
+/* read_pointer : fat_pointer -> raw_pointer */
+value ctypes_read_pointer(value src_)
 {
-  CAMLparam2(offset_, src_);
-  void *src = (char *)CTYPES_TO_PTR(src_) + Int_val(offset_);
+  CAMLparam1(src_);
+  void *src = CTYPES_ADDR_OF_FATPTR(src_);
   CAMLreturn(CTYPES_FROM_PTR(*(void **)src));
 }
 
-/* write_pointer : offset:int -> raw_pointer -> dst:raw_pointer -> unit */
-value ctypes_write_pointer(value offset_, value p_, value dst_)
+/* write_pointer : fat_pointer -> dst:fat_pointer -> unit */
+value ctypes_write_pointer(value p_, value dst_)
 {
-  CAMLparam3(offset_, p_, dst_);
-  void *dst = (char *)CTYPES_TO_PTR(dst_) + Int_val(offset_);
-  *(void **)dst = CTYPES_TO_PTR(p_);
+  CAMLparam2(p_, dst_);
+  void *dst = CTYPES_ADDR_OF_FATPTR(dst_);
+  *(void **)dst = CTYPES_ADDR_OF_FATPTR(p_);
   CAMLreturn(Val_unit);
 }
 
-/* string_of_pointer : raw_pointer -> string */
+/* string_of_pointer : fat_pointer -> string */
 value ctypes_string_of_pointer(value p_)
 {
   char buf[32];
   CAMLparam1(p_);
-  snprintf(buf, sizeof buf, "%p", CTYPES_TO_PTR(p_));
+  snprintf(buf, sizeof buf, "%p", CTYPES_ADDR_OF_FATPTR(p_));
   CAMLreturn (caml_copy_string(buf));
 }
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/type_info_stubs.h ./src/ctypes/type_info_stubs.h
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/type_info_stubs.h	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/type_info_stubs.h	2014-10-06 15:23:14.000000000 +0000
@@ -11,11 +11,11 @@
 #include <caml/mlvalues.h>
 
 /* Read a C value from a block of memory */
-/* read : 'a prim -> offset:int -> raw_pointer -> 'a */
-extern value ctypes_read(value ctype, value offset, value buffer);
+/* read : 'a prim -> raw_pointer -> 'a */
+extern value ctypes_read(value ctype, value buffer);
 
 /* Write a C value to a block of memory */
-/* write : 'a prim -> offset:int -> 'a -> raw_pointer -> unit */
-extern value ctypes_write(value ctype, value offset, value v, value buffer);
+/* write : 'a prim -> 'a -> raw_pointer -> unit */
+extern value ctypes_write(value ctype, value v, value buffer);
 
 #endif /* TYPE_INFO_STUBS_H */
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/unsigned_stubs.c ./src/ctypes/unsigned_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/unsigned_stubs.c	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/unsigned_stubs.c	2014-10-07 19:55:47.000000000 +0000
@@ -36,20 +36,20 @@
     return (u1 > u2) - (u1 < u2);                                            \
   }                                                                          \
                                                                              \
-  static long uint ## BITS ## _hash(value v)                                 \
+  static intnat uint ## BITS ## _hash(value v)                               \
   {                                                                          \
     return Uint_custom_val(TYPE(BITS), v);                                   \
   }                                                                          \
                                                                              \
   static void uint ## BITS ## _serialize(value v,                            \
-                                         unsigned long *wsize_32,            \
-                                         unsigned long *wsize_64)            \
+                                         uintnat *wsize_32,                  \
+                                         uintnat *wsize_64)                  \
   {                                                                          \
     caml_serialize_int_ ## BYTES(Uint_custom_val(TYPE(BITS), v));            \
     *wsize_32 = *wsize_64 = BYTES;                                           \
   }                                                                          \
                                                                              \
-  static unsigned long uint ## BITS ## _deserialize(void *dst)               \
+  static uintnat uint ## BITS ## _deserialize(void *dst)                     \
   {                                                                          \
     *(TYPE(BITS) *)dst = caml_deserialize_uint_ ## BYTES();                  \
     return BYTES;                                                            \
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/value_printing.ml ./src/ctypes/value_printing.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/value_printing.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/value_printing.ml	2014-10-06 15:23:14.000000000 +0000
@@ -21,12 +21,15 @@
     (fun fmt -> Type_printing.format_typ fmt) typ
   | Abstract _ -> format_structured fmt v
   | OCaml _ -> format_ocaml fmt v
-    (* For now, just print the underlying value in a view *)
-  | View {write; ty} -> format ty fmt (write v)
+  | View {write; ty; format=f} ->
+    begin match f with
+      | None -> format ty fmt (write v)
+      | Some f -> f fmt v
+    end
 and format_structured : type a b. Format.formatter -> (a, b) structured -> unit
-  = fun fmt ({structured = CPointer {reftype}} as s) ->
+  = fun fmt ({structured = CPointer p} as s) ->
     let open Format in
-    match reftype with
+    match Ctypes_ptr.Fat.reftype p with
     | Struct {fields} ->
       fprintf fmt "{@;<1 2>@[";
       format_fields "," fields fmt s;
@@ -39,11 +42,11 @@
       pp_print_string fmt "<abstract>"
     | _ -> raise (Unsupported "unknown structured type")
 and format_array : type a. Format.formatter -> a carray -> unit
-  = fun fmt ({astart = CPointer {reftype}; alength} as arr) ->
+  = fun fmt ({astart = CPointer p; alength} as arr) ->
     let open Format in
     fprintf fmt "{@;<1 2>@[";
     for i = 0 to alength - 1 do
-      format reftype fmt (CArray.get arr i);
+      format (Ctypes_ptr.Fat.reftype p) fmt (CArray.get arr i);
       if i <> alength - 1 then
         fprintf fmt ",@;"
     done;
@@ -77,9 +80,7 @@
           (if i <> last_field then sep else ""))
       fields
 and format_ptr : type a. Format.formatter -> a ptr -> unit
-  = fun fmt (CPointer {raw_ptr; reftype; pbyte_offset}) ->
-    Format.fprintf fmt "%s"
-      (Value_printing_stubs.string_of_pointer
-         (Raw.PtrType.(add raw_ptr (of_int pbyte_offset))))
+  = fun fmt (CPointer p) ->
+    Format.fprintf fmt "%s" (Value_printing_stubs.string_of_pointer p)
 
 let string_of typ v = Common.string_of (format typ) v
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes/value_printing_stubs.ml ./src/ctypes/value_printing_stubs.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes/value_printing_stubs.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes/value_printing_stubs.ml	2014-10-06 15:23:14.000000000 +0000
@@ -11,5 +11,5 @@
 external string_of_prim : 'a Primitives.prim -> 'a -> string
   = "ctypes_string_of_prim"
 
-external string_of_pointer : Ctypes_raw.voidp -> string
+external string_of_pointer : _ Ctypes_ptr.Fat.t -> string
   = "ctypes_string_of_pointer"
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes_config.h ./src/ctypes_config.h
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes_config.h	1970-01-01 00:00:00.000000000 +0000
+++ ./src/ctypes_config.h	2014-10-07 17:44:26.000000000 +0000
@@ -0,0 +1,3 @@
+#ifndef __CTYPES_CONFIG_H
+#define __CTYPES_CONFIG_H
+#endif
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/dl.ml ./src/ctypes-foreign-base/dl.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/dl.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/dl.ml	2014-10-06 15:23:14.000000000 +0000
@@ -22,7 +22,7 @@
   = "ctypes_dlopen"
     
 (* void *dlsym(void *handle, const char *symbol); *)
-external _dlsym : ?handle:library -> symbol:string -> int64 option
+external _dlsym : ?handle:library -> symbol:string -> nativeint option
   = "ctypes_dlsym"
 
 (* int dlclose(void *handle); *)
@@ -55,5 +55,5 @@
 
 let dlsym ?handle ~symbol =
   match _dlsym ?handle ~symbol with
-    | Some symbol -> Ctypes_raw.PtrType.of_int64 symbol
+    | Some symbol -> Ctypes_ptr.Raw.of_nativeint symbol
     | None        -> _report_dl_error ()
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/dl.mli ./src/ctypes-foreign-base/dl.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/dl.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/dl.mli	2014-10-06 15:23:14.000000000 +0000
@@ -30,5 +30,5 @@
 val dlclose : handle:library -> unit
 (** Close a dynamic library. *)
 
-val dlsym : ?handle:library -> symbol:string -> Ctypes_raw.voidp
+val dlsym : ?handle:library -> symbol:string -> Ctypes_ptr.voidp
 (** Look up a symbol in a dynamic library. *)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/dl_stubs.c ./src/ctypes-foreign-base/dl_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/dl_stubs.c	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/dl_stubs.c	2014-10-06 15:23:14.000000000 +0000
@@ -92,7 +92,7 @@
   void *result = dlsym(handle, s);
   CAMLreturn(result == NULL
              ? Val_none
-             : Val_some(caml_copy_int64((intptr_t)result)));
+             : Val_some(caml_copy_nativeint((intptr_t)result)));
 }
 
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi.ml ./src/ctypes-foreign-base/ffi.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/ffi.ml	2014-10-06 15:23:14.000000000 +0000
@@ -27,8 +27,8 @@
   let () = Ffi_stubs.set_closure_callback Closure_properties.retrieve
 
   type _ ccallspec =
-      Call : bool * (Ctypes_raw.voidp -> 'a) -> 'a ccallspec
-    | WriteArg : ('a -> Ctypes_raw.voidp -> (Obj.t * int) array -> unit) * 'b ccallspec ->
+      Call : bool * (Ctypes_ptr.voidp -> 'a) -> 'a ccallspec
+    | WriteArg : ('a -> Ctypes_ptr.voidp -> (Obj.t * int) array -> unit) * 'b ccallspec ->
                  ('a -> 'b) ccallspec
 
   type arg_type = ArgType : 'a Ffi_stubs.ffitype -> arg_type
@@ -47,7 +47,7 @@
   let rec arg_type : type a. a typ -> arg_type = function
     | Void                                -> ArgType (Ffi_stubs.void_ffitype ())
     | Primitive p as prim                 -> let ffitype = Ffi_stubs.primitive_ffitype p in
-                                             if ffitype = Ctypes_raw.null
+                                             if ffitype = Ctypes_ptr.Raw.null
                                              then report_unpassable
                                                (Type_printing.string_of_typ prim)
                                              else ArgType ffitype
@@ -76,13 +76,6 @@
        Ffi_stubs.complete_struct_type bufspec;
        ArgType (Ffi_stubs.ffi_type_of_struct_type bufspec)
 
-
-  let pick_call_stub check_errno name =
-    match check_errno, name with
-    | true, Some name -> Ffi_stubs.call_errno name
-    | true, None      -> Ffi_stubs.call_errno ""
-    | false, _        -> Ffi_stubs.call
-
   (*
     call addr callspec
      (fun buffer ->
@@ -94,15 +87,15 @@
   *)
   let rec invoke : type a. string option ->
                            a ccallspec ->
-                           (Ctypes_raw.voidp -> (Obj.t * int) array -> unit) list ->
+                           (Ctypes_ptr.voidp -> (Obj.t * int) array -> unit) list ->
                            Ffi_stubs.callspec ->
-                           Ctypes_raw.voidp ->
+                           unit typ Ctypes_ptr.Fat.t ->
                         a
     = fun name -> function
       | Call (check_errno, read_return_value) ->
-        let call = pick_call_stub check_errno name in
+        let name = match name with Some name -> name | None -> "" in
         fun writers callspec addr ->
-          call addr callspec
+          Ffi_stubs.call name addr callspec
             (fun buf arr -> List.iter (fun w -> w buf arr) writers)
             read_return_value
       | WriteArg (write, ccallspec) ->
@@ -126,14 +119,17 @@
       | Returns ty ->
         let () = prep_callspec callspec abi ty in
         let write_rv = Memory.write ty in
-        fun f -> Ffi_stubs.Done (write_rv ~offset:0 (WeakRef.get f), callspec)
+        fun f ->
+          let w = write_rv (WeakRef.get f) in
+          Ffi_stubs.Done ((fun p -> w (Ctypes_ptr.Fat.make ~reftyp:Void p)),
+                          callspec)
       | Function (p, f) ->
         let _ = add_argument callspec p in
         let box = box_function abi f callspec in
-        let read = Memory.build p ~offset:0 in
+        let read = Memory.build p in
         fun f -> Ffi_stubs.Fn (fun buf ->
           let f' =
-            try WeakRef.get f (read buf)
+            try WeakRef.get f (read (Ctypes_ptr.Fat.make ~reftyp:Void buf))
             with WeakRef.EmptyWeakReference ->
               raise Ffi_stubs.CallToExpiredClosure
           in
@@ -142,7 +138,7 @@
           v)
 
   let write_arg : type a. a typ -> offset:int -> idx:int -> a ->
-                  Ctypes_raw.voidp -> (Obj.t * int) array -> unit =
+                  Ctypes_ptr.voidp -> (Obj.t * int) array -> unit =
     let ocaml_arg elt_size =
       fun ~offset ~idx (OCamlRef (disp, obj, _)) dst mov ->
         mov.(idx) <- (Obj.repr obj, disp * elt_size)
@@ -150,7 +146,8 @@
     | OCaml String     -> ocaml_arg 1
     | OCaml Bytes      -> ocaml_arg 1
     | OCaml FloatArray -> ocaml_arg (Ctypes_primitives.sizeof Primitives.Double)
-    | ty -> (fun ~offset ~idx v dst mov -> Memory.write ty ~offset v dst)
+    | ty -> (fun ~offset ~idx v dst mov -> Memory.write ty v
+      (Ctypes_ptr.Fat.(add_bytes (make ~reftyp:Void dst) offset)))
 
   (*
     callspec = allocate_callspec ()
@@ -165,26 +162,32 @@
     = fun ~abi ~check_errno ?(idx=0) fn callspec -> match fn with
       | Returns t ->
         let () = prep_callspec callspec abi t in
-        Call (check_errno, Memory.build t ~offset:0)
+        let b = Memory.build t in
+        Call (check_errno, (fun p -> b (Ctypes_ptr.Fat.make ~reftyp:Void p)))
       | Function (p, f) ->
         let offset = add_argument callspec p in
         let rest = build_ccallspec ~abi ~check_errno ~idx:(idx+1) f callspec in
         WriteArg (write_arg p ~offset ~idx, rest)
 
-  let build_function ?name ~abi ~check_errno fn =
-    let c = Ffi_stubs.allocate_callspec () in
+  let build_function ?name ~abi ~release_runtime_lock ~check_errno fn =
+    let c = Ffi_stubs.allocate_callspec ~check_errno
+      ~runtime_lock:release_runtime_lock
+    in
     let e = build_ccallspec ~abi ~check_errno fn c in
     invoke name e [] c
 
   let ptr_of_rawptr raw_ptr =
-    CPointer { raw_ptr ; pbyte_offset = 0; reftype = void; pmanaged = None; }
-
-  let function_of_pointer ?name ~abi ~check_errno fn =
-    let f = build_function ?name ~abi ~check_errno fn in
-    fun (CPointer {raw_ptr}) -> f raw_ptr
+    CPointer (Ctypes_ptr.Fat.make ~reftyp:void raw_ptr)
 
-  let pointer_of_function ~abi fn =
-    let cs' = Ffi_stubs.allocate_callspec () in
+  let function_of_pointer ?name ~abi ~check_errno ~release_runtime_lock fn =
+    let f = build_function ?name ~abi ~check_errno ~release_runtime_lock fn in
+    fun (CPointer p) -> f p
+
+  let pointer_of_function ~abi ~acquire_runtime_lock fn =
+    let cs' = Ffi_stubs.allocate_callspec
+      ~check_errno:false
+      ~runtime_lock:acquire_runtime_lock
+    in
     let cs = box_function abi fn cs' in
     fun f ->
       let boxed = cs (WeakRef.make f) in
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi.mli ./src/ctypes-foreign-base/ffi.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/ffi.mli	2014-10-06 15:23:14.000000000 +0000
@@ -25,11 +25,12 @@
   (** Dynamic function calls based on libffi *)
 
   val function_of_pointer : ?name:string -> abi:abi -> check_errno:bool ->
-    ('a -> 'b) fn -> unit ptr -> ('a -> 'b)
+    release_runtime_lock:bool -> ('a -> 'b) fn -> unit ptr -> ('a -> 'b)
   (** Build an OCaml function from a type specification and a pointer to a C
       function. *)
 
-  val pointer_of_function : abi:abi -> ('a -> 'b) fn -> ('a -> 'b) -> unit ptr
+  val pointer_of_function : abi:abi -> acquire_runtime_lock:bool -> ('a -> 'b) fn ->
+    ('a -> 'b) -> unit ptr
   (** Build an C function from a type specification and an OCaml function.
 
       The C function pointer returned is callable as long as the OCaml function
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi_call_stubs.c ./src/ctypes-foreign-base/ffi_call_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi_call_stubs.c	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/ffi_call_stubs.c	2014-10-07 19:55:47.000000000 +0000
@@ -17,6 +17,8 @@
 #include <caml/fail.h>
 #include <caml/hash.h>
 #include <caml/unixsupport.h>
+#include <caml/unixsupport.h>
+#include <caml/threads.h>
 
 #include <ffi.h>
 
@@ -27,8 +29,6 @@
 /* TODO: support callbacks that raise exceptions?  e.g. using
    caml_callback_exn etc.  */
 
-/* TODO: thread support */
-
 /* An OCaml function that converts resolves identifiers to OCaml functions */
 static value retrieve_closure_;
 
@@ -106,7 +106,7 @@
   /* The maximum element alignment */
   size_t max_align;
 
-  /* The state of the bufferspec value. */
+  /* The state of the callspec value. */
   enum { BUILDING, CALLSPEC } state;
 
   /* A null-terminated array of size `nelements' types */
@@ -115,6 +115,13 @@
   /* return value offset */
   size_t roffset;
 
+  /* The context in which the call should run: whether errno is
+     checked, whether the runtime lock is released, and so on. */
+  struct call_context {
+    int check_errno;
+    int runtime_lock;
+  } context;
+
   /* The libffi call interface structure.  It would be nice for this member to
      be a value rather than a pointer (to save a layer of indirection) but the
      ffi_closure structure keeps the address of the structure, and the GC can
@@ -123,11 +130,11 @@
   ffi_cif *cif;
 
 } callspec_prototype = {
-  0, 0, 0, 0, BUILDING, NULL, -1, NULL
+  0, 0, 0, 0, BUILDING, NULL, -1, { 0, 0 }, NULL
 };
 
 
-static void finalize_bufferspec(value v)
+static void finalize_callspec(value v)
 {
   struct callspec *callspec = Data_custom_val(v);
   free(callspec->args);
@@ -136,8 +143,8 @@
 
 
 static struct custom_operations callspec_custom_ops = {
-  "ocaml-ctypes:bufferspec",
-  finalize_bufferspec,
+  "ocaml-ctypes:callspec",
+  finalize_callspec,
   custom_compare_default,
   custom_hash_default,
   custom_serialize_default,
@@ -187,13 +194,19 @@
 
 
 /* Allocate a new C call specification */
-/* allocate_callspec : unit -> callspec */
-value ctypes_allocate_callspec(value unit)
+/* allocate_callspec : check_errno:bool -> runtime_lock:bool -> callspec */
+value ctypes_allocate_callspec(value check_errno, value runtime_lock)
 {
+  struct call_context context = {
+    Int_val(check_errno),
+    Int_val(runtime_lock),
+  };
+
   value block = caml_alloc_custom(&callspec_custom_ops,
                                   sizeof(struct callspec), 0, 1);
-  memcpy(Data_custom_val(block), &callspec_prototype,
-         sizeof(struct callspec));
+  struct callspec *spec = Data_custom_val(block);
+  memcpy(spec, &callspec_prototype, sizeof(struct callspec));
+  spec->context = context;
   return block;
 }
 
@@ -275,16 +288,19 @@
 
 /* Call the function specified by `callspec', passing arguments and return
    values in `buffer' */
-/* call : raw_pointer -> callspec -> (raw_pointer -> Obj.t array -> unit) ->
-          (raw_pointer -> 'a) -> 'a */
-value ctypes_call(value function, value callspec_, value argwriter, value rvreader)
+/* call : string -> raw_pointer -> callspec ->
+          (raw_pointer -> Obj.t array -> unit) -> (raw_pointer -> 'a) -> 'a */
+value ctypes_call(value fnname, value function, value callspec_,
+                  value argwriter, value rvreader)
 {
-  CAMLparam4(function, callspec_, argwriter, rvreader);
+  CAMLparam5(fnname, function, callspec_, argwriter, rvreader);
   CAMLlocal3(callback_arg_buf, callback_val_arr, callback_rv_buf);
 
   struct callspec *callspec = Data_custom_val(callspec_);
   int roffset = callspec->roffset;
+  struct call_context context = callspec->context;
   size_t nelements = callspec->nelements;
+  ffi_cif *cif = callspec->cif;
 
   assert(callspec->state == CALLSPEC);
 
@@ -319,43 +335,44 @@
     ((void**)(callbuffer + arg_array_offset))[arg_idx] = &val_refs[arg_idx];
   }
 
-  void (*cfunction)(void) = (void (*)(void)) CTYPES_TO_PTR(function);
+  void (*cfunction)(void) = (void (*)(void)) CTYPES_ADDR_OF_FATPTR(function);
 
-  ffi_call(((struct callspec *)Data_custom_val(callspec_))->cif,
+  if (context.check_errno)
+  {
+    errno = 0;
+  }
+  if (context.runtime_lock)
+  {
+    caml_release_runtime_system();
+  }
+
+  ffi_call(cif,
            cfunction,
            return_slot,
            (void **)(callbuffer + arg_array_offset));
 
-  callback_rv_buf = CTYPES_FROM_PTR(return_slot);
-  CAMLreturn(caml_callback(rvreader, callback_rv_buf));
-}
-
-
-/* call_errno : string -> raw_pointer -> callspec ->
-               (raw_pointer -> unit) ->
-               (raw_pointer -> 'a) -> 'a */
-value ctypes_call_errno(value fnname, value function, value callspec_,
-                        value argwriter, value rvreader)
-{
-  CAMLparam5(fnname, function, callspec_, argwriter, rvreader);
+  if (context.runtime_lock)
+  {
+    caml_acquire_runtime_system();
+  }
 
-  errno = 0;
-  CAMLlocal1(rv);
-  rv = ctypes_call(function, callspec_, argwriter, rvreader);
-  if (errno != 0)
+  if (context.check_errno && errno != 0)
   {
     char *buffer = alloca(caml_string_length(fnname) + 1);
     strcpy(buffer, String_val(fnname));
     unix_error(errno, buffer, Nothing);
   }
-  CAMLreturn(rv);
+
+  callback_rv_buf = CTYPES_FROM_PTR(return_slot);
+  CAMLreturn(caml_callback(rvreader, callback_rv_buf));
 }
 
 typedef struct closure closure;
 struct closure
 {
-  ffi_closure closure;
-  int         fnkey;
+  ffi_closure         closure;
+  int                 fnkey;
+  struct call_context context;
 };
 
 enum boxedfn_tags { Done, Fn };
@@ -368,16 +385,37 @@
   CAMLparam0 ();
 
   CAMLlocal2(boxedfn, argptr);
-  boxedfn = retrieve_closure(*(int *)user_data);
+  closure *closure = user_data;
+
+  if (closure->context.runtime_lock)
+  {
+    caml_acquire_runtime_system();
+  }
+
+  boxedfn = retrieve_closure(closure->fnkey);
 
   int i, arity = cif->nargs;
-  for (i = 0; i < arity; i++)
+
+  switch (arity)
   {
-    void *cvalue = args[i];
-    assert (Tag_val(boxedfn) == Fn);
-    /* unbox and call */
-    argptr = CTYPES_FROM_PTR(cvalue);
-    boxedfn = caml_callback(Field(boxedfn, 0), argptr);
+    case 0:
+    {
+      assert (Tag_val(boxedfn) == Fn);
+      boxedfn = caml_callback(Field(boxedfn, 0), Val_unit);
+      break;
+    }
+    default:
+    {
+      for (i = 0; i < arity; i++)
+      {
+        void *cvalue = args[i];
+        assert (Tag_val(boxedfn) == Fn);
+        /* unbox and call */
+        argptr = CTYPES_FROM_PTR(cvalue);
+        boxedfn = caml_callback(Field(boxedfn, 0), argptr);
+      }
+      break;
+    }
   }
 
   /* now store the return value */
@@ -385,6 +423,11 @@
   argptr = CTYPES_FROM_PTR(ret);
   caml_callback(Field(boxedfn, 0), argptr);
 
+  if (closure->context.runtime_lock)
+  {
+    caml_release_runtime_system();
+  }
+
   CAMLreturn0;
 }
 
@@ -411,12 +454,13 @@
     caml_raise_out_of_memory();
   } else {
     closure->fnkey = Int_val(fnid);
+    closure->context = callspec->context;
 
     ffi_status status =  ffi_prep_closure_loc
       ((ffi_closure *)closure,
        callspec->cif,
        callback_handler,
-       &closure->fnkey,
+       closure,
        (void *)code_address);
 
     ctypes_check_ffi_status(status);
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi_stubs.ml ./src/ctypes-foreign-base/ffi_stubs.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/ffi_stubs.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/ffi_stubs.ml	2014-10-06 15:23:14.000000000 +0000
@@ -7,7 +7,7 @@
 
 (* Stubs for binding to libffi. *)
 
-open Ctypes_raw
+open Ctypes_ptr
 
 (* The type of structure types *)
 type 'a ffitype = voidp
@@ -41,7 +41,7 @@
 type callspec
 
 (* Allocate a new C call specification *)
-external allocate_callspec : unit -> callspec
+external allocate_callspec : check_errno:bool -> runtime_lock:bool -> callspec
   = "ctypes_allocate_callspec"
 
 (* Add an argument to the C buffer specification *)
@@ -55,15 +55,10 @@
 (* Call the function specified by `callspec' at the given address.
    The callback functions write the arguments to the buffer and read
    the return value. *)
-external call : voidp -> callspec ->
+external call : string -> unit Static.typ Fat.t -> callspec ->
   (voidp -> (Obj.t * int) array -> unit) -> (voidp -> 'a) -> 'a
   = "ctypes_call"
 
-(* As ctypes_call, but check errno and raise Unix_error if the call failed. *)
-external call_errno : string -> voidp -> callspec ->
-  (voidp -> (Obj.t * int) array -> unit) -> (voidp -> 'a) -> 'a
-  = "ctypes_call_errno"
-
 
 (* nary callbacks *)
 type boxedfn =
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/foreign_basis.ml ./src/ctypes-foreign-base/foreign_basis.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/foreign_basis.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-base/foreign_basis.ml	2014-10-06 15:23:14.000000000 +0000
@@ -18,10 +18,13 @@
     Type_printing.format_fn' fn
       (fun fmt -> Format.fprintf fmt "(*%t)" k) fmt
 
-  let funptr ?(abi=Libffi_abi.default_abi) ?name ?(check_errno=false) fn =
+  let funptr ?(abi=Libffi_abi.default_abi) ?name ?(check_errno=false)
+      ?(runtime_lock=false) fn =
     let open Ffi in
-    let read = function_of_pointer ~abi ~check_errno ?name fn
-    and write = pointer_of_function ~abi fn
+    let read = function_of_pointer
+      ~abi ~check_errno ~release_runtime_lock:runtime_lock ?name fn
+    and write = pointer_of_function
+      ~abi ~acquire_runtime_lock:runtime_lock fn
     and format_typ = format_function_pointer fn in
     Static.(view ~format_typ ~read ~write (ptr void))
 
@@ -30,16 +33,16 @@
   let funptr_opt ?abi fn = Std_views.nullable_view (funptr ?abi fn)
 
   let ptr_of_raw_ptr p = 
-    Ctypes.ptr_of_raw_address (Ctypes_raw.PtrType.to_int64 p)
+    Ctypes.ptr_of_raw_address (Ctypes_ptr.Raw.to_nativeint p)
 
   let foreign_value ?from symbol t =
     from_voidp t (ptr_of_raw_ptr (dlsym ?handle:from ~symbol))
 
   let foreign ?(abi=Libffi_abi.default_abi) ?from ?(stub=false)
-      ?(check_errno=false) symbol typ =
+      ?(check_errno=false) ?(release_runtime_lock=false) symbol typ =
     try
       let coerce = Coerce.coerce (ptr void)
-        (funptr ~abi ~name:symbol ~check_errno typ) in
+        (funptr ~abi ~name:symbol ~check_errno ~runtime_lock:release_runtime_lock typ) in
       coerce (ptr_of_raw_ptr (dlsym ?handle:from ~symbol))
     with 
     | exn -> if stub then fun _ -> raise exn else raise exn
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/libffi_abi.ml ./src/ctypes-foreign-base/libffi_abi.ml
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-base/libffi_abi.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./src/ctypes-foreign-base/libffi_abi.ml	2014-10-07 17:44:28.000000000 +0000
@@ -0,0 +1,43 @@
+
+(*
+ * Copyright (c) 2014 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* Support for various ABIs *)
+
+type abi = Code of int | Unsupported of string
+
+let abi_code = function
+   Code c -> c
+ | Unsupported sym -> raise (Ctypes.Unsupported sym)
+
+let aix = Unsupported "FFI_AIX"
+let darwin = Unsupported "FFI_DARWIN"
+let eabi = Unsupported "FFI_EABI"
+let fastcall = Unsupported "FFI_FASTCALL"
+let gcc_sysv = Unsupported "FFI_GCC_SYSV"
+let linux = Unsupported "FFI_LINUX"
+let linux64 = Unsupported "FFI_LINUX64"
+let linux_soft_float = Unsupported "FFI_LINUX_SOFT_FLOAT"
+let ms_cdecl = Unsupported "FFI_MS_CDECL"
+let n32 = Unsupported "FFI_N32"
+let n32_soft_float = Unsupported "FFI_N32_SOFT_FLOAT"
+let n64 = Unsupported "FFI_N64"
+let n64_soft_float = Unsupported "FFI_N64_SOFT_FLOAT"
+let o32 = Unsupported "FFI_O32"
+let o32_soft_float = Unsupported "FFI_O32_SOFT_FLOAT"
+let osf = Unsupported "FFI_OSF"
+let pa32 = Unsupported "FFI_PA32"
+let stdcall = Unsupported "FFI_STDCALL"
+let sysv = Code 1
+let thiscall = Unsupported "FFI_THISCALL"
+let unix = Unsupported "FFI_UNIX"
+let unix64 = Code 2
+let v8 = Unsupported "FFI_V8"
+let v8plus = Unsupported "FFI_V8PLUS"
+let v9 = Unsupported "FFI_V9"
+let vfp = Unsupported "FFI_VFP"
+let default_abi = Code 2
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-threaded/foreign.mli ./src/ctypes-foreign-threaded/foreign.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-threaded/foreign.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-threaded/foreign.mli	2014-10-06 15:23:14.000000000 +0000
@@ -12,6 +12,7 @@
   ?from:Dl.library ->
   ?stub:bool -> 
   ?check_errno:bool ->
+  ?release_runtime_lock:bool ->
   string ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b)
@@ -28,6 +29,13 @@
     The value [?check_errno], which defaults to [false], indicates whether
     {!Unix.Unix_error} should be raised if the C function modifies [errno].
 
+    The value [?release_runtime_lock], which defaults to [false], indicates
+    whether the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must not
+    call back into OCaml.
+
     @raise Dl.DL_error if [name] is not found in [?from] and [?stub] is
     [false]. *)
 
@@ -40,6 +48,7 @@
   ?abi:Libffi_abi.abi ->
   ?name:string ->
   ?check_errno:bool ->
+  ?runtime_lock:bool ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b) Ctypes.typ
 (** Construct a function pointer type from a function type.
@@ -51,7 +60,19 @@
     restrictions.
 
     The value [?check_errno], which defaults to [false], indicates whether
-    {!Unix.Unix_error} should be raised if the C function modifies [errno]. *)
+    {!Unix.Unix_error} should be raised if the C function modifies [errno].
+
+    The value [?runtime_lock], which defaults to [false], indicates whether
+    the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must
+    not call back into OCaml.  If the function pointer is used to call into
+    OCaml from C then the [?runtime_lock] argument indicates whether the lock
+    should be acquired and held during the call.
+
+    @raise Dl.DL_error if [name] is not found in [?from] and [?stub] is
+    [false]. *)
 
 val funptr_opt :
   ?abi:Libffi_abi.abi ->
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-unthreaded/foreign.mli ./src/ctypes-foreign-unthreaded/foreign.mli
--- ../ocaml-ctypes-0.3.3.orig/src/ctypes-foreign-unthreaded/foreign.mli	2014-08-01 08:23:56.000000000 +0000
+++ ./src/ctypes-foreign-unthreaded/foreign.mli	2014-10-06 15:23:14.000000000 +0000
@@ -12,6 +12,7 @@
   ?from:Dl.library ->
   ?stub:bool -> 
   ?check_errno:bool ->
+  ?release_runtime_lock:bool ->
   string ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b)
@@ -28,6 +29,13 @@
     The value [?check_errno], which defaults to [false], indicates whether
     {!Unix.Unix_error} should be raised if the C function modifies [errno].
 
+    The value [?release_runtime_lock], which defaults to [false], indicates
+    whether the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must not
+    call back into OCaml.
+
     @raise Dl.DL_error if [name] is not found in [?from] and [?stub] is
     [false]. *)
 
@@ -40,6 +48,7 @@
   ?abi:Libffi_abi.abi ->
   ?name:string ->
   ?check_errno:bool ->
+  ?runtime_lock:bool ->
   ('a -> 'b) Ctypes.fn ->
   ('a -> 'b) Ctypes.typ
 (** Construct a function pointer type from a function type.
@@ -51,7 +60,16 @@
     restrictions.
 
     The value [?check_errno], which defaults to [false], indicates whether
-    {!Unix.Unix_error} should be raised if the C function modifies [errno]. *)
+    {!Unix.Unix_error} should be raised if the C function modifies [errno].
+
+    The value [?runtime_lock], which defaults to [false], indicates whether
+    the OCaml runtime lock should be released during the call to the C
+    function, allowing other threads to run.  If the runtime lock is released
+    then the C function must not access OCaml heap objects, such as arguments
+    passed using {!Ctypes.ocaml_string} and {!Ctypes.ocaml_bytes}, and must
+    not call back into OCaml.  If the function pointer is used to call into
+    OCaml from C then the [?runtime_lock] argument indicates whether the lock
+    should be acquired and held during the call. *)
 
 val funptr_opt :
   ?abi:Libffi_abi.abi ->
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/clib/test_functions.c ./tests/clib/test_functions.c
--- ../ocaml-ctypes-0.3.3.orig/tests/clib/test_functions.c	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/clib/test_functions.c	2014-10-07 19:55:47.000000000 +0000
@@ -16,6 +16,8 @@
 #include <string.h>
 #include <complex.h>
 
+#include <semaphore.h>
+
 #include "test_functions.h"
 
 static int add(int x, int y) { return x + y; }
@@ -376,8 +378,6 @@
 unsigned int retrieve_UINT_MAX(void) { return UINT_MAX; }
 long retrieve_LONG_MAX(void) { return LONG_MAX; }
 long retrieve_LONG_MIN(void) { return LONG_MIN; }
-long retrieve_nLONG_MAX(void) { return LONG_MAX; }
-long retrieve_nLONG_MIN(void) { return LONG_MIN; }
 unsigned long retrieve_ULONG_MAX(void) { return ULONG_MAX; }
 long long retrieve_LLONG_MAX(void) { return LLONG_MAX; }
 long long retrieve_LLONG_MIN(void) { return LLONG_MIN; }
@@ -501,3 +501,40 @@
   }
   return sum;
 }
+
+static callback_t *registered_callback = NULL;
+
+void register_callback(callback_t *callback)
+{
+  registered_callback = callback;
+}
+
+void call_registered_callback(int times, int starting_value)
+{
+  int i;
+  for (i = 0; i < times; i++) {
+    int result = registered_callback();
+    assert (result == starting_value++);
+  }
+}
+
+static sem_t semaphore1;
+static sem_t semaphore2;
+
+void initialize_waiters(void)
+{
+  sem_init(&semaphore1, 0, -1);
+  sem_init(&semaphore2, 0, -1);
+}
+
+void post1_wait2(void)
+{
+  sem_post(&semaphore1);
+  sem_wait(&semaphore2);
+}
+
+void post2_wait1(void)
+{
+  sem_post(&semaphore2);
+  sem_wait(&semaphore1);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/clib/test_functions.h ./tests/clib/test_functions.h
--- ../ocaml-ctypes-0.3.3.orig/tests/clib/test_functions.h	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/clib/test_functions.h	2014-10-06 15:23:14.000000000 +0000
@@ -118,8 +118,6 @@
 unsigned int retrieve_UINT_MAX(void);
 long retrieve_LONG_MAX(void);
 long retrieve_LONG_MIN(void);
-long retrieve_nLONG_MAX(void);
-long retrieve_nLONG_MIN(void);
 unsigned long retrieve_ULONG_MAX(void);
 long long retrieve_LLONG_MAX(void);
 long long retrieve_LLONG_MIN(void);
@@ -158,5 +156,11 @@
 double *matrix_transpose(int, int, double *);
 int (*plus_callback)(int);
 int sum_range_with_plus_callback(int, int);
+typedef int callback_t(void);
+void register_callback(callback_t *);
+void call_registered_callback(int, int);
+void initialize_waiters(void);
+void post1_wait2(void);
+void post2_wait1(void);
 
 #endif /* TEST_FUNCTIONS_H */
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-alignment/test_alignment.ml ./tests/test-alignment/test_alignment.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-alignment/test_alignment.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-alignment/test_alignment.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Test some relationships between the alignment requirements of primitive types.
 *)
-let test_primitive_alignment () = begin
+let test_primitive_alignment _ = begin
   assert_equal ~msg:"alignmentof(char) == 1"
     (alignment char) 1;
 
@@ -57,7 +57,7 @@
 (*
   Test the alignment of abstract types
 *)
-let test_abstract_alignment () =
+let test_abstract_alignment _ =
   for i = 1 to 10 do
     assert_equal
       i (alignment (abstract ~name:"abstract" ~size:(11 - i) ~alignment:i))
@@ -67,7 +67,7 @@
 (*
   Test that requesting the alignment of an incomplete type raises an exception.
 *)
-let test_incomplete_alignment () =
+let test_incomplete_alignment _ =
   assert_raises IncompleteType
     (fun () -> alignment void);
 
@@ -94,7 +94,7 @@
 (*
   Test that [alignment] treats OCaml types as incomplete.
 *)
-let test_alignment_ocaml_string () =
+let test_alignment_ocaml_string _ =
   assert_raises IncompleteType
     (fun () -> alignment ocaml_string)
 
@@ -103,7 +103,7 @@
    Test that the alignment of a struct is equal to the maximum
    alignment of its members.
 *)
-let test_struct_alignment () = 
+let test_struct_alignment _ = 
   let module M = struct
     type a and b and u
 
@@ -160,7 +160,7 @@
      sizeof (struct A) == 12
      sizeof (struct B) == 16
 *)
-let test_struct_tail_padding () = 
+let test_struct_tail_padding _ = 
   let module M = struct
     type a and b and u
 
@@ -237,7 +237,7 @@
    Test that the alignment of a bigarray is the same as the alignment
    of its element type.
 *)
-let test_bigarray_alignment () =
+let test_bigarray_alignment _ =
   let module M = struct
     module B = Bigarray
     type k = K : ('a, 'b) Bigarray.kind * int -> k
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-arrays/generated_bindings.ml ./tests/test-arrays/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-arrays/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-arrays/generated_bindings.ml	2014-10-07 17:44:48.000000000 +0000
@@ -0,0 +1,14 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_accepts_pointer_to_array_of_structs
+  : _ CI.fatptr -> float
+  = "cstubs_tests_1_accepts_pointer_to_array_of_structs" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "accepts_pointer_to_array_of_structs",
+  CI.Function (CI.Pointer x2, CI.Returns (CI.Primitive CI.Double)) ->
+  (fun x1 -> cstubs_tests_1_accepts_pointer_to_array_of_structs (CI.cptr x1))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-arrays/generated_stubs.c ./tests/test-arrays/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-arrays/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-arrays/generated_stubs.c	2014-10-07 17:44:48.000000000 +0000
@@ -0,0 +1,10 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_accepts_pointer_to_array_of_structs(value x1)
+{
+   struct tagged(* x2)[5] = CTYPES_ADDR_OF_FATPTR(x1);
+   double x3 = accepts_pointer_to_array_of_structs(x2);
+   return caml_copy_double(x3);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-arrays/test_array.ml ./tests/test-arrays/test_array.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-arrays/test_array.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-arrays/test_array.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -15,7 +15,7 @@
 (*
   Creating multidimensional arrays, and reading and writing elements.
 *)
-let test_multidimensional_arrays () =
+let test_multidimensional_arrays _ =
   let module Array = CArray in
   (* one dimension *)
   let one = Array.make int 10 in
@@ -96,7 +96,7 @@
 (*
   Test that creating an array initializes all elements appropriately.
 *)
-let test_array_initialiation () =
+let test_array_initialiation _ =
   let module Array = CArray in
   let int_array = Array.make int ~initial:33 10 in
   for i = 0 to Array.length int_array - 1 do
@@ -114,7 +114,7 @@
 (*
   Test that creating arrays of elements of incomplete type fails.
 *)
-let test_arrays_of_incomplete_type () =
+let test_arrays_of_incomplete_type _ =
   let module M = struct
     let () = assert_raises IncompleteType
       (fun () -> CArray.make void 10)
@@ -128,7 +128,7 @@
 (*
   Test that OCaml types cannot be used to build arrays.
 *)
-let test_ocaml_types_rejected_as_array_elements () =
+let test_ocaml_types_rejected_as_array_elements _ =
   assert_raises IncompleteType
     (fun () -> CArray.make ocaml_string 10)
 
@@ -136,7 +136,7 @@
 (*
   Test that creating an array initializes all elements appropriately.
 *)
-let test_pointer_to_array_arithmetic () =
+let test_pointer_to_array_arithmetic _ =
   let module Array = CArray in
   (* int ( * )[3] *)
   let p = allocate_n (array 3 int) ~count:4 in
@@ -161,7 +161,7 @@
   (*
     Test passing pointer to array of structs.
   *)
-  let test_passing_pointer_to_array_of_structs () =
+  let test_passing_pointer_to_array_of_structs _ =
     let box_int x =
       let v = make s in
       setf v tag 'i';
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-bigarrays/generated_bindings.ml ./tests/test-bigarrays/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-bigarrays/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-bigarrays/generated_bindings.ml	2014-10-07 17:44:55.000000000 +0000
@@ -0,0 +1,37 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_matrix_mul
+  : int -> int -> int -> _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> unit
+  = "cstubs_tests_1_matrix_mul_byte6" "cstubs_tests_1_matrix_mul" 
+
+external cstubs_tests_2_matrix_transpose
+  : int -> int -> _ CI.fatptr -> CI.voidp = "cstubs_tests_2_matrix_transpose" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "matrix_transpose",
+  CI.Function
+    (CI.Primitive CI.Int,
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Function (CI.Pointer x4, CI.Returns (CI.Pointer x5)))) ->
+  (fun x1 x2 x3 ->
+    CI.make_ptr x5 (cstubs_tests_2_matrix_transpose x1 x2 (CI.cptr x3)))
+| "matrix_mul",
+  CI.Function
+    (CI.Primitive CI.Int,
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Function
+          (CI.Primitive CI.Int,
+           CI.Function
+             (CI.Pointer x10,
+              CI.Function
+                (CI.Pointer x12,
+                 CI.Function (CI.Pointer x14, CI.Returns CI.Void)))))) ->
+  (fun x6 x7 x8 x9 x11 x13 ->
+    cstubs_tests_1_matrix_mul x6 x7 x8 (CI.cptr x9) (CI.cptr x11)
+    (CI.cptr x13))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-bigarrays/generated_stubs.c ./tests/test-bigarrays/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-bigarrays/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-bigarrays/generated_stubs.c	2014-10-07 17:44:55.000000000 +0000
@@ -0,0 +1,34 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_matrix_mul(value x6, value x5, value x4, value x3,
+                                value x2, value x1)
+{
+   int x7 = Int_val(x6);
+   int x10 = Int_val(x5);
+   int x13 = Int_val(x4);
+   double* x16 = CTYPES_ADDR_OF_FATPTR(x3);
+   double* x17 = CTYPES_ADDR_OF_FATPTR(x2);
+   double* x18 = CTYPES_ADDR_OF_FATPTR(x1);
+   matrix_mul(x7, x10, x13, x16, x17, x18);
+   return Val_unit;
+}
+value cstubs_tests_1_matrix_mul_byte6(value* argv, int argc)
+{
+   value x20 = argv[5];
+   value x21 = argv[4];
+   value x22 = argv[3];
+   value x23 = argv[2];
+   value x24 = argv[1];
+   value x25 = argv[0];
+   return cstubs_tests_1_matrix_mul(x25, x24, x23, x22, x21, x20);
+}
+value cstubs_tests_2_matrix_transpose(value x28, value x27, value x26)
+{
+   int x29 = Int_val(x28);
+   int x32 = Int_val(x27);
+   double* x35 = CTYPES_ADDR_OF_FATPTR(x26);
+   double* x36 = matrix_transpose(x29, x32, x35);
+   return CTYPES_FROM_PTR(x36);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-bigarrays/test_bigarrays.ml ./tests/test-bigarrays/test_bigarrays.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-bigarrays/test_bigarrays.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-bigarrays/test_bigarrays.ml	2014-10-06 15:23:14.000000000 +0000
@@ -8,7 +8,7 @@
 module Std_array = Array
 type 'a std_array = 'a array
 
-open OUnit
+open OUnit2
 open Ctypes
 module BA = Bigarray
 
@@ -37,7 +37,7 @@
 (*
   View ctypes-managed memory through a bigarray lens.
 *)
-let test_bigarray_of_ctypes_array () =
+let test_bigarray_of_ctypes_array _ =
   (* One-dimensional Genarrays *)
   let module Array = CArray in
   let a1 = Array.of_list int8_t [10; 20; 30; 40] in
@@ -157,7 +157,7 @@
 (*
   View bigarray-managed memory through a ctypes lens
 *)
-let test_ctypes_array_of_bigarray () =
+let test_ctypes_array_of_bigarray _ =
   let module Array = CArray in
 
   (* One-dimensional Genarrays *)
@@ -328,7 +328,7 @@
   (*
     Test passing bigarrays to c functions.
   *)
-  let test_passing_bigarrays () =
+  let test_passing_bigarrays _ =
     let mul l r =
       let m = BA.Array2.dim1 l and n = BA.Array2.dim2 l in
       let o = BA.Array2.dim1 r and p = BA.Array2.dim2 r in
@@ -360,7 +360,7 @@
   (*
     Test returning bigarrays from c functions.
   *)
-  let test_returning_bigarrays () =
+  let test_returning_bigarrays _ =
     let transpose m =
       (* For the purposes of the test we'll just leak the allocated memory. *)
       let rows = BA.Array2.dim1 m and cols = BA.Array2.dim2 m in
@@ -382,7 +382,7 @@
   Test that bigarrays are not collected while there's a ctypes pointer pointing
   into them.
 *)
-let test_bigarray_lifetime_with_ctypes_reference () =
+let test_bigarray_lifetime_with_ctypes_reference _ =
   let state = ref `Not_safe_to_collect in
   let finalise ba =
     begin
@@ -424,7 +424,7 @@
   Test that ctypes-allocated memory is not collected while there's a bigarray
   associated with it.
 *)
-let test_ctypes_memory_lifetime_with_bigarray_reference () =
+let test_ctypes_memory_lifetime_with_bigarray_reference _ =
   let module Array = CArray in
   let state = ref `Not_safe_to_collect in
   let finalise a =
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-builtins/generated_bindings.ml ./tests/test-builtins/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-builtins/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-builtins/generated_bindings.ml	2014-10-07 17:44:42.000000000 +0000
@@ -0,0 +1,27 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1___sync_or_and_fetch
+  : _ CI.fatptr -> Unsigned.uint8 -> Unsigned.uint8
+  = "cstubs_tests_1___sync_or_and_fetch" 
+
+external cstubs_tests_2___sync_fetch_and_and
+  : _ CI.fatptr -> Unsigned.uint8 -> Unsigned.uint8
+  = "cstubs_tests_2___sync_fetch_and_and" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "__sync_fetch_and_and",
+  CI.Function
+    (CI.Pointer x2,
+     CI.Function
+       (CI.Primitive CI.Uint8_t, CI.Returns (CI.Primitive CI.Uint8_t))) ->
+  (fun x1 x3 -> cstubs_tests_2___sync_fetch_and_and (CI.cptr x1) x3)
+| "__sync_or_and_fetch",
+  CI.Function
+    (CI.Pointer x5,
+     CI.Function
+       (CI.Primitive CI.Uint8_t, CI.Returns (CI.Primitive CI.Uint8_t))) ->
+  (fun x4 x6 -> cstubs_tests_1___sync_or_and_fetch (CI.cptr x4) x6)
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-builtins/generated_stubs.c ./tests/test-builtins/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-builtins/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-builtins/generated_stubs.c	2014-10-07 17:44:42.000000000 +0000
@@ -0,0 +1,18 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1___sync_or_and_fetch(value x2, value x1)
+{
+   uint8_t* x3 = CTYPES_ADDR_OF_FATPTR(x2);
+   uint8_t x4 = Uint8_val(x1);
+   uint8_t x7 = __sync_or_and_fetch(x3, x4);
+   return ctypes_copy_uint8(x7);
+}
+value cstubs_tests_2___sync_fetch_and_and(value x9, value x8)
+{
+   uint8_t* x10 = CTYPES_ADDR_OF_FATPTR(x9);
+   uint8_t x11 = Uint8_val(x8);
+   uint8_t x14 = __sync_fetch_and_and(x10, x11);
+   return ctypes_copy_uint8(x14);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-builtins/test_builtins.ml ./tests/test-builtins/test_builtins.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-builtins/test_builtins.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-builtins/test_builtins.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 module Bindings = Functions.Stubs(Generated_bindings)
@@ -13,7 +13,7 @@
 (*
   Test calling builtins.
 *)
-let test_calling_builtins () =
+let test_calling_builtins _ =
   let open Unsigned.UInt8 in
   let open Bindings in
   let u1 = of_int 0x77
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-callback_lifetime/generated_bindings.ml ./tests/test-callback_lifetime/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-callback_lifetime/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-callback_lifetime/generated_bindings.ml	2014-10-07 17:44:54.000000000 +0000
@@ -0,0 +1,29 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_store_callback : _ CI.fatptr -> unit
+  = "cstubs_tests_1_store_callback" 
+
+external cstubs_tests_2_invoke_stored_callback : int -> int
+  = "cstubs_tests_2_invoke_stored_callback" 
+
+external cstubs_tests_3_return_callback : _ CI.fatptr -> CI.voidp
+  = "cstubs_tests_3_return_callback" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "return_callback",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x3; write = x2; },
+     CI.Returns (CI.View {CI.ty = CI.Pointer x4; read = x5; })) ->
+  (fun x1 ->
+    x5 (CI.make_ptr x4 (cstubs_tests_3_return_callback (CI.cptr (x2 x1)))))
+| "invoke_stored_callback",
+  CI.Function (CI.Primitive CI.Int, CI.Returns (CI.Primitive CI.Int)) ->
+  cstubs_tests_2_invoke_stored_callback
+| "store_callback",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x9; write = x8; }, CI.Returns CI.Void) ->
+  (fun x7 -> cstubs_tests_1_store_callback (CI.cptr (x8 x7)))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-callback_lifetime/generated_stubs.c ./tests/test-callback_lifetime/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-callback_lifetime/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-callback_lifetime/generated_stubs.c	2014-10-07 17:44:54.000000000 +0000
@@ -0,0 +1,22 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_store_callback(value x1)
+{
+   int(* x2)(int) = CTYPES_ADDR_OF_FATPTR(x1);
+   store_callback(x2);
+   return Val_unit;
+}
+value cstubs_tests_2_invoke_stored_callback(value x4)
+{
+   int x5 = Int_val(x4);
+   int x8 = invoke_stored_callback(x5);
+   return Val_int(x8);
+}
+value cstubs_tests_3_return_callback(value x9)
+{
+   int(* x10)(int) = CTYPES_ADDR_OF_FATPTR(x9);
+   int(* x11)(int) = return_callback(x10);
+   return CTYPES_FROM_PTR(x11);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-callback_lifetime/test_callback_lifetime.ml ./tests/test-callback_lifetime/test_callback_lifetime.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-callback_lifetime/test_callback_lifetime.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-callback_lifetime/test_callback_lifetime.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
@@ -19,7 +19,7 @@
     Check that we can store a reference to an OCaml function in a C global and
     invoke it later.
   *)
-  let test_storing_function_reference () =
+  let test_storing_function_reference _ =
     (* This shouldn't be collected in the code that follows. *)
     let double x = x * 2 in
 
@@ -38,7 +38,7 @@
     have defined behaviour, since the structures needed to make the call may
     have been garbage collected.
   *)
-  let test_calling_collected_closure_raises_exception () =
+  let test_calling_collected_closure_raises_exception _ =
     let closure x y = x * y in
 
     begin
@@ -57,7 +57,7 @@
     Check that we have fairly fine-grained control over the lifetime of closures
     passed to C.
   *)
-  let test_controlling_closure_lifetime () =
+  let test_controlling_closure_lifetime _ =
     (* The return_callback function simply returns its argument.  However, since
        that involves converting an OCaml function ("arg") to a C function
        pointer and back to an OCaml function ("ret"), there are potential
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-coercions/generated_bindings.ml ./tests/test-coercions/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-coercions/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-coercions/generated_bindings.ml	2014-10-07 17:44:56.000000000 +0000
@@ -0,0 +1,18 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_memchr
+  : _ CI.fatptr -> int -> Unsigned.size_t -> CI.voidp
+  = "cstubs_tests_1_memchr" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "memchr",
+  CI.Function
+    (CI.Pointer x2,
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Function (CI.Primitive CI.Size_t, CI.Returns (CI.Pointer x5)))) ->
+  (fun x1 x3 x4 -> CI.make_ptr x5 (cstubs_tests_1_memchr (CI.cptr x1) x3 x4))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-coercions/generated_stubs.c ./tests/test-coercions/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-coercions/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-coercions/generated_stubs.c	2014-10-07 17:44:56.000000000 +0000
@@ -0,0 +1,12 @@
+#include "clib/test_functions.h"
+#include <string.h>
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_memchr(value x3, value x2, value x1)
+{
+   void* x4 = CTYPES_ADDR_OF_FATPTR(x3);
+   int x5 = Int_val(x2);
+   size_t x8 = ctypes_size_t_val(x1);
+   void* x11 = memchr(x4, x5, x8);
+   return CTYPES_FROM_PTR(x11);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-coercions/test_coercions.ml ./tests/test-coercions/test_coercions.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-coercions/test_coercions.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-coercions/test_coercions.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (* 
    Check coercions between pointers.
 *)
-let test_pointer_coercions () =
+let test_pointer_coercions _ =
   let module M = struct
     type boxed_type = T : 'a typ -> boxed_type
     let types = [
@@ -53,7 +53,7 @@
   Check that coercions between a pointer to a struct and a pointer to
   its first member succeed.
 *)
-let test_struct_first_member_coercions () =
+let test_struct_first_member_coercions _ =
   let module M = struct
     let s = structure "s"
     let f = field s "f" double
@@ -77,7 +77,7 @@
    Check that coercions between a pointer to a union and a pointer to
    a member succeed.
 *)
-let test_union_coercions () =
+let test_union_coercions _ =
   let module M = struct
     let u = union "u"
     let f = field u "f" double
@@ -108,7 +108,7 @@
 (* 
    Check coercions between views.
 *)
-let test_view_coercions () =
+let test_view_coercions _ =
   let module M = struct
     type 'a variant = V of 'a
     let unV (V v) = v and inV v = V v
@@ -142,7 +142,7 @@
   (* 
      Check coercions between functions.
   *)
-  let test_function_coercions () =
+  let test_function_coercions _ =
     let isize_t = view size_t
       ~read:Unsigned.Size_t.to_int ~write:Unsigned.Size_t.of_int in
     let memchr' = coerce_fn
@@ -164,7 +164,7 @@
 (* 
    Check that identity coercions are cost-free.
 *)
-let test_identity_coercions () =
+let test_identity_coercions _ =
   let f = fun x y -> x in
   let fn = int @-> float @-> returning int in
   let f' = coerce_fn fn fn f in
@@ -174,7 +174,7 @@
 (* 
    Check that coercions between unsupported types raise an exception
 *)
-let test_unsupported_coercions () =
+let test_unsupported_coercions _ =
   let module M = struct
     type boxed_type = T : 'a typ -> boxed_type
     let types = [
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-complex/generated_bindings.ml ./tests/test-complex/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-complex/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-complex/generated_bindings.ml	2014-10-07 17:44:53.000000000 +0000
@@ -0,0 +1,87 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_add_complexd
+  : _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> unit
+  = "cstubs_tests_1_add_complexd" 
+
+external cstubs_tests_2_mul_complexd
+  : _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> unit
+  = "cstubs_tests_2_mul_complexd" 
+
+external cstubs_tests_3_add_complexf
+  : _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> unit
+  = "cstubs_tests_3_add_complexf" 
+
+external cstubs_tests_4_mul_complexf
+  : _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> unit
+  = "cstubs_tests_4_mul_complexf" 
+
+external cstubs_tests_5_add_complexd_val
+  : Complex.t -> Complex.t -> Complex.t = "cstubs_tests_5_add_complexd_val" 
+
+external cstubs_tests_6_mul_complexd_val
+  : Complex.t -> Complex.t -> Complex.t = "cstubs_tests_6_mul_complexd_val" 
+
+external cstubs_tests_7_add_complexf_val
+  : Complex.t -> Complex.t -> Complex.t = "cstubs_tests_7_add_complexf_val" 
+
+external cstubs_tests_8_mul_complexf_val
+  : Complex.t -> Complex.t -> Complex.t = "cstubs_tests_8_mul_complexf_val" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "mul_complexf_val",
+  CI.Function
+    (CI.Primitive CI.Complex32,
+     CI.Function
+       (CI.Primitive CI.Complex32, CI.Returns (CI.Primitive CI.Complex32))) ->
+  cstubs_tests_8_mul_complexf_val
+| "add_complexf_val",
+  CI.Function
+    (CI.Primitive CI.Complex32,
+     CI.Function
+       (CI.Primitive CI.Complex32, CI.Returns (CI.Primitive CI.Complex32))) ->
+  cstubs_tests_7_add_complexf_val
+| "mul_complexd_val",
+  CI.Function
+    (CI.Primitive CI.Complex64,
+     CI.Function
+       (CI.Primitive CI.Complex64, CI.Returns (CI.Primitive CI.Complex64))) ->
+  cstubs_tests_6_mul_complexd_val
+| "add_complexd_val",
+  CI.Function
+    (CI.Primitive CI.Complex64,
+     CI.Function
+       (CI.Primitive CI.Complex64, CI.Returns (CI.Primitive CI.Complex64))) ->
+  cstubs_tests_5_add_complexd_val
+| "mul_complexf",
+  CI.Function
+    (CI.Pointer x10,
+     CI.Function
+       (CI.Pointer x12, CI.Function (CI.Pointer x14, CI.Returns CI.Void))) ->
+  (fun x9 x11 x13 ->
+    cstubs_tests_4_mul_complexf (CI.cptr x9) (CI.cptr x11) (CI.cptr x13))
+| "add_complexf",
+  CI.Function
+    (CI.Pointer x16,
+     CI.Function
+       (CI.Pointer x18, CI.Function (CI.Pointer x20, CI.Returns CI.Void))) ->
+  (fun x15 x17 x19 ->
+    cstubs_tests_3_add_complexf (CI.cptr x15) (CI.cptr x17) (CI.cptr x19))
+| "mul_complexd",
+  CI.Function
+    (CI.Pointer x22,
+     CI.Function
+       (CI.Pointer x24, CI.Function (CI.Pointer x26, CI.Returns CI.Void))) ->
+  (fun x21 x23 x25 ->
+    cstubs_tests_2_mul_complexd (CI.cptr x21) (CI.cptr x23) (CI.cptr x25))
+| "add_complexd",
+  CI.Function
+    (CI.Pointer x28,
+     CI.Function
+       (CI.Pointer x30, CI.Function (CI.Pointer x32, CI.Returns CI.Void))) ->
+  (fun x27 x29 x31 ->
+    cstubs_tests_1_add_complexd (CI.cptr x27) (CI.cptr x29) (CI.cptr x31))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-complex/generated_stubs.c ./tests/test-complex/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-complex/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-complex/generated_stubs.c	2014-10-07 17:44:53.000000000 +0000
@@ -0,0 +1,64 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_add_complexd(value x3, value x2, value x1)
+{
+   double _Complex* x4 = CTYPES_ADDR_OF_FATPTR(x3);
+   double _Complex* x5 = CTYPES_ADDR_OF_FATPTR(x2);
+   double _Complex* x6 = CTYPES_ADDR_OF_FATPTR(x1);
+   add_complexd(x4, x5, x6);
+   return Val_unit;
+}
+value cstubs_tests_2_mul_complexd(value x10, value x9, value x8)
+{
+   double _Complex* x11 = CTYPES_ADDR_OF_FATPTR(x10);
+   double _Complex* x12 = CTYPES_ADDR_OF_FATPTR(x9);
+   double _Complex* x13 = CTYPES_ADDR_OF_FATPTR(x8);
+   mul_complexd(x11, x12, x13);
+   return Val_unit;
+}
+value cstubs_tests_3_add_complexf(value x17, value x16, value x15)
+{
+   float _Complex* x18 = CTYPES_ADDR_OF_FATPTR(x17);
+   float _Complex* x19 = CTYPES_ADDR_OF_FATPTR(x16);
+   float _Complex* x20 = CTYPES_ADDR_OF_FATPTR(x15);
+   add_complexf(x18, x19, x20);
+   return Val_unit;
+}
+value cstubs_tests_4_mul_complexf(value x24, value x23, value x22)
+{
+   float _Complex* x25 = CTYPES_ADDR_OF_FATPTR(x24);
+   float _Complex* x26 = CTYPES_ADDR_OF_FATPTR(x23);
+   float _Complex* x27 = CTYPES_ADDR_OF_FATPTR(x22);
+   mul_complexf(x25, x26, x27);
+   return Val_unit;
+}
+value cstubs_tests_5_add_complexd_val(value x30, value x29)
+{
+   double _Complex x31 = ctypes_double_complex_val(x30);
+   double _Complex x34 = ctypes_double_complex_val(x29);
+   double _Complex x37 = add_complexd_val(x31, x34);
+   return ctypes_copy_double_complex(x37);
+}
+value cstubs_tests_6_mul_complexd_val(value x39, value x38)
+{
+   double _Complex x40 = ctypes_double_complex_val(x39);
+   double _Complex x43 = ctypes_double_complex_val(x38);
+   double _Complex x46 = mul_complexd_val(x40, x43);
+   return ctypes_copy_double_complex(x46);
+}
+value cstubs_tests_7_add_complexf_val(value x48, value x47)
+{
+   float _Complex x49 = ctypes_float_complex_val(x48);
+   float _Complex x52 = ctypes_float_complex_val(x47);
+   float _Complex x55 = add_complexf_val(x49, x52);
+   return ctypes_copy_float_complex(x55);
+}
+value cstubs_tests_8_mul_complexf_val(value x57, value x56)
+{
+   float _Complex x58 = ctypes_float_complex_val(x57);
+   float _Complex x61 = ctypes_float_complex_val(x56);
+   float _Complex x64 = mul_complexf_val(x58, x61);
+   return ctypes_copy_float_complex(x64);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-complex/test_complex.ml ./tests/test-complex/test_complex.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-complex/test_complex.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-complex/test_complex.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -23,7 +23,7 @@
     Arguments and return values are currently mediated through pointers,
     since libffi doesn't support passing complex numbers.
   *)
-  let test_complex_primitive_operations () =
+  let test_complex_primitive_operations _ =
     let wrap typ f l r =
       let rv = allocate_n ~count:1 typ in
       f (allocate typ l) (allocate typ r) rv;
@@ -68,7 +68,7 @@
   (*
     Test primitive operations on complex numbers passed by value.
   *)
-  let test_complex_primitive_value_operations () =
+  let test_complex_primitive_value_operations _ =
     begin
       let open Complex in
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-cstdlib/generated_bindings.ml ./tests/test-cstdlib/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-cstdlib/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-cstdlib/generated_bindings.ml	2014-10-07 17:44:46.000000000 +0000
@@ -0,0 +1,171 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_isalnum : int -> int = "cstubs_tests_1_isalnum" 
+
+external cstubs_tests_2_isalpha : int -> int = "cstubs_tests_2_isalpha" 
+
+external cstubs_tests_3_iscntrl : int -> int = "cstubs_tests_3_iscntrl" 
+
+external cstubs_tests_4_isdigit : int -> int = "cstubs_tests_4_isdigit" 
+
+external cstubs_tests_5_isgraph : int -> int = "cstubs_tests_5_isgraph" 
+
+external cstubs_tests_6_islower : int -> int = "cstubs_tests_6_islower" 
+
+external cstubs_tests_7_isprint : int -> int = "cstubs_tests_7_isprint" 
+
+external cstubs_tests_8_ispunct : int -> int = "cstubs_tests_8_ispunct" 
+
+external cstubs_tests_9_isspace : int -> int = "cstubs_tests_9_isspace" 
+
+external cstubs_tests_10_isupper : int -> int = "cstubs_tests_10_isupper" 
+
+external cstubs_tests_11_isxdigit : int -> int = "cstubs_tests_11_isxdigit" 
+
+external cstubs_tests_12_strchr : _ CI.fatptr -> int -> CI.voidp
+  = "cstubs_tests_12_strchr" 
+
+external cstubs_tests_13_strcmp : _ CI.fatptr -> _ CI.fatptr -> int
+  = "cstubs_tests_13_strcmp" 
+
+external cstubs_tests_14_memcmp
+  : _ CI.fatptr -> _ CI.fatptr -> Unsigned.size_t -> int
+  = "cstubs_tests_14_memcmp" 
+
+external cstubs_tests_15_memset
+  : _ CI.fatptr -> int -> Unsigned.size_t -> CI.voidp
+  = "cstubs_tests_15_memset" 
+
+external cstubs_tests_16_qsort
+  : _ CI.fatptr -> Unsigned.size_t -> Unsigned.size_t -> _ CI.fatptr -> unit
+  = "cstubs_tests_16_qsort" 
+
+external cstubs_tests_17_bsearch
+  : _ CI.fatptr -> _ CI.fatptr -> Unsigned.size_t -> Unsigned.size_t ->
+    _ CI.fatptr -> CI.voidp = "cstubs_tests_17_bsearch" 
+
+external cstubs_tests_18_strlen : _ CI.fatptr -> Unsigned.size_t
+  = "cstubs_tests_18_strlen" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "strlen", CI.Function (CI.Pointer x2, CI.Returns (CI.Primitive CI.Size_t)) ->
+  (fun x1 -> cstubs_tests_18_strlen (CI.cptr x1))
+| "bsearch",
+  CI.Function
+    (CI.Pointer x4,
+     CI.Function
+       (CI.Pointer x6,
+        CI.Function
+          (CI.Primitive CI.Size_t,
+           CI.Function
+             (CI.Primitive CI.Size_t,
+              CI.Function
+                (CI.View {CI.ty = CI.Pointer x11; write = x10; },
+                 CI.Returns (CI.Pointer x12)))))) ->
+  (fun x3 x5 x7 x8 x9 ->
+    CI.make_ptr x12
+      (cstubs_tests_17_bsearch (CI.cptr x3) (CI.cptr x5) x7 x8
+        (CI.cptr (x10 x9))))
+| "qsort",
+  CI.Function
+    (CI.Pointer x14,
+     CI.Function
+       (CI.Primitive CI.Size_t,
+        CI.Function
+          (CI.Primitive CI.Size_t,
+           CI.Function
+             (CI.View {CI.ty = CI.Pointer x19; write = x18; },
+              CI.Returns CI.Void)))) ->
+  (fun x13 x15 x16 x17 ->
+    cstubs_tests_16_qsort (CI.cptr x13) x15 x16 (CI.cptr (x18 x17)))
+| "memset",
+  CI.Function
+    (CI.Pointer x21,
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Function (CI.Primitive CI.Size_t, CI.Returns (CI.Pointer x24)))) ->
+  (fun x20 x22 x23 ->
+    CI.make_ptr x24 (cstubs_tests_15_memset (CI.cptr x20) x22 x23))
+| "memcmp",
+  CI.Function
+    (CI.Pointer x26,
+     CI.Function
+       (CI.Pointer x28,
+        CI.Function
+          (CI.Primitive CI.Size_t, CI.Returns (CI.Primitive CI.Int)))) ->
+  (fun x25 x27 x29 -> cstubs_tests_14_memcmp (CI.cptr x25) (CI.cptr x27) x29)
+| "strcmp",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x32; write = x31; },
+     CI.Function
+       (CI.View {CI.ty = CI.Pointer x35; write = x34; },
+        CI.Returns (CI.Primitive CI.Int))) ->
+  (fun x30 x33 ->
+    cstubs_tests_13_strcmp (CI.cptr (x31 x30)) (CI.cptr (x34 x33)))
+| "strchr",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x38; write = x37; },
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Returns (CI.View {CI.ty = CI.Pointer x40; read = x41; }))) ->
+  (fun x36 x39 ->
+    x41 (CI.make_ptr x40 (cstubs_tests_12_strchr (CI.cptr (x37 x36)) x39)))
+| "isxdigit",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x43; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x44; })) ->
+  (fun x42 -> x44 (cstubs_tests_11_isxdigit (x43 x42)))
+| "isupper",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x46; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x47; })) ->
+  (fun x45 -> x47 (cstubs_tests_10_isupper (x46 x45)))
+| "isspace",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x49; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x50; })) ->
+  (fun x48 -> x50 (cstubs_tests_9_isspace (x49 x48)))
+| "ispunct",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x52; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x53; })) ->
+  (fun x51 -> x53 (cstubs_tests_8_ispunct (x52 x51)))
+| "isprint",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x55; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x56; })) ->
+  (fun x54 -> x56 (cstubs_tests_7_isprint (x55 x54)))
+| "islower",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x58; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x59; })) ->
+  (fun x57 -> x59 (cstubs_tests_6_islower (x58 x57)))
+| "isgraph",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x61; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x62; })) ->
+  (fun x60 -> x62 (cstubs_tests_5_isgraph (x61 x60)))
+| "isdigit",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x64; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x65; })) ->
+  (fun x63 -> x65 (cstubs_tests_4_isdigit (x64 x63)))
+| "iscntrl",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x67; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x68; })) ->
+  (fun x66 -> x68 (cstubs_tests_3_iscntrl (x67 x66)))
+| "isalpha",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x70; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x71; })) ->
+  (fun x69 -> x71 (cstubs_tests_2_isalpha (x70 x69)))
+| "isalnum",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x73; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x74; })) ->
+  (fun x72 -> x74 (cstubs_tests_1_isalnum (x73 x72)))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-cstdlib/generated_stubs.c ./tests/test-cstdlib/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-cstdlib/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-cstdlib/generated_stubs.c	2014-10-07 17:44:46.000000000 +0000
@@ -0,0 +1,130 @@
+#include "clib/test_functions.h"
+
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_isalnum(value x1)
+{
+   int x2 = Int_val(x1);
+   int x5 = isalnum(x2);
+   return Val_int(x5);
+}
+value cstubs_tests_2_isalpha(value x6)
+{
+   int x7 = Int_val(x6);
+   int x10 = isalpha(x7);
+   return Val_int(x10);
+}
+value cstubs_tests_3_iscntrl(value x11)
+{
+   int x12 = Int_val(x11);
+   int x15 = iscntrl(x12);
+   return Val_int(x15);
+}
+value cstubs_tests_4_isdigit(value x16)
+{
+   int x17 = Int_val(x16);
+   int x20 = isdigit(x17);
+   return Val_int(x20);
+}
+value cstubs_tests_5_isgraph(value x21)
+{
+   int x22 = Int_val(x21);
+   int x25 = isgraph(x22);
+   return Val_int(x25);
+}
+value cstubs_tests_6_islower(value x26)
+{
+   int x27 = Int_val(x26);
+   int x30 = islower(x27);
+   return Val_int(x30);
+}
+value cstubs_tests_7_isprint(value x31)
+{
+   int x32 = Int_val(x31);
+   int x35 = isprint(x32);
+   return Val_int(x35);
+}
+value cstubs_tests_8_ispunct(value x36)
+{
+   int x37 = Int_val(x36);
+   int x40 = ispunct(x37);
+   return Val_int(x40);
+}
+value cstubs_tests_9_isspace(value x41)
+{
+   int x42 = Int_val(x41);
+   int x45 = isspace(x42);
+   return Val_int(x45);
+}
+value cstubs_tests_10_isupper(value x46)
+{
+   int x47 = Int_val(x46);
+   int x50 = isupper(x47);
+   return Val_int(x50);
+}
+value cstubs_tests_11_isxdigit(value x51)
+{
+   int x52 = Int_val(x51);
+   int x55 = isxdigit(x52);
+   return Val_int(x55);
+}
+value cstubs_tests_12_strchr(value x57, value x56)
+{
+   char* x58 = CTYPES_ADDR_OF_FATPTR(x57);
+   int x59 = Int_val(x56);
+   char* x62 = strchr(x58, x59);
+   return CTYPES_FROM_PTR(x62);
+}
+value cstubs_tests_13_strcmp(value x64, value x63)
+{
+   char* x65 = CTYPES_ADDR_OF_FATPTR(x64);
+   char* x66 = CTYPES_ADDR_OF_FATPTR(x63);
+   int x67 = strcmp(x65, x66);
+   return Val_int(x67);
+}
+value cstubs_tests_14_memcmp(value x70, value x69, value x68)
+{
+   void* x71 = CTYPES_ADDR_OF_FATPTR(x70);
+   void* x72 = CTYPES_ADDR_OF_FATPTR(x69);
+   size_t x73 = ctypes_size_t_val(x68);
+   int x76 = memcmp(x71, x72, x73);
+   return Val_int(x76);
+}
+value cstubs_tests_15_memset(value x79, value x78, value x77)
+{
+   void* x80 = CTYPES_ADDR_OF_FATPTR(x79);
+   int x81 = Int_val(x78);
+   size_t x84 = ctypes_size_t_val(x77);
+   void* x87 = memset(x80, x81, x84);
+   return CTYPES_FROM_PTR(x87);
+}
+value cstubs_tests_16_qsort(value x91, value x90, value x89, value x88)
+{
+   void* x92 = CTYPES_ADDR_OF_FATPTR(x91);
+   size_t x93 = ctypes_size_t_val(x90);
+   size_t x96 = ctypes_size_t_val(x89);
+   int(* x99)(void*, void*) = CTYPES_ADDR_OF_FATPTR(x88);
+   qsort(x92, x93, x96, x99);
+   return Val_unit;
+}
+value cstubs_tests_17_bsearch(value x105, value x104, value x103, value x102,
+                              value x101)
+{
+   void* x106 = CTYPES_ADDR_OF_FATPTR(x105);
+   void* x107 = CTYPES_ADDR_OF_FATPTR(x104);
+   size_t x108 = ctypes_size_t_val(x103);
+   size_t x111 = ctypes_size_t_val(x102);
+   int(* x114)(void*, void*) = CTYPES_ADDR_OF_FATPTR(x101);
+   void* x115 = bsearch(x106, x107, x108, x111, x114);
+   return CTYPES_FROM_PTR(x115);
+}
+value cstubs_tests_18_strlen(value x116)
+{
+   char* x117 = CTYPES_ADDR_OF_FATPTR(x116);
+   size_t x118 = strlen(x117);
+   return ctypes_copy_size_t(x118);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-cstdlib/test_cstdlib.ml ./tests/test-cstdlib/test_cstdlib.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-cstdlib/test_cstdlib.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-cstdlib/test_cstdlib.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Unsigned
 open Foreign
@@ -31,7 +31,7 @@
        int isisupper(int)
        int isisxdigit(int)
   *)
-  let test_isX_functions () =
+  let test_isX_functions _ =
     begin
       assert_bool "" (isalnum 'a');
       assert_bool "" (not (isalnum ' '));
@@ -74,7 +74,7 @@
       char *strchr(const char *str, int c);
       int strcmp(const char *str1, const char *str2);
   *)
-  let test_string_functions () =
+  let test_string_functions _ =
     assert_equal "efg" (strchr "abcdefg" (Char.code 'e'))
       ~printer:(fun x -> x);
 
@@ -110,7 +110,7 @@
        void qsort(void *base, size_t nmemb, size_t size,
                   int(*compar)(const void *, const void *));
   *)
-  let test_qsort () =
+  let test_qsort _ =
     let sortby (type a) (typ : a typ) (f : a -> a -> int) (l : a list) =
       let open CArray in
       let open Size_t in
@@ -143,7 +143,7 @@
                      size_t nmemb, size_t size,
                      int (*compar)(const void *, const void *));
   *)
-  let test_bsearch () =
+  let test_bsearch _ =
     let module M = struct
       (*
         struct mi {
@@ -173,12 +173,12 @@
         arr.(len) <- '\000';
         arr
 
-    let as_string : char ptr -> string =
+    let as_string : char ptr -> Bytes.t =
       fun p ->
         let len = Size_t.to_int (strlen p) in
-        let s = String.create len in
+        let s = Bytes.create len in
         for i = 0 to len - 1 do
-          s.[i] <- !@(p +@ i);
+          Bytes.set s i (!@(p +@ i));
         done;
         s
 
@@ -284,7 +284,7 @@
         int rem;			/* Remainder.  */
       } div_t;
 *)
-let test_div () =
+let test_div _ =
   let module M = struct
     type div_t
     let div_t : div_t structure typ = structure "div_t"
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-custom_ops/test_custom_ops.ml ./tests/test-custom_ops/test_custom_ops.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-custom_ops/test_custom_ops.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-custom_ops/test_custom_ops.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 let hash = Hashtbl.hash
@@ -18,7 +18,7 @@
   objects, so even structurally-equal values should have different
   hashes and compare unequal.
 *)
-let test_managed_buffer_hashing_and_equality () =
+let test_managed_buffer_hashing_and_equality _ =
   let i1 = allocate int 20 in
   let i2 = allocate int 20 in
   assert_equal !@i1 !@i2;
@@ -38,7 +38,7 @@
   should have equal hashes and compare equal.
 *)
 
-let test_type_info_hashing_and_equality () =
+let test_type_info_hashing_and_equality _ =
   let module M = struct
     type s
     let s : s structure typ = structure "s"
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-errno/test_errno.ml ./tests/test-errno/test_errno.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-errno/test_errno.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-errno/test_errno.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -13,7 +13,7 @@
    Call fdopendir() with a bogus file descriptor and check that an exception
    is raised.
 *)
-let test_errno_exception_raised () =
+let test_errno_exception_raised _ =
   let close = Foreign.foreign "close" ~check_errno:true
     (int @-> returning int) in
   assert_raises (Unix.Unix_error(Unix.EBADF, "close", ""))
@@ -23,7 +23,7 @@
 (*
   Call chdir() with a valid directory path and check that zero is returned. 
 *)
-let test_int_return_errno_exception_raised () =
+let test_int_return_errno_exception_raised _ =
   let chdir = Foreign.foreign "chdir" ~check_errno:true
     (string @-> returning int) in
   assert_raises (Unix.Unix_error(Unix.ENOENT, "chdir", ""))
@@ -33,7 +33,7 @@
 (*
   Call chdir() with a valid directory path and check that zero is returned. 
 *)
-let test_errno_no_exception_raised () =
+let test_errno_no_exception_raised _ =
   let chdir = Foreign.foreign "chdir" ~check_errno:true
     (string @-> returning int) in
   assert_equal 0 (chdir (Sys.getcwd ()))
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-finalisers/test_finalisers.ml ./tests/test-finalisers/test_finalisers.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-finalisers/test_finalisers.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-finalisers/test_finalisers.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Simple finalisation test for arrays.
 *)
-let test_array_finaliser () =
+let test_array_finaliser _ =
   let module Array = CArray in
   let finaliser_completed = ref false in
   let finalise a =
@@ -44,7 +44,7 @@
 (*
   Simple finalisation test for structs.
 *)
-let test_struct_finaliser () =
+let test_struct_finaliser _ =
   let module M = struct
     type s
     let s : s structure typ = structure "s"
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-foreign_values/test_foreign_values.ml ./tests/test-foreign_values/test_foreign_values.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-foreign_values/test_foreign_values.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-foreign_values/test_foreign_values.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -15,14 +15,14 @@
 (*
   Retrieve a struct exposed as a global value. 
 *)
-let test_retrieving_struct () =
+let test_retrieving_struct _ =
   let s = structure "global_struct" in
   let (-:) ty label = field s label ty in
   let len = size_t       -: "len" in
   let str = array 1 char -: "str" in
   let () = seal s in
   let global_struct = Foreign.foreign_value "global_struct" s ~from:testlib in
-  let p = Array.start (getf !@global_struct str) in
+  let p = CArray.start (getf !@global_struct str) in
   let stringp = from_voidp string (to_voidp (allocate (ptr char) p)) in
   begin
     let expected = "global string" in
@@ -36,7 +36,7 @@
 (*
   Store a reference to an OCaml function as a global function pointer.
 *)
-let test_global_callback () =
+let test_global_callback _ =
   let open Foreign in
 
   let plus =
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/generated_bindings.ml ./tests/test-higher_order/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-higher_order/generated_bindings.ml	2014-10-07 17:44:44.000000000 +0000
@@ -0,0 +1,65 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_higher_order_1 : _ CI.fatptr -> int -> int -> int
+  = "cstubs_tests_1_higher_order_1" 
+
+external cstubs_tests_2_higher_order_3
+  : _ CI.fatptr -> _ CI.fatptr -> int -> int -> int
+  = "cstubs_tests_2_higher_order_3" 
+
+external cstubs_tests_3_returning_funptr : int -> CI.voidp
+  = "cstubs_tests_3_returning_funptr" 
+
+external cstubs_tests_4_callback_returns_funptr : _ CI.fatptr -> int -> int
+  = "cstubs_tests_4_callback_returns_funptr" 
+
+external cstubs_tests_5_register_callback : _ CI.fatptr -> unit
+  = "cstubs_tests_5_register_callback" 
+
+external cstubs_tests_6_call_registered_callback : int -> int -> unit
+  = "cstubs_tests_6_call_registered_callback" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "call_registered_callback",
+  CI.Function
+    (CI.Primitive CI.Int,
+     CI.Function (CI.Primitive CI.Int, CI.Returns CI.Void)) ->
+  cstubs_tests_6_call_registered_callback
+| "register_callback",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x5; write = x4; }, CI.Returns CI.Void) ->
+  (fun x3 -> cstubs_tests_5_register_callback (CI.cptr (x4 x3)))
+| "callback_returns_funptr",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x8; write = x7; },
+     CI.Function (CI.Primitive CI.Int, CI.Returns (CI.Primitive CI.Int))) ->
+  (fun x6 x9 -> cstubs_tests_4_callback_returns_funptr (CI.cptr (x7 x6)) x9)
+| "returning_funptr",
+  CI.Function
+    (CI.Primitive CI.Int,
+     CI.Returns (CI.View {CI.ty = CI.Pointer x11; read = x12; })) ->
+  (fun x10 -> x12 (CI.make_ptr x11 (cstubs_tests_3_returning_funptr x10)))
+| "higher_order_3",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x15; write = x14; },
+     CI.Function
+       (CI.View {CI.ty = CI.Pointer x18; write = x17; },
+        CI.Function
+          (CI.Primitive CI.Int,
+           CI.Function
+             (CI.Primitive CI.Int, CI.Returns (CI.Primitive CI.Int))))) ->
+  (fun x13 x16 x19 x20 ->
+    cstubs_tests_2_higher_order_3 (CI.cptr (x14 x13)) (CI.cptr (x17 x16)) x19
+    x20)
+| "higher_order_1",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x23; write = x22; },
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Function (CI.Primitive CI.Int, CI.Returns (CI.Primitive CI.Int)))) ->
+  (fun x21 x24 x25 ->
+    cstubs_tests_1_higher_order_1 (CI.cptr (x22 x21)) x24 x25)
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/generated_stubs.c ./tests/test-higher_order/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-higher_order/generated_stubs.c	2014-10-07 17:44:44.000000000 +0000
@@ -0,0 +1,48 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_higher_order_1(value x3, value x2, value x1)
+{
+   int(* x4)(int, int) = CTYPES_ADDR_OF_FATPTR(x3);
+   int x5 = Int_val(x2);
+   int x8 = Int_val(x1);
+   int x11 = higher_order_1(x4, x5, x8);
+   return Val_int(x11);
+}
+value cstubs_tests_2_higher_order_3(value x15, value x14, value x13,
+                                    value x12)
+{
+   int(* x16)(int(*)(int, int), int, int) = CTYPES_ADDR_OF_FATPTR(x15);
+   int(* x17)(int, int) = CTYPES_ADDR_OF_FATPTR(x14);
+   int x18 = Int_val(x13);
+   int x21 = Int_val(x12);
+   int x24 = higher_order_3(x16, x17, x18, x21);
+   return Val_int(x24);
+}
+value cstubs_tests_3_returning_funptr(value x25)
+{
+   int x26 = Int_val(x25);
+   int(* x29)(int, int) = returning_funptr(x26);
+   return CTYPES_FROM_PTR(x29);
+}
+value cstubs_tests_4_callback_returns_funptr(value x31, value x30)
+{
+   int(*(* x32)(int))(int) = CTYPES_ADDR_OF_FATPTR(x31);
+   int x33 = Int_val(x30);
+   int x36 = callback_returns_funptr(x32, x33);
+   return Val_int(x36);
+}
+value cstubs_tests_5_register_callback(value x37)
+{
+   int(* x38)(void) = CTYPES_ADDR_OF_FATPTR(x37);
+   register_callback(x38);
+   return Val_unit;
+}
+value cstubs_tests_6_call_registered_callback(value x41, value x40)
+{
+   int x42 = Int_val(x41);
+   int x45 = Int_val(x40);
+   call_registered_callback(x42, x45);
+   return Val_unit;
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/stubs/functions.ml ./tests/test-higher_order/stubs/functions.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/stubs/functions.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-higher_order/stubs/functions.ml	2014-10-06 15:23:14.000000000 +0000
@@ -28,4 +28,10 @@
   let callback_returns_funptr = foreign "callback_returns_funptr"
     (funptr (int @-> returning (funptr (int @-> returning int))) @->
      int @-> returning int)
+
+  let register_callback = foreign "register_callback"
+      (funptr (void @-> returning int) @-> returning void)
+
+  let call_registered_callback = foreign "call_registered_callback"
+      (int @-> int @-> returning void)
 end
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/test_higher_order.ml ./tests/test-higher_order/test_higher_order.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-higher_order/test_higher_order.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-higher_order/test_higher_order.ml	2014-10-06 15:23:14.000000000 +0000
@@ -6,7 +6,7 @@
  *)
 
 open Ctypes
-open OUnit
+open OUnit2
 open Foreign
 
 
@@ -26,7 +26,7 @@
 
      as the first argument.
   *)
-  let test_higher_order_basic () =
+  let test_higher_order_basic _ =
     (* higher_order_1 f x y returns true iff f x y == x + y *)
     assert_equal 1 (higher_order_1 ( + ) 2 3);
     assert_equal 0 (higher_order_1 ( * ) 2 3);
@@ -48,7 +48,7 @@
 
     as the first and second arguments.
   *)
-  let test_higher_higher_order () =
+  let test_higher_higher_order _ =
     let acceptor op x y = op x (op x y) in
     assert_equal 10 (higher_order_3 acceptor ( + ) 3 4);
     assert_equal 36 (higher_order_3 acceptor ( * ) 3 4)
@@ -62,7 +62,7 @@
     (i.e. a function that returns a pointer-to-function) and ensure that we can
     call the returned function from OCaml.
   *)
-  let test_returning_pointer_to_function () =
+  let test_returning_pointer_to_function _ =
     let add = returning_funptr 0 in
 
     let times = returning_funptr 1 in
@@ -81,7 +81,7 @@
     (i.e. a function whose first argument is a pointer-to-function
     returning a pointer-to-function.)
   *)
-  let test_callback_returns_pointer_to_function () =
+  let test_callback_returns_pointer_to_function _ =
     let callback = function
       | 0 -> ( + ) 10
       | 1 -> ( * ) 13
@@ -89,6 +89,24 @@
     in
 
     assert_equal 280 (callback_returns_funptr callback 0)
+
+  (*
+    Call an OCaml function through a C function pointer of type
+
+         void ( * )(void)
+  *)
+  let test_zero_argument_callbacks _ =
+    let counter = ref 0 in
+    let callback () = let c = !counter in incr counter; c in
+    let () = register_callback callback in
+
+    begin
+      assert_equal !counter 0;
+      call_registered_callback 5 !counter;
+      assert_equal !counter 5;
+      call_registered_callback 3 !counter;
+      assert_equal !counter 8;
+    end
 end
 
 
@@ -120,6 +138,12 @@
 
    "test_callback_returns_pointer_to_function (stubs)"
    >:: Stub_tests.test_callback_returns_pointer_to_function;
+
+   "test_zero_argument_callbacks (foreign)"
+   >:: Foreign_tests.test_zero_argument_callbacks;
+
+   "test_zero_argument_callbacks (stubs)"
+   >:: Stub_tests.test_zero_argument_callbacks;
   ]
 
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-macros/generated_bindings.ml ./tests/test-macros/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-macros/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-macros/generated_bindings.ml	2014-10-07 17:44:43.000000000 +0000
@@ -0,0 +1,17 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_exp : float -> float = "cstubs_tests_1_exp" 
+
+external cstubs_tests_2_exp : float -> float = "cstubs_tests_2_exp" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "exp",
+  CI.Function (CI.Primitive CI.Float, CI.Returns (CI.Primitive CI.Float)) ->
+  cstubs_tests_2_exp
+| "exp",
+  CI.Function (CI.Primitive CI.Double, CI.Returns (CI.Primitive CI.Double)) ->
+  cstubs_tests_1_exp
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-macros/generated_stubs.c ./tests/test-macros/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-macros/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-macros/generated_stubs.c	2014-10-07 17:44:43.000000000 +0000
@@ -0,0 +1,18 @@
+#include "clib/test_functions.h"
+
+#include <tgmath.h>
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_exp(value x1)
+{
+   double x2 = Double_val(x1);
+   double x5 = exp(x2);
+   return caml_copy_double(x5);
+}
+value cstubs_tests_2_exp(value x6)
+{
+   double x7 = Double_val(x6);
+   float x10 = exp((float)x7);
+   return caml_copy_double(x10);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-macros/test_macros.ml ./tests/test-macros/test_macros.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-macros/test_macros.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-macros/test_macros.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 module Bindings = Functions.Stubs(Generated_bindings)
@@ -13,7 +13,7 @@
 (*
   Test calling type-generic macros.
 *)
-let test_tg_macros () =
+let test_tg_macros _ =
   let open Bindings in
   assert_bool "calling double version of type-generic exp"
     (exp_double 1.0 = exp 1.0);
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-oo_style/generated_bindings.ml ./tests/test-oo_style/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-oo_style/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-oo_style/generated_bindings.ml	2014-10-07 17:44:51.000000000 +0000
@@ -0,0 +1,22 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_check_name : _ CI.fatptr -> _ CI.fatptr -> int
+  = "cstubs_tests_1_check_name" 
+
+external cstubs_tests_2_new_chorse : int -> CI.voidp
+  = "cstubs_tests_2_new_chorse" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "new_chorse", CI.Function (CI.Primitive CI.Int, CI.Returns (CI.Pointer x2)) ->
+  (fun x1 -> CI.make_ptr x2 (cstubs_tests_2_new_chorse x1))
+| "check_name",
+  CI.Function
+    (CI.Pointer x4,
+     CI.Function
+       (CI.View {CI.ty = CI.Pointer x7; write = x6; },
+        CI.Returns (CI.Primitive CI.Int))) ->
+  (fun x3 x5 -> cstubs_tests_1_check_name (CI.cptr x3) (CI.cptr (x6 x5)))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-oo_style/generated_stubs.c ./tests/test-oo_style/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-oo_style/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-oo_style/generated_stubs.c	2014-10-07 17:44:51.000000000 +0000
@@ -0,0 +1,17 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_check_name(value x2, value x1)
+{
+   struct animal* x3 = CTYPES_ADDR_OF_FATPTR(x2);
+   char* x4 = CTYPES_ADDR_OF_FATPTR(x1);
+   int x5 = check_name(x3, x4);
+   return Val_int(x5);
+}
+value cstubs_tests_2_new_chorse(value x6)
+{
+   int x7 = Int_val(x6);
+   struct animal* x10 = new_chorse(x7);
+   return CTYPES_FROM_PTR(x10);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-oo_style/test_oo_style.ml ./tests/test-oo_style/test_oo_style.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-oo_style/test_oo_style.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-oo_style/test_oo_style.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -18,7 +18,7 @@
      Establish a hierarchy of "classes", create some "objects" and call some
      "methods".
   *)
-  let test_oo_hierarchy () =
+  let test_oo_hierarchy _ =
     let module M = struct
 
       let camel_vtable_singleton = make camel_methods
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-passable/test_passable.ml ./tests/test-passable/test_passable.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-passable/test_passable.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-passable/test_passable.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Test that primitives are passable.
 *)
-let test_primitives_are_passable () =
+let test_primitives_are_passable _ =
   let _ = void @-> returning void 
   and _ = char @-> returning char
   and _ = schar @-> returning schar
@@ -41,7 +41,7 @@
 (*
   Test that unions are not passable
 *)
-let test_unions_are_not_passable () =
+let test_unions_are_not_passable _ =
   let module M = struct
     type u
 
@@ -73,7 +73,7 @@
 (*
   Test the passability of complex values
 *)
-let test_complex_value_passability () =
+let test_complex_value_passability _ =
   (* complex32 can be used as an argument type *)
   ignore (complex32 @-> returning void);
 
@@ -106,7 +106,7 @@
 (*
   Test that arrays are not passable
 *)
-let test_arrays_are_not_passable () =
+let test_arrays_are_not_passable _ =
   assert_raises ~msg:"Array type rejected as argument"
     (Unsupported "Unsupported argument type")
     (fun () -> array 1 int @-> returning void);
@@ -119,7 +119,7 @@
 (*
   Test that bigarrays are not passable
 *)
-let test_bigarrays_are_not_passable () =
+let test_bigarrays_are_not_passable _ =
   assert_raises ~msg:"bigarray type rejected as argument"
     (Unsupported "Unsupported argument type")
     (fun () -> bigarray genarray [|1|] Bigarray.int @-> returning void);
@@ -156,7 +156,7 @@
 (*
   Test that pointers are passable
 *)
-let test_pointers_are_passable () =
+let test_pointers_are_passable _ =
   (* Pointers to primitives are passable *)
   let _ = ptr void @-> returning (ptr void)
   and _ = ptr int @-> returning (ptr int)
@@ -186,7 +186,7 @@
 (*
   Test that function pointers are passable
 *)
-let test_function_pointers_are_passable () =
+let test_function_pointers_are_passable _ =
   (* Pointers to primitives are passable *)
   ignore (Foreign.funptr (int @-> returning int)
           @-> returning (Foreign.funptr (int @-> returning int)))
@@ -195,7 +195,7 @@
 (*
   Test that values of abstract types are not passable
 *)
-let test_abstract_values_are_not_passable () = begin
+let test_abstract_values_are_not_passable _ = begin
   assert_raises ~msg:"Abstract type rejected as argument"
     (Unsupported "Unsupported argument type")
     (fun () ->
@@ -212,7 +212,7 @@
   Test struct passability.  Structs are passable unless they contain
   unpassable members (unions, arrays, abstract types, or unpassable structs).
 *)
-let test_struct_passability () =
+let test_struct_passability _ =
   let module M = struct
     type s1 and s2 and s3 and s4 and s5 and s6 and u
 
@@ -330,7 +330,7 @@
   Test passability of incomplete types.  Trying to use an incomplete type
   in a function specification should give rise to an error.
 *)
-let test_incomplete_passability () =
+let test_incomplete_passability _ =
   let s = structure "incomplete"
   and u = union "incomplete"
   in begin
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-passing-ocaml-values/generated_bindings.ml ./tests/test-passing-ocaml-values/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-passing-ocaml-values/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-passing-ocaml-values/generated_bindings.ml	2014-10-07 17:44:57.000000000 +0000
@@ -0,0 +1,48 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_memcpy
+  : string CI.ocaml -> string CI.ocaml -> Unsigned.size_t -> CI.voidp
+  = "cstubs_tests_1_memcpy" 
+
+external cstubs_tests_2_memcpy
+  : Bytes.t CI.ocaml -> Bytes.t CI.ocaml -> Unsigned.size_t -> CI.voidp
+  = "cstubs_tests_2_memcpy" 
+
+external cstubs_tests_3_memcpy
+  : string CI.ocaml -> _ CI.fatptr -> Unsigned.size_t -> CI.voidp
+  = "cstubs_tests_3_memcpy" 
+
+external cstubs_tests_4_strdup : string CI.ocaml -> CI.voidp
+  = "cstubs_tests_4_strdup" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "strdup",
+  CI.Function
+    (CI.OCaml CI.String,
+     CI.Returns (CI.View {CI.ty = CI.Pointer x2; read = x3; })) ->
+  (fun x1 -> x3 (CI.make_ptr x2 (cstubs_tests_4_strdup x1)))
+| "memcpy",
+  CI.Function
+    (CI.OCaml CI.String,
+     CI.Function
+       (CI.Pointer x6,
+        CI.Function (CI.Primitive CI.Size_t, CI.Returns (CI.Pointer x8)))) ->
+  (fun x4 x5 x7 -> CI.make_ptr x8 (cstubs_tests_3_memcpy x4 (CI.cptr x5) x7))
+| "memcpy",
+  CI.Function
+    (CI.OCaml CI.Bytes,
+     CI.Function
+       (CI.OCaml CI.Bytes,
+        CI.Function (CI.Primitive CI.Size_t, CI.Returns (CI.Pointer x12)))) ->
+  (fun x9 x10 x11 -> CI.make_ptr x12 (cstubs_tests_2_memcpy x9 x10 x11))
+| "memcpy",
+  CI.Function
+    (CI.OCaml CI.String,
+     CI.Function
+       (CI.OCaml CI.String,
+        CI.Function (CI.Primitive CI.Size_t, CI.Returns (CI.Pointer x16)))) ->
+  (fun x13 x14 x15 -> CI.make_ptr x16 (cstubs_tests_1_memcpy x13 x14 x15))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-passing-ocaml-values/generated_stubs.c ./tests/test-passing-ocaml-values/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-passing-ocaml-values/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-passing-ocaml-values/generated_stubs.c	2014-10-07 17:44:57.000000000 +0000
@@ -0,0 +1,34 @@
+#include "clib/test_functions.h"
+#include <string.h>
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_memcpy(value x3, value x2, value x1)
+{
+   char* x4 = CTYPES_PTR_OF_OCAML_STRING(x3);
+   char* x5 = CTYPES_PTR_OF_OCAML_STRING(x2);
+   size_t x6 = ctypes_size_t_val(x1);
+   void* x9 = memcpy(x4, x5, x6);
+   return CTYPES_FROM_PTR(x9);
+}
+value cstubs_tests_2_memcpy(value x12, value x11, value x10)
+{
+   char* x13 = CTYPES_PTR_OF_OCAML_STRING(x12);
+   char* x14 = CTYPES_PTR_OF_OCAML_STRING(x11);
+   size_t x15 = ctypes_size_t_val(x10);
+   void* x18 = memcpy(x13, x14, x15);
+   return CTYPES_FROM_PTR(x18);
+}
+value cstubs_tests_3_memcpy(value x21, value x20, value x19)
+{
+   char* x22 = CTYPES_PTR_OF_OCAML_STRING(x21);
+   void* x23 = CTYPES_ADDR_OF_FATPTR(x20);
+   size_t x24 = ctypes_size_t_val(x19);
+   void* x27 = memcpy(x22, x23, x24);
+   return CTYPES_FROM_PTR(x27);
+}
+value cstubs_tests_4_strdup(value x28)
+{
+   char* x29 = CTYPES_PTR_OF_OCAML_STRING(x28);
+   char* x30 = strdup(x29);
+   return CTYPES_FROM_PTR(x30);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-passing-ocaml-values/test_passing_ocaml_values.ml ./tests/test-passing-ocaml-values/test_passing_ocaml_values.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-passing-ocaml-values/test_passing_ocaml_values.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-passing-ocaml-values/test_passing_ocaml_values.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
@@ -20,10 +20,10 @@
   (*
     Test passing OCaml strings directly to C.
   *)
-  let test_passing_strings () =
+  let test_passing_strings _ =
     let input = "abcdefghijklmnopqrstuvwxyz" in
     let len = String.length input in
-    let buf = String.create len in
+    let buf = String.make len 'Z' in
     let _ = memcpy_string_string
       (ocaml_string_start buf)
       (ocaml_string_start input)
@@ -33,7 +33,7 @@
     end;
 
     let bbuf = Bytes.create len in
-    let binput = Bytes.unsafe_of_string (String.copy input) in
+    let binput = Bytes.of_string input in
     let _ = memcpy_bytes_bytes
       (ocaml_bytes_start bbuf)
       (ocaml_bytes_start binput)
@@ -44,7 +44,7 @@
     
     let arr = CArray.make char len in
     let () = String.iteri (CArray.set arr) input in
-    let buf = String.create len in
+    let buf = String.make len 'Z' in
     let _ = memcpy_string_ptr
       (ocaml_string_start buf)
       (coerce (ptr char) (ptr void) (CArray.start arr))
@@ -54,29 +54,29 @@
     end
 
 
-    (*
-      Test pointer arithmetic on OCaml values.
-    *)
-    let test_pointer_arithmetic () =
-      let s = ocaml_string_start "abcdefghijklmnopqrstuvwxyz" in
-      begin
-        assert_equal s (s +@ 0);
-
-        assert_equal (ptr_diff s (s +@ 10)) 10;
-
-        assert_equal s ((s +@ 10) -@ 10);
-
-        assert_equal
-          (strdup (ocaml_string_start "klmnopqrstuvwxyz"))
-          (strdup (s +@ 10))
-      end
+  (*
+    Test pointer arithmetic on OCaml values.
+   *)
+  let test_pointer_arithmetic _ =
+    let s = ocaml_string_start "abcdefghijklmnopqrstuvwxyz" in
+    begin
+      assert_equal s (s +@ 0);
+
+      assert_equal (ptr_diff s (s +@ 10)) 10;
+
+      assert_equal s ((s +@ 10) -@ 10);
+
+      assert_equal
+        (strdup (ocaml_string_start "klmnopqrstuvwxyz"))
+        (strdup (s +@ 10))
+    end
 end
 
 
 (*
   Test that OCaml values do not reside in addressable memory.
 *)
-let test_ocaml_types_rejected_as_pointer_reference_types () =
+let test_ocaml_types_rejected_as_pointer_reference_types _ =
   assert_raises IncompleteType
     (fun () -> allocate ocaml_string (ocaml_string_start ""))
 
@@ -84,7 +84,7 @@
 (*
   Test that OCaml values cannot be used as return types.
 *)
-let test_ocaml_types_rejected_as_return_types () =
+let test_ocaml_types_rejected_as_return_types _ =
   assert_raises IncompleteType
     (fun () -> Foreign.foreign "strdup" (string @-> returning ocaml_string))
 
@@ -92,7 +92,7 @@
 (*
   Test that pointers to OCaml values cannot be dereferenced.
 *)
-let test_pointers_to_ocaml_types_cannot_be_dereferenced () =
+let test_pointers_to_ocaml_types_cannot_be_dereferenced _ =
   let p = allocate_n char 10 in
   let po = coerce (ptr char) (ptr ocaml_string) p in
 
@@ -108,7 +108,7 @@
 (*
   Test that [funptr] does not support ocaml_string return values.
 *)
-let test_no_higher_order_ocaml_string_support () =
+let test_no_higher_order_ocaml_string_support _ =
   begin
     assert_raises IncompleteType
       (fun () -> funptr (void @-> returning ocaml_string))
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-pointers/generated_bindings.ml ./tests/test-pointers/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-pointers/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-pointers/generated_bindings.ml	2014-10-07 17:44:40.000000000 +0000
@@ -0,0 +1,149 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_accept_pointers
+  : _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr ->
+    _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr ->
+    _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr ->
+    _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr ->
+    _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> int
+  = "cstubs_tests_1_accept_pointers_byte20" "cstubs_tests_1_accept_pointers" 
+
+external cstubs_tests_2_accept_pointers_to_pointers
+  : _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> _ CI.fatptr -> int
+  = "cstubs_tests_2_accept_pointers_to_pointers" 
+
+external cstubs_tests_3_malloc : Unsigned.size_t -> CI.voidp
+  = "cstubs_tests_3_malloc" 
+
+external cstubs_tests_4_realloc : _ CI.fatptr -> Unsigned.size_t -> CI.voidp
+  = "cstubs_tests_4_realloc" 
+
+external cstubs_tests_5_free : _ CI.fatptr -> unit = "cstubs_tests_5_free" 
+
+external cstubs_tests_6_return_global_address : unit -> CI.voidp
+  = "cstubs_tests_6_return_global_address" 
+
+external cstubs_tests_7_pass_pointer_through
+  : _ CI.fatptr -> _ CI.fatptr -> int -> CI.voidp
+  = "cstubs_tests_7_pass_pointer_through" 
+
+external cstubs_tests_8_passing_pointers_to_callback : _ CI.fatptr -> int
+  = "cstubs_tests_8_passing_pointers_to_callback" 
+
+external cstubs_tests_9_accepting_pointer_from_callback : _ CI.fatptr -> int
+  = "cstubs_tests_9_accepting_pointer_from_callback" 
+
+external cstubs_tests_10_accepting_pointer_to_function_pointer
+  : _ CI.fatptr -> int
+  = "cstubs_tests_10_accepting_pointer_to_function_pointer" 
+
+external cstubs_tests_11_returning_pointer_to_function_pointer
+  : unit -> CI.voidp
+  = "cstubs_tests_11_returning_pointer_to_function_pointer" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "returning_pointer_to_function_pointer",
+  CI.Function (CI.Void, CI.Returns (CI.Pointer x2)) ->
+  (fun x1 ->
+    CI.make_ptr x2 (cstubs_tests_11_returning_pointer_to_function_pointer x1))
+| "accepting_pointer_to_function_pointer",
+  CI.Function (CI.Pointer x4, CI.Returns (CI.Primitive CI.Int)) ->
+  (fun x3 ->
+    cstubs_tests_10_accepting_pointer_to_function_pointer (CI.cptr x3))
+| "accepting_pointer_from_callback",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x7; write = x6; },
+     CI.Returns (CI.Primitive CI.Int)) ->
+  (fun x5 ->
+    cstubs_tests_9_accepting_pointer_from_callback (CI.cptr (x6 x5)))
+| "passing_pointers_to_callback",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x10; write = x9; },
+     CI.Returns (CI.Primitive CI.Int)) ->
+  (fun x8 -> cstubs_tests_8_passing_pointers_to_callback (CI.cptr (x9 x8)))
+| "pass_pointer_through",
+  CI.Function
+    (CI.Pointer x12,
+     CI.Function
+       (CI.Pointer x14,
+        CI.Function (CI.Primitive CI.Int, CI.Returns (CI.Pointer x16)))) ->
+  (fun x11 x13 x15 ->
+    CI.make_ptr x16
+      (cstubs_tests_7_pass_pointer_through (CI.cptr x11) (CI.cptr x13) x15))
+| "return_global_address", CI.Function (CI.Void, CI.Returns (CI.Pointer x18)) ->
+  (fun x17 -> CI.make_ptr x18 (cstubs_tests_6_return_global_address x17))
+| "free", CI.Function (CI.Pointer x20, CI.Returns CI.Void) ->
+  (fun x19 -> cstubs_tests_5_free (CI.cptr x19))
+| "realloc",
+  CI.Function
+    (CI.Pointer x22,
+     CI.Function (CI.Primitive CI.Size_t, CI.Returns (CI.Pointer x24))) ->
+  (fun x21 x23 -> CI.make_ptr x24 (cstubs_tests_4_realloc (CI.cptr x21) x23))
+| "malloc", CI.Function (CI.Primitive CI.Size_t, CI.Returns (CI.Pointer x26)) ->
+  (fun x25 -> CI.make_ptr x26 (cstubs_tests_3_malloc x25))
+| "accept_pointers_to_pointers",
+  CI.Function
+    (CI.Pointer x28,
+     CI.Function
+       (CI.Pointer x30,
+        CI.Function
+          (CI.Pointer x32,
+           CI.Function (CI.Pointer x34, CI.Returns (CI.Primitive CI.Int))))) ->
+  (fun x27 x29 x31 x33 ->
+    cstubs_tests_2_accept_pointers_to_pointers (CI.cptr x27) (CI.cptr x29)
+    (CI.cptr x31) (CI.cptr x33))
+| "accept_pointers",
+  CI.Function
+    (CI.Pointer x36,
+     CI.Function
+       (CI.Pointer x38,
+        CI.Function
+          (CI.Pointer x40,
+           CI.Function
+             (CI.Pointer x42,
+              CI.Function
+                (CI.Pointer x44,
+                 CI.Function
+                   (CI.Pointer x46,
+                    CI.Function
+                      (CI.Pointer x48,
+                       CI.Function
+                         (CI.Pointer x50,
+                          CI.Function
+                            (CI.Pointer x52,
+                             CI.Function
+                               (CI.Pointer x54,
+                                CI.Function
+                                  (CI.Pointer x56,
+                                   CI.Function
+                                     (CI.Pointer x58,
+                                      CI.Function
+                                        (CI.Pointer x60,
+                                         CI.Function
+                                           (CI.Pointer x62,
+                                            CI.Function
+                                              (CI.Pointer x64,
+                                               CI.Function
+                                                 (CI.Pointer x66,
+                                                  CI.Function
+                                                    (CI.Pointer x68,
+                                                     CI.Function
+                                                       (CI.Pointer x70,
+                                                        CI.Function
+                                                          (CI.Pointer x72,
+                                                           CI.Function
+                                                             (CI.Pointer x74,
+                                                              CI.Returns
+                                                                (CI.Primitive
+                                                                   CI.Int))))))))))))))))))))) ->
+  (fun x35 x37 x39 x41 x43 x45 x47 x49 x51 x53 x55 x57 x59 x61 x63 x65 x67
+    x69 x71 x73 ->
+    cstubs_tests_1_accept_pointers (CI.cptr x35) (CI.cptr x37) (CI.cptr x39)
+    (CI.cptr x41) (CI.cptr x43) (CI.cptr x45) (CI.cptr x47) (CI.cptr x49)
+    (CI.cptr x51) (CI.cptr x53) (CI.cptr x55) (CI.cptr x57) (CI.cptr x59)
+    (CI.cptr x61) (CI.cptr x63) (CI.cptr x65) (CI.cptr x67) (CI.cptr x69)
+    (CI.cptr x71) (CI.cptr x73))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-pointers/generated_stubs.c ./tests/test-pointers/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-pointers/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-pointers/generated_stubs.c	2014-10-07 17:44:40.000000000 +0000
@@ -0,0 +1,128 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_accept_pointers(value x20, value x19, value x18,
+                                     value x17, value x16, value x15,
+                                     value x14, value x13, value x12,
+                                     value x11, value x10, value x9,
+                                     value x8, value x7, value x6, value x5,
+                                     value x4, value x3, value x2, value x1)
+{
+   float* x21 = CTYPES_ADDR_OF_FATPTR(x20);
+   double* x22 = CTYPES_ADDR_OF_FATPTR(x19);
+   short* x23 = CTYPES_ADDR_OF_FATPTR(x18);
+   int* x24 = CTYPES_ADDR_OF_FATPTR(x17);
+   long* x25 = CTYPES_ADDR_OF_FATPTR(x16);
+   long long* x26 = CTYPES_ADDR_OF_FATPTR(x15);
+   intnat* x27 = CTYPES_ADDR_OF_FATPTR(x14);
+   int8_t* x28 = CTYPES_ADDR_OF_FATPTR(x13);
+   int16_t* x29 = CTYPES_ADDR_OF_FATPTR(x12);
+   int32_t* x30 = CTYPES_ADDR_OF_FATPTR(x11);
+   int64_t* x31 = CTYPES_ADDR_OF_FATPTR(x10);
+   uint8_t* x32 = CTYPES_ADDR_OF_FATPTR(x9);
+   uint16_t* x33 = CTYPES_ADDR_OF_FATPTR(x8);
+   uint32_t* x34 = CTYPES_ADDR_OF_FATPTR(x7);
+   uint64_t* x35 = CTYPES_ADDR_OF_FATPTR(x6);
+   size_t* x36 = CTYPES_ADDR_OF_FATPTR(x5);
+   unsigned short* x37 = CTYPES_ADDR_OF_FATPTR(x4);
+   unsigned int* x38 = CTYPES_ADDR_OF_FATPTR(x3);
+   unsigned long* x39 = CTYPES_ADDR_OF_FATPTR(x2);
+   unsigned long long* x40 = CTYPES_ADDR_OF_FATPTR(x1);
+   int x41 =
+   accept_pointers(x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, 
+                   x31, x32, x33, x34, x35, x36, x37, x38, x39, x40);
+   return Val_int(x41);
+}
+value cstubs_tests_1_accept_pointers_byte20(value* argv, int argc)
+{
+   value x42 = argv[19];
+   value x43 = argv[18];
+   value x44 = argv[17];
+   value x45 = argv[16];
+   value x46 = argv[15];
+   value x47 = argv[14];
+   value x48 = argv[13];
+   value x49 = argv[12];
+   value x50 = argv[11];
+   value x51 = argv[10];
+   value x52 = argv[9];
+   value x53 = argv[8];
+   value x54 = argv[7];
+   value x55 = argv[6];
+   value x56 = argv[5];
+   value x57 = argv[4];
+   value x58 = argv[3];
+   value x59 = argv[2];
+   value x60 = argv[1];
+   value x61 = argv[0];
+   return
+     cstubs_tests_1_accept_pointers(x61, x60, x59, x58, x57, x56, x55, 
+                                    x54, x53, x52, x51, x50, x49, x48, 
+                                    x47, x46, x45, x44, x43, x42);
+}
+value cstubs_tests_2_accept_pointers_to_pointers(value x65, value x64,
+                                                 value x63, value x62)
+{
+   int* x66 = CTYPES_ADDR_OF_FATPTR(x65);
+   int** x67 = CTYPES_ADDR_OF_FATPTR(x64);
+   int*** x68 = CTYPES_ADDR_OF_FATPTR(x63);
+   int**** x69 = CTYPES_ADDR_OF_FATPTR(x62);
+   int x70 = accept_pointers_to_pointers(x66, x67, x68, x69);
+   return Val_int(x70);
+}
+value cstubs_tests_3_malloc(value x71)
+{
+   size_t x72 = ctypes_size_t_val(x71);
+   void* x75 = malloc(x72);
+   return CTYPES_FROM_PTR(x75);
+}
+value cstubs_tests_4_realloc(value x77, value x76)
+{
+   void* x78 = CTYPES_ADDR_OF_FATPTR(x77);
+   size_t x79 = ctypes_size_t_val(x76);
+   void* x82 = realloc(x78, x79);
+   return CTYPES_FROM_PTR(x82);
+}
+value cstubs_tests_5_free(value x83)
+{
+   void* x84 = CTYPES_ADDR_OF_FATPTR(x83);
+   free(x84);
+   return Val_unit;
+}
+value cstubs_tests_6_return_global_address(value x86)
+{
+   int* x87 = return_global_address();
+   return CTYPES_FROM_PTR(x87);
+}
+value cstubs_tests_7_pass_pointer_through(value x90, value x89, value x88)
+{
+   int* x91 = CTYPES_ADDR_OF_FATPTR(x90);
+   int* x92 = CTYPES_ADDR_OF_FATPTR(x89);
+   int x93 = Int_val(x88);
+   int* x96 = pass_pointer_through(x91, x92, x93);
+   return CTYPES_FROM_PTR(x96);
+}
+value cstubs_tests_8_passing_pointers_to_callback(value x97)
+{
+   int(* x98)(int*, int*) = CTYPES_ADDR_OF_FATPTR(x97);
+   int x99 = passing_pointers_to_callback(x98);
+   return Val_int(x99);
+}
+value cstubs_tests_9_accepting_pointer_from_callback(value x100)
+{
+   int*(* x101)(int, int) = CTYPES_ADDR_OF_FATPTR(x100);
+   int x102 = accepting_pointer_from_callback(x101);
+   return Val_int(x102);
+}
+value cstubs_tests_10_accepting_pointer_to_function_pointer(value x103)
+{
+   int(** x104)(int, int) = CTYPES_ADDR_OF_FATPTR(x103);
+   int x105 = accepting_pointer_to_function_pointer(x104);
+   return Val_int(x105);
+}
+value cstubs_tests_11_returning_pointer_to_function_pointer(value x106)
+{
+   int(** x107)(int, int) = returning_pointer_to_function_pointer();
+   return CTYPES_FROM_PTR(x107);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-pointers/test_pointers.ml ./tests/test-pointers/test_pointers.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-pointers/test_pointers.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-pointers/test_pointers.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
@@ -20,7 +20,7 @@
   (*
     Test passing various types of pointers to a function.
   *)
-  let test_passing_pointers () =
+  let test_passing_pointers _ =
     assert_equal ~msg:"Passing pointers to various numeric types"
       ~printer:string_of_int
       (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 +
@@ -52,7 +52,7 @@
   (*
     Test passing pointers to pointers.
   *)
-  let test_passing_pointers_to_pointers () =
+  let test_passing_pointers_to_pointers _ =
     let p = allocate int 1
     and pp = allocate (ptr int) (allocate int 2)
     and ppp = allocate (ptr (ptr int)) (allocate (ptr int) (allocate int 3))
@@ -67,7 +67,7 @@
   (*
     Passing a callback that accepts pointers as arguments.
   *)
-  let test_callback_receiving_pointers () =
+  let test_callback_receiving_pointers _ =
     assert_equal 7
       (passing_pointers_to_callback (fun lp rp -> !@lp + !@rp))
 
@@ -75,7 +75,7 @@
   (*
     Passing a callback that returns a pointer.
   *)
-  let test_callback_returning_pointers () =
+  let test_callback_returning_pointers _ =
     let p = allocate int 17 in
     begin
       assert_equal 17 !@p;
@@ -90,7 +90,7 @@
   (*
     Test passing a pointer-to-a-function-pointer as an argument.
   *)
-  let test_passing_pointer_to_function_pointer () =
+  let test_passing_pointer_to_function_pointer _ =
     assert_equal ~printer:string_of_int
       5 (accepting_pointer_to_function_pointer 
            (allocate (funptr (int @-> int @-> returning int)) ( / )))
@@ -100,7 +100,7 @@
   (*
     Test returning a pointer to a function pointer
   *)
-  let test_callback_returning_pointer_to_function_pointer () =
+  let test_callback_returning_pointer_to_function_pointer _ =
     assert_equal
       10 (!@(returning_pointer_to_function_pointer ()) 2 5)
 
@@ -108,7 +108,7 @@
   (*
     Test bindings for malloc, realloc and free.
   *)
-  let test_allocation () =
+  let test_allocation _ =
     let open Unsigned in
 
     let pointer = malloc (Size_t.of_int (sizeof int)) in
@@ -139,14 +139,14 @@
   (*
     Test a function that returns the address of a global variable.
   *)
-  let test_reading_returned_global () =
+  let test_reading_returned_global _ =
     assert_equal (!@(return_global_address ())) 100
 
 
   (*
     Test a function that returns a pointer passed as argument.
   *)
-  let test_passing_pointer_through () =
+  let test_passing_pointer_through _ =
     let p1 = allocate int 25 in
     let p2 = allocate int 32 in
     let rv = pass_pointer_through p1 p2 10 in
@@ -172,7 +172,7 @@
     assert_bool
       "returned pointer with positive computed offset compares greater than original"
       (ptr_compare rv p1 > 0);
-    assert_equal !@rv !@p3;
+    assert_equal !@(rv -@ 1) !@(p3 -@ 1);
     let p4 = p1 -@ 1 in
     let rv = pass_pointer_through p1 p4 (-1) in
     assert_bool
@@ -196,7 +196,7 @@
 (*
   Tests for reading and writing primitive values through pointers.
 *)
-let test_pointer_assignment_with_primitives () =
+let test_pointer_assignment_with_primitives _ =
   let open Signed in
   let open Unsigned in
   let p_char = allocate char '1'
@@ -300,7 +300,7 @@
 (*
   Dereferencing pointers to incomplete types
 *)
-let test_dereferencing_pointers_to_incomplete_types () =
+let test_dereferencing_pointers_to_incomplete_types _ =
   begin
     assert_raises IncompleteType
       (fun () -> !@null);
@@ -316,7 +316,7 @@
 (*
   Writing through a pointer to an abstract type
 *)
-let test_writing_through_pointer_to_abstract_type () =
+let test_writing_through_pointer_to_abstract_type _ =
   let module Array = CArray in
   let arra = Array.make int 2 in
   let arrb = Array.make int 2 in
@@ -357,7 +357,7 @@
    Test for reading and writing global values using the "foreign_value"
    function.
 *)
-let test_reading_and_writing_global_value () =
+let test_reading_and_writing_global_value _ =
   let ptr = foreign_value "global" int ~from:testlib in
   let ptr' = foreign_value "global" int ~from:testlib in
   assert_equal (!@ptr) 100;
@@ -372,7 +372,7 @@
 (*
   Tests for reading a string from an address.
 *)
-let test_reading_strings () =
+let test_reading_strings _ =
   let p = allocate_n char 26 in begin
     StringLabels.iteri "abcdefghijklmnoprwstuvwxyz"
       ~f:(fun i c -> (p +@ i) <-@ c);
@@ -387,7 +387,7 @@
 (*
   Tests for various aspects of pointer arithmetic.
 *)
-let test_pointer_arithmetic () =
+let test_pointer_arithmetic _ =
   let module Array = CArray in
   let arr = Array.of_list int [1;2;3;4;5;6;7;8] in
 
@@ -428,7 +428,7 @@
 (*
   Test pointer comparisons.
 *)
-let test_pointer_comparison () =
+let test_pointer_comparison _ =
   let canonicalize p =
     (* Ensure that the 'pbyte_offset' component of the pointer is zero by
        writing the pointer to memory and then reading it back. *)
@@ -515,7 +515,7 @@
 (*
   Test pointer differences.
 *)
-let test_pointer_differences () =
+let test_pointer_differences _ =
   let canonicalize p =
     (* Ensure that the 'pbyte_offset' component of the pointer is zero by
        writing the pointer to memory and then reading it back. *)
@@ -561,13 +561,13 @@
 (*
   Test raw pointers.
 *)
-let test_raw_pointers () =
+let test_raw_pointers _ =
   (* Check that conversions to the raw form commute with arithmetic. *)
   let p : float ptr = allocate double 1.0 in
   let p' = p +@ 3 in
   let praw = raw_address_of_ptr (to_voidp p) in
   let praw' = raw_address_of_ptr (to_voidp p') in
-  assert_equal praw' Int64.(add praw (of_int (3 * sizeof double)))
+  assert_equal praw' Nativeint.(add praw (of_int (3 * sizeof double)))
 
 
 module Foreign_tests = Common_tests(Tests_common.Foreign_binder)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-raw/test_raw.ml ./tests/test-raw/test_raw.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-raw/test_raw.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-raw/test_raw.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Memory_stubs
 open Std_view_stubs
 
@@ -18,20 +18,26 @@
 
         double fabs(double)
 *)
-let test_fabs () =
+let test_fabs _ =
   Ffi_stubs.(
     let double_ffitype = primitive_ffitype Primitives.Double in
-    let callspec = allocate_callspec () in
+    let callspec = allocate_callspec
+      ~check_errno:false
+      ~runtime_lock:false
+    in
     let arg_1_offset = add_argument callspec double_ffitype in
     let () = prep_callspec callspec Libffi_abi.(abi_code default_abi)
       double_ffitype in
     
     let dlfabs = Dl.dlsym "fabs" in
+    let dlfabs_fat = Ctypes_ptr.Fat.make ~reftyp:Static.Void dlfabs in
     
     let fabs x =
-      call dlfabs callspec
-        (fun p _values -> write Primitives.Double ~offset:arg_1_offset x p)
-        (read Primitives.Double ~offset:0)
+      call "fabs" dlfabs_fat callspec
+        (fun p _values ->
+          write Primitives.Double x
+            Ctypes_ptr.(Fat.make ~reftyp:Static.Void (Raw.(add p (of_int arg_1_offset)))))
+        (fun p -> read Primitives.Double (Ctypes_ptr.Fat.make ~reftyp:Static.Void p))
     in
 
     assert_equal 2.0 (fabs (-2.0)) ~printer:string_of_float;
@@ -44,23 +50,29 @@
 
         double pow(double, double)
 *)
-let test_pow () =
+let test_pow _ =
   Ffi_stubs.(
     let double_ffitype = primitive_ffitype Primitives.Double in
-    let callspec = allocate_callspec () in
+    let callspec = allocate_callspec
+      ~check_errno:false
+      ~runtime_lock:false
+    in
     let arg_1_offset = add_argument callspec double_ffitype in
     let arg_2_offset = add_argument callspec double_ffitype in
     let () = prep_callspec callspec Libffi_abi.(abi_code default_abi) 
       double_ffitype in
     
     let dlpow = Dl.dlsym "pow" in
+    let dlpow_fat = Ctypes_ptr.Fat.make ~reftyp:Static.Void dlpow in
     
     let pow x y =
-      call dlpow callspec
+      call "pow" dlpow_fat callspec
         (fun buffer _values ->
-          write Primitives.Double ~offset:arg_1_offset x buffer;
-          write Primitives.Double ~offset:arg_2_offset y buffer)
-        (read ~offset:0 Primitives.Double)
+          write Primitives.Double x
+            Ctypes_ptr.(Fat.make ~reftyp:Static.Void (Raw.(add buffer (of_int arg_1_offset))));
+          write Primitives.Double y
+            Ctypes_ptr.(Fat.make ~reftyp:Static.Void (Raw.(add buffer (of_int arg_2_offset)))))
+        (fun p -> read Primitives.Double (Ctypes_ptr.Fat.make ~reftyp:Static.Void p))
     in
 
     assert_equal 8.0 (pow 2.0 3.0);
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-sizeof/test_sizeof.ml ./tests/test-sizeof/test_sizeof.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-sizeof/test_sizeof.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-sizeof/test_sizeof.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,14 +5,14 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
 (*
   Test some relationships between the sizes of primitive types.
 *)
-let test_sizeof_primitives () = begin
+let test_sizeof_primitives _ = begin
   assert_equal ~msg:"sizeof (char) == 1"
     (sizeof char) 1;
 
@@ -73,7 +73,7 @@
 (*
   Test some properties of the sizes of unions.
 *)
-let test_sizeof_unions () =
+let test_sizeof_unions _ =
   let int_char = union "int_char" in
   let _ = field int_char "_" int in
   let _ = field int_char "_" char in
@@ -92,7 +92,7 @@
 (*
   Test some properties of the sizes of structs.
 *)
-let test_sizeof_structs () =
+let test_sizeof_structs _ =
   let module M = struct
     (* We don't expect homogeneous structs consisting of words to have
        any padding. *)
@@ -113,7 +113,7 @@
 (*
   Test the size of abstract types.
 *)
-let test_sizeof_abstract () =
+let test_sizeof_abstract _ =
   for i = 1 to 10 do
     assert_equal
       i (sizeof (abstract ~name:"abstract" ~size:i ~alignment:(11 - i)))
@@ -123,7 +123,7 @@
 (*
   Test that taking the size of an incomplete type is treated as an error.
 *)
-let test_sizeof_incomplete () = begin
+let test_sizeof_incomplete _ = begin
   assert_raises IncompleteType
     (fun () -> sizeof (structure "incomplete"));
 
@@ -135,7 +135,7 @@
 (*
   Test that taking the size of void is treated as an error.
 *)
-let test_sizeof_void () =
+let test_sizeof_void _ =
   assert_raises IncompleteType
     (fun () -> sizeof void)
  
@@ -143,7 +143,7 @@
 (*
   Test that [sizeof] treats OCaml types as incomplete.
 *)
-let test_sizeof_ocaml_string () =
+let test_sizeof_ocaml_string _ =
   assert_raises IncompleteType
     (fun () -> sizeof ocaml_string)
 
@@ -151,7 +151,7 @@
 (*
   Test the behaviour of sizeof on array types.
 *)
-let test_sizeof_arrays () = begin
+let test_sizeof_arrays _ = begin
   assert_equal ~msg:"The size of an array is the sum of the size of its members"
     (12 * (sizeof int8_t)) (sizeof (array 12 int8_t));
 
@@ -163,7 +163,7 @@
 (*
   Test the behaviour of sizeof on bigarray types.
 *)
-let test_sizeof_bigarrays () =
+let test_sizeof_bigarrays _ =
   let module M = struct
     module B = Bigarray
     type k = K : ('a, 'b) Bigarray.kind * int -> k
@@ -211,7 +211,7 @@
 (*
   Test that all pointers have equal size.
 *)
-let test_sizeof_pointers () = begin
+let test_sizeof_pointers _ = begin
   let pointer_size = sizeof (ptr void) in
   assert_equal pointer_size (sizeof (ptr void));
   assert_equal pointer_size (sizeof (ptr int));
@@ -231,7 +231,7 @@
 (*
   Test that the size of a view type is the same as the underlying type.
 *)
-let test_sizeof_views () = begin
+let test_sizeof_views _ = begin
   let const c x = c in
   let vint = view ~read:(const [1]) ~write:(const 0) int
   and vchar = view ~read:(const ["1"]) ~write:(const 'a') char
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-structs/generated_bindings.ml ./tests/test-structs/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-structs/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-structs/generated_bindings.ml	2014-10-07 17:44:45.000000000 +0000
@@ -0,0 +1,40 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_accept_struct : _ CI.fatptr -> int
+  = "cstubs_tests_1_accept_struct" 
+
+external cstubs_tests_2_return_struct : unit -> Memory_stubs.managed_buffer
+  = "cstubs_tests_2_return_struct" 
+
+external cstubs_tests_3_add_tagged_numbers
+  : _ CI.fatptr -> _ CI.fatptr -> Memory_stubs.managed_buffer
+  = "cstubs_tests_3_add_tagged_numbers" 
+
+external cstubs_tests_4_add_triples
+  : _ CI.fatptr -> _ CI.fatptr -> Memory_stubs.managed_buffer
+  = "cstubs_tests_4_add_triples" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "add_triples",
+  CI.Function
+    (CI.Struct _, CI.Function (CI.Struct _, CI.Returns (CI.Struct _ as x3))) ->
+  (fun x1 x2 ->
+    CI.make_structured x3
+      (cstubs_tests_4_add_triples (CI.cptr (Ctypes.addr x1))
+        (CI.cptr (Ctypes.addr x2))))
+| "add_tagged_numbers",
+  CI.Function
+    (CI.Struct _, CI.Function (CI.Struct _, CI.Returns (CI.Struct _ as x6))) ->
+  (fun x4 x5 ->
+    CI.make_structured x6
+      (cstubs_tests_3_add_tagged_numbers (CI.cptr (Ctypes.addr x4))
+        (CI.cptr (Ctypes.addr x5))))
+| "return_struct", CI.Function (CI.Void, CI.Returns (CI.Struct _ as x8)) ->
+  (fun x7 -> CI.make_structured x8 (cstubs_tests_2_return_struct x7))
+| "accept_struct",
+  CI.Function (CI.Struct _, CI.Returns (CI.Primitive CI.Int)) ->
+  (fun x9 -> cstubs_tests_1_accept_struct (CI.cptr (Ctypes.addr x9)))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-structs/generated_stubs.c ./tests/test-structs/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-structs/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-structs/generated_stubs.c	2014-10-07 17:44:45.000000000 +0000
@@ -0,0 +1,34 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_accept_struct(value x1)
+{
+   void* x2 = CTYPES_ADDR_OF_FATPTR(x1);
+   struct simple x4 = *(struct simple*)x2;
+   int x5 = accept_struct(x4);
+   return Val_int(x5);
+}
+value cstubs_tests_2_return_struct(value x6)
+{
+   struct simple x7 = return_struct();
+   return ctypes_copy_bytes(&x7, 24);
+}
+value cstubs_tests_3_add_tagged_numbers(value x9, value x8)
+{
+   void* x10 = CTYPES_ADDR_OF_FATPTR(x9);
+   struct tagged x12 = *(struct tagged*)x10;
+   void* x13 = CTYPES_ADDR_OF_FATPTR(x8);
+   struct tagged x15 = *(struct tagged*)x13;
+   struct tagged x16 = add_tagged_numbers(x12, x15);
+   return ctypes_copy_bytes(&x16, 16);
+}
+value cstubs_tests_4_add_triples(value x18, value x17)
+{
+   void* x19 = CTYPES_ADDR_OF_FATPTR(x18);
+   struct triple x21 = *(struct triple*)x19;
+   void* x22 = CTYPES_ADDR_OF_FATPTR(x17);
+   struct triple x24 = *(struct triple*)x22;
+   struct triple x25 = add_triples(x21, x24);
+   return ctypes_copy_bytes(&x25, 24);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-structs/test_structs.ml ./tests/test-structs/test_structs.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-structs/test_structs.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-structs/test_structs.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -30,7 +30,7 @@
          struct simple *self;
        };
   *)
-  let test_passing_struct () =
+  let test_passing_struct _ =
     let module M = struct
       let s = make simple
 
@@ -61,7 +61,7 @@
          struct simple *self;
        };
   *)
-  let test_returning_struct () =
+  let test_returning_struct _ =
     let module M = struct
       let s = return_struct ()
 
@@ -83,7 +83,7 @@
 (*
   Check that attempts to use incomplete types for struct members are rejected.
 *)
-let test_incomplete_struct_members () =
+let test_incomplete_struct_members _ =
   let s = structure "s" in begin
 
     assert_raises IncompleteType
@@ -100,7 +100,7 @@
 (*
   Test that OCaml types cannot be used as struct or union fields.
 *)
-let test_ocaml_types_rejected_as_fields () =
+let test_ocaml_types_rejected_as_fields _ =
   let module M = struct
     let s = structure "s"
     let () = assert_raises IncompleteType
@@ -109,16 +109,16 @@
     let u = union "u"
     let () = assert_raises IncompleteType
       (fun () ->
-        field u "o" ocaml_string;
-        (* The error is currently only caught on sealing the union *)
-        seal u)
+       let _ =  field u "o" ocaml_string in
+       (* The error is currently only caught on sealing the union *)
+       seal u)
   end in ()
 
 
 (*
   Test reading and writing pointers to struct members.
 *)
-let test_pointers_to_struct_members () =
+let test_pointers_to_struct_members _ =
   let module M = struct
     type s
 
@@ -159,7 +159,7 @@
 (*
   Test structs with union members.
 *)
-let test_structs_with_union_members () =
+let test_structs_with_union_members _ =
   let module M = struct
     type u and s
 
@@ -221,7 +221,7 @@
 (*
   Test structs with array members.
 *)
-let test_structs_with_array_members () =
+let test_structs_with_array_members _ =
   let module M = struct
     type u and s
 
@@ -285,7 +285,7 @@
 (*
   Test that attempting to update a sealed struct is treated as an error.
 *)
-let test_updating_sealed_struct () =
+let test_updating_sealed_struct _ =
   let styp = structure "sealed" in
   let _ = field styp "_" int in
   let () = seal styp in
@@ -297,7 +297,7 @@
 (*
   Test that attempting to seal an empty struct is treated as an error.
 *)
-let test_sealing_empty_struct () =
+let test_sealing_empty_struct _ =
   let empty = structure "empty" in
 
   assert_raises (Unsupported "struct with no fields")
@@ -308,7 +308,7 @@
    Check that references to fields aren't garbage collected while they're
    still needed.
 *)
-let test_field_references_not_invalidated () =
+let test_field_references_not_invalidated _ =
   let module M = struct
     type s1 and s2
 
@@ -340,7 +340,7 @@
    Check that references to ffi_type values for structs aren't collected while
    they're still needed
 *)
-let test_struct_ffi_type_lifetime () =
+let test_struct_ffi_type_lifetime _ =
   let module M = struct
     let f =
       let t = 
@@ -370,7 +370,7 @@
   (*
     Test passing structs with union members.
   *)
-  let test_passing_structs_with_union_members () =
+  let test_passing_structs_with_union_members _ =
     let mkInt v =
       let t = make tagged in
       t @. tag <-@ 'i';
@@ -396,7 +396,7 @@
   (*
     Test passing structs with array members.
   *)
-  let test_passing_structs_with_array_members () =
+  let test_passing_structs_with_array_members _ =
     let mkTriple (x, y, z) =
       let t = make triple in
       t @. elements <-@ CArray.of_list double [x; y; z];
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-stubs/test_stubs.ml ./tests/test-stubs/test_stubs.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-stubs/test_stubs.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-stubs/test_stubs.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,13 +5,13 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Foreign
 
 let missing = "_60d2dd04_1b66_4b79_a2ea_8375157da563"
 
-let test_missing () = 
+let test_missing _ = 
   let miss = foreign missing ~stub:true (int @-> int @-> (returning int)) in
   begin try ignore (miss 2 3); assert_failure "should raise" with exn -> () end;
   try
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-threads/stubs/functions.ml ./tests/test-threads/stubs/functions.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-threads/stubs/functions.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-threads/stubs/functions.ml	2014-10-06 15:23:14.000000000 +0000
@@ -0,0 +1,27 @@
+(*
+ * Copyright (c) 2014 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+(* Foreign function bindings for the threads tests. *)
+
+open Ctypes
+open Foreign
+
+let initialize_waiters = foreign "initialize_waiters"
+  (void @-> returning void)
+
+let post1_wait2 = foreign "post1_wait2"
+  ~release_runtime_lock:true
+  (void @-> returning void)
+
+let post2_wait1 = foreign "post2_wait1"
+  ~release_runtime_lock:true
+  (void @-> returning void)
+
+let callback_with_pointers = foreign "passing_pointers_to_callback"
+  ~release_runtime_lock:true
+  (funptr ~runtime_lock:true
+     (ptr int @-> ptr int @-> returning int) @-> returning int)
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-threads/test_threads.ml ./tests/test-threads/test_threads.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-threads/test_threads.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-threads/test_threads.ml	2014-10-06 15:23:14.000000000 +0000
@@ -0,0 +1,50 @@
+(*
+ * Copyright (c) 2013 Jeremy Yallop.
+ *
+ * This file is distributed under the terms of the MIT License.
+ * See the file LICENSE for details.
+ *)
+
+open Ctypes
+open OUnit2
+open Foreign
+open Functions
+
+
+(*
+  Ensure that passing ~release_runtime_lock releases the runtime lock.
+*)
+let test_release_runtime_lock _ =
+  begin
+    initialize_waiters ();
+    let t1 = Thread.create post1_wait2 () in
+    let t2 = Thread.create post2_wait1 () in
+    Thread.join t1;
+    Thread.join t2;
+  end
+
+
+(*
+  Ensure that passing ~runtime_lock to funptr causes a callbacks to acquire
+  the runtime lock.
+*)
+let test_acquire_runtime_lock _ =
+  begin
+    let f x y = let _ = Gc.major () in !@x + !@y in
+    let t1 = Thread.create Gc.major () in
+    assert (callback_with_pointers f = 7);
+    Thread.join t1
+  end
+
+
+let suite = "Thread tests" >:::
+  ["test_release_runtime_lock (foreign)"
+   >:: test_release_runtime_lock;
+
+   "test_acquire_runtime_lock (foreign)"
+   >:: test_acquire_runtime_lock;
+  ]
+
+
+let _ =
+  run_test_tt_main suite
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-type_printing/test_type_printing.ml ./tests/test-type_printing/test_type_printing.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-type_printing/test_type_printing.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-type_printing/test_type_printing.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -28,7 +28,7 @@
   Test the printing of atomic types: void, arithmetic types and abstract
   types.
 *)
-let test_atomic_printing () =
+let test_atomic_printing _ =
   begin
     assert_typ_printed_as "void"
       void;
@@ -112,7 +112,7 @@
 (*
   Test the printing of pointers to object and function types.
 *)
-let test_pointer_printing () =
+let test_pointer_printing _ =
   begin
     (* Pointers to atomic types *)
     assert_typ_printed_as ~name:"a" "void *a"
@@ -208,7 +208,7 @@
 (*
   Test the printing of pointers to object and function types.
 *)
-let test_struct_and_union_printing () =
+let test_struct_and_union_printing _ =
   begin
     (* Incomplete structs and unions *) 
     let s_incomplete = structure "s_incomplete" in 
@@ -362,7 +362,7 @@
 (*
   Test the printing of array types.
 *)
-let test_array_printing () =
+let test_array_printing _ =
   begin
     assert_typ_printed_as ~name:"a" "int a[10]"
       (array 10 int);
@@ -386,7 +386,7 @@
 (*
   Test the printing of OCaml string types.
 *)
-let test_ocaml_string_printing () =
+let test_ocaml_string_printing _ =
   begin
     assert_typ_printed_as ~name:"p" "char *p"
       ocaml_string;
@@ -397,28 +397,16 @@
 
 
 (*
-  Test the printing of bigarray types.
+  Test the printing of bigarray types with signed elements.
 *)
-let test_bigarray_printing () =
+let test_bigarray_signed_printing _ =
   begin
-    assert_typ_printed_as "float[10][100]"
-      (bigarray genarray [|10; 100|] Bigarray.float32);
-
-    assert_typ_printed_as "double[20][30][40]"
-      (bigarray genarray [|20; 30; 40|] Bigarray.float64);
-
     assert_typ_printed_as "int8_t[1][3]"
       (bigarray genarray [|1; 3|] Bigarray.int8_signed);
 
-    assert_typ_printed_as "uint8_t[2]"
-      (bigarray array1 2 Bigarray.int8_unsigned);
-
     assert_typ_printed_as "int16_t[3]"
       (bigarray array1 3 Bigarray.int16_signed);
 
-    assert_typ_printed_as "uint16_t[4]"
-      (bigarray array1 4 Bigarray.int16_unsigned);
-
     assert_typ_printed_as "int32_t[5][6]"
       (bigarray array2 (5, 6) Bigarray.int32);
 
@@ -430,24 +418,47 @@
 
     assert_typ_printed_as "intnat[13][14][15]"
       (bigarray array3 (13, 14, 15) Bigarray.nativeint);
+  end
+
+
+(*
+  Test the printing of bigarray types with unsigned elements.
+*)
+let test_bigarray_unsigned_printing _ =
+  skip_if true
+    "Unsigned bigarray elements currently indistinguishable from signed elements";
+  begin
+    assert_typ_printed_as "uint8_t[2]"
+      (bigarray array1 2 Bigarray.int8_unsigned);
+
+    assert_typ_printed_as "uint16_t[4]"
+      (bigarray array1 4 Bigarray.int16_unsigned);
+  end
+
+
+(*
+  Test the printing of bigarray types with floating elements.
+*)
+let test_bigarray_float_printing _ =
+  begin
+    assert_typ_printed_as "float[10][100]"
+      (bigarray genarray [|10; 100|] Bigarray.float32);
+
+    assert_typ_printed_as "double[20][30][40]"
+      (bigarray genarray [|20; 30; 40|] Bigarray.float64);
 
     assert_typ_printed_as "float _Complex[16][17][18]"
       (bigarray array3 (16, 17, 18) Bigarray.complex32);
 
     assert_typ_printed_as "double _Complex[19][20][21]"
       (bigarray array3 (19, 20, 21) Bigarray.complex64);
-
-    assert_typ_printed_as ~name:"b" "int (*b[10])(camlint(*)[5])"
-      (array 10
-         (Foreign.funptr (ptr (bigarray genarray [|5|] Bigarray.int) @->
-                          returning int)));
   end
 
 
 (*
   Test the printing of function types.
 *)
-let test_function_printing () =
+let test_function_printing _ =
   begin
     assert_fn_printed_as ~name:"a" "void a(void)"
       (void @-> returning void);
@@ -471,7 +482,7 @@
 (*
   Test the printing of view types.
 *)
-let test_view_printing () =
+let test_view_printing _ =
   begin
     (* By default, views are printed as the underlying type *)
 
@@ -516,8 +527,14 @@
    "printing OCaml string types"
     >:: test_ocaml_string_printing;
 
-   "printing bigarrays"
-    >:: test_bigarray_printing;
+   "printing bigarrays with signed elements"
+    >:: test_bigarray_signed_printing;
+
+   "printing bigarrays with unsigned elements"
+    >:: test_bigarray_unsigned_printing;
+
+   "printing bigarrays with floating elements"
+    >:: test_bigarray_float_printing;
 
    "printing functions"
     >:: test_function_printing;
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-unions/generated_bindings.ml ./tests/test-unions/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-unions/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-unions/generated_bindings.ml	2014-10-07 17:44:47.000000000 +0000
@@ -0,0 +1,28 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_sum_union_components
+  : _ CI.fatptr -> Unsigned.size_t -> int64
+  = "cstubs_tests_1_sum_union_components" 
+
+external cstubs_tests_2_add_unions
+  : _ CI.fatptr -> _ CI.fatptr -> Memory_stubs.managed_buffer
+  = "cstubs_tests_2_add_unions" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "add_unions",
+  CI.Function
+    (CI.Union _, CI.Function (CI.Union _, CI.Returns (CI.Union _ as x3))) ->
+  (fun x1 x2 ->
+    CI.make_structured x3
+      (cstubs_tests_2_add_unions (CI.cptr (Ctypes.addr x1))
+        (CI.cptr (Ctypes.addr x2))))
+| "sum_union_components",
+  CI.Function
+    (CI.Pointer x5,
+     CI.Function
+       (CI.Primitive CI.Size_t, CI.Returns (CI.Primitive CI.Int64_t))) ->
+  (fun x4 x6 -> cstubs_tests_1_sum_union_components (CI.cptr x4) x6)
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-unions/generated_stubs.c ./tests/test-unions/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-unions/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-unions/generated_stubs.c	2014-10-07 17:44:47.000000000 +0000
@@ -0,0 +1,20 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_sum_union_components(value x2, value x1)
+{
+   union padded* x3 = CTYPES_ADDR_OF_FATPTR(x2);
+   size_t x4 = ctypes_size_t_val(x1);
+   int64_t x7 = sum_union_components(x3, x4);
+   return caml_copy_int64(x7);
+}
+value cstubs_tests_2_add_unions(value x9, value x8)
+{
+   void* x10 = CTYPES_ADDR_OF_FATPTR(x9);
+   union padded x12 = *(union padded*)x10;
+   void* x13 = CTYPES_ADDR_OF_FATPTR(x8);
+   union padded x15 = *(union padded*)x13;
+   union padded x16 = add_unions(x12, x15);
+   return ctypes_copy_bytes(&x16, 16);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-unions/test_unions.ml ./tests/test-unions/test_unions.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-unions/test_unions.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-unions/test_unions.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 open Unsigned
 
@@ -19,7 +19,7 @@
        int64_t i;
      };
 *)
-let test_inspecting_float () =
+let test_inspecting_float _ =
   let module M = struct
     type u
     let utyp : u union typ = union "u"
@@ -53,7 +53,7 @@
        unsigned char c[sizeof int64_t];
      };
 *)
-let test_endian_detection () =
+let test_endian_detection _ =
   let module M = struct
     type e
     let etyp : e union typ = union "e"
@@ -92,7 +92,7 @@
   (* Check that unions are tail-padded sufficiently to satisfy the alignment
      requirements of all their members.
   *)
-  let test_union_padding () =
+  let test_union_padding _ =
     let module M = struct
       let mkPadded : int64 -> padded union =
         fun x ->
@@ -128,7 +128,7 @@
 
   (* Check that unions can be passed and returned by value.
   *)
-  let test_passing_unions_by_value () =
+  let test_passing_unions_by_value _ =
     let module M = struct
       let mkPadded : int64 -> padded union =
         fun x ->
@@ -148,7 +148,7 @@
 (* Check that the address of a union is equal to the addresses of each
    of its members.
 *)
-let test_union_address () =
+let test_union_address _ =
   let module M = struct
     type u
     let u : u union typ = union "u"
@@ -177,7 +177,7 @@
 (*
   Test that attempting to update a sealed union is treated as an error.
 *)
-let test_updating_sealed_union () =
+let test_updating_sealed_union _ =
   let utyp = union "sealed" in
   let _ = field utyp "_" int in
   let () = seal utyp in
@@ -189,7 +189,7 @@
 (*
   Test that attempting to seal an empty union is treated as an error.
 *)
-let test_sealing_empty_union () =
+let test_sealing_empty_union _ =
   let empty = union "empty" in
 
   assert_raises (Unsupported "union with no fields")
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/generated_bindings.ml ./tests/test-value_printing/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-value_printing/generated_bindings.ml	2014-10-07 17:44:52.000000000 +0000
@@ -0,0 +1,209 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_retrieve_CHAR_MIN : unit -> char
+  = "cstubs_tests_1_retrieve_CHAR_MIN" 
+
+external cstubs_tests_2_retrieve_CHAR_MAX : unit -> char
+  = "cstubs_tests_2_retrieve_CHAR_MAX" 
+
+external cstubs_tests_3_retrieve_SCHAR_MIN : unit -> int
+  = "cstubs_tests_3_retrieve_SCHAR_MIN" 
+
+external cstubs_tests_4_retrieve_SCHAR_MAX : unit -> int
+  = "cstubs_tests_4_retrieve_SCHAR_MAX" 
+
+external cstubs_tests_5_retrieve_SHRT_MIN : unit -> int
+  = "cstubs_tests_5_retrieve_SHRT_MIN" 
+
+external cstubs_tests_6_retrieve_SHRT_MAX : unit -> int
+  = "cstubs_tests_6_retrieve_SHRT_MAX" 
+
+external cstubs_tests_7_retrieve_INT_MIN : unit -> int
+  = "cstubs_tests_7_retrieve_INT_MIN" 
+
+external cstubs_tests_8_retrieve_INT_MAX : unit -> int
+  = "cstubs_tests_8_retrieve_INT_MAX" 
+
+external cstubs_tests_9_retrieve_LONG_MAX : unit -> Signed.long
+  = "cstubs_tests_9_retrieve_LONG_MAX" 
+
+external cstubs_tests_10_retrieve_LONG_MIN : unit -> Signed.long
+  = "cstubs_tests_10_retrieve_LONG_MIN" 
+
+external cstubs_tests_11_retrieve_LLONG_MAX : unit -> Signed.llong
+  = "cstubs_tests_11_retrieve_LLONG_MAX" 
+
+external cstubs_tests_12_retrieve_LLONG_MIN : unit -> Signed.llong
+  = "cstubs_tests_12_retrieve_LLONG_MIN" 
+
+external cstubs_tests_13_retrieve_UCHAR_MAX : unit -> Unsigned.uchar
+  = "cstubs_tests_13_retrieve_UCHAR_MAX" 
+
+external cstubs_tests_14_retrieve_USHRT_MAX : unit -> Unsigned.ushort
+  = "cstubs_tests_14_retrieve_USHRT_MAX" 
+
+external cstubs_tests_15_retrieve_UINT_MAX : unit -> Unsigned.uint
+  = "cstubs_tests_15_retrieve_UINT_MAX" 
+
+external cstubs_tests_16_retrieve_ULONG_MAX : unit -> Unsigned.ulong
+  = "cstubs_tests_16_retrieve_ULONG_MAX" 
+
+external cstubs_tests_17_retrieve_ULLONG_MAX : unit -> Unsigned.ullong
+  = "cstubs_tests_17_retrieve_ULLONG_MAX" 
+
+external cstubs_tests_18_retrieve_INT8_MIN : unit -> int
+  = "cstubs_tests_18_retrieve_INT8_MIN" 
+
+external cstubs_tests_19_retrieve_INT8_MAX : unit -> int
+  = "cstubs_tests_19_retrieve_INT8_MAX" 
+
+external cstubs_tests_20_retrieve_INT16_MIN : unit -> int
+  = "cstubs_tests_20_retrieve_INT16_MIN" 
+
+external cstubs_tests_21_retrieve_INT16_MAX : unit -> int
+  = "cstubs_tests_21_retrieve_INT16_MAX" 
+
+external cstubs_tests_22_retrieve_INT32_MIN : unit -> int32
+  = "cstubs_tests_22_retrieve_INT32_MIN" 
+
+external cstubs_tests_23_retrieve_INT32_MAX : unit -> int32
+  = "cstubs_tests_23_retrieve_INT32_MAX" 
+
+external cstubs_tests_24_retrieve_INT64_MIN : unit -> int64
+  = "cstubs_tests_24_retrieve_INT64_MIN" 
+
+external cstubs_tests_25_retrieve_INT64_MAX : unit -> int64
+  = "cstubs_tests_25_retrieve_INT64_MAX" 
+
+external cstubs_tests_26_retrieve_UINT8_MAX : unit -> Unsigned.uint8
+  = "cstubs_tests_26_retrieve_UINT8_MAX" 
+
+external cstubs_tests_27_retrieve_UINT16_MAX : unit -> Unsigned.uint16
+  = "cstubs_tests_27_retrieve_UINT16_MAX" 
+
+external cstubs_tests_28_retrieve_UINT32_MAX : unit -> Unsigned.uint32
+  = "cstubs_tests_28_retrieve_UINT32_MAX" 
+
+external cstubs_tests_29_retrieve_UINT64_MAX : unit -> Unsigned.uint64
+  = "cstubs_tests_29_retrieve_UINT64_MAX" 
+
+external cstubs_tests_30_retrieve_SIZE_MAX : unit -> Unsigned.size_t
+  = "cstubs_tests_30_retrieve_SIZE_MAX" 
+
+external cstubs_tests_31_retrieve_FLT_MIN : unit -> float
+  = "cstubs_tests_31_retrieve_FLT_MIN" 
+
+external cstubs_tests_32_retrieve_FLT_MAX : unit -> float
+  = "cstubs_tests_32_retrieve_FLT_MAX" 
+
+external cstubs_tests_33_retrieve_DBL_MIN : unit -> float
+  = "cstubs_tests_33_retrieve_DBL_MIN" 
+
+external cstubs_tests_34_retrieve_DBL_MAX : unit -> float
+  = "cstubs_tests_34_retrieve_DBL_MAX" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "retrieve_DBL_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Double)) ->
+  cstubs_tests_34_retrieve_DBL_MAX
+| "retrieve_DBL_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Double)) ->
+  cstubs_tests_33_retrieve_DBL_MIN
+| "retrieve_FLT_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Float)) ->
+  cstubs_tests_32_retrieve_FLT_MAX
+| "retrieve_FLT_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Float)) ->
+  cstubs_tests_31_retrieve_FLT_MIN
+| "retrieve_SIZE_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Size_t)) ->
+  cstubs_tests_30_retrieve_SIZE_MAX
+| "retrieve_UINT64_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Uint64_t)) ->
+  cstubs_tests_29_retrieve_UINT64_MAX
+| "retrieve_UINT32_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Uint32_t)) ->
+  cstubs_tests_28_retrieve_UINT32_MAX
+| "retrieve_UINT16_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Uint16_t)) ->
+  cstubs_tests_27_retrieve_UINT16_MAX
+| "retrieve_UINT8_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Uint8_t)) ->
+  cstubs_tests_26_retrieve_UINT8_MAX
+| "retrieve_INT64_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int64_t)) ->
+  cstubs_tests_25_retrieve_INT64_MAX
+| "retrieve_INT64_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int64_t)) ->
+  cstubs_tests_24_retrieve_INT64_MIN
+| "retrieve_INT32_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int32_t)) ->
+  cstubs_tests_23_retrieve_INT32_MAX
+| "retrieve_INT32_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int32_t)) ->
+  cstubs_tests_22_retrieve_INT32_MIN
+| "retrieve_INT16_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int16_t)) ->
+  cstubs_tests_21_retrieve_INT16_MAX
+| "retrieve_INT16_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int16_t)) ->
+  cstubs_tests_20_retrieve_INT16_MIN
+| "retrieve_INT8_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int8_t)) ->
+  cstubs_tests_19_retrieve_INT8_MAX
+| "retrieve_INT8_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int8_t)) ->
+  cstubs_tests_18_retrieve_INT8_MIN
+| "retrieve_ULLONG_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Ullong)) ->
+  cstubs_tests_17_retrieve_ULLONG_MAX
+| "retrieve_ULONG_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Ulong)) ->
+  cstubs_tests_16_retrieve_ULONG_MAX
+| "retrieve_UINT_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Uint)) ->
+  cstubs_tests_15_retrieve_UINT_MAX
+| "retrieve_USHRT_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Ushort)) ->
+  cstubs_tests_14_retrieve_USHRT_MAX
+| "retrieve_UCHAR_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Uchar)) ->
+  cstubs_tests_13_retrieve_UCHAR_MAX
+| "retrieve_LLONG_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Llong)) ->
+  cstubs_tests_12_retrieve_LLONG_MIN
+| "retrieve_LLONG_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Llong)) ->
+  cstubs_tests_11_retrieve_LLONG_MAX
+| "retrieve_LONG_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Long)) ->
+  cstubs_tests_10_retrieve_LONG_MIN
+| "retrieve_LONG_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Long)) ->
+  cstubs_tests_9_retrieve_LONG_MAX
+| "retrieve_INT_MAX", CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int)) ->
+  cstubs_tests_8_retrieve_INT_MAX
+| "retrieve_INT_MIN", CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Int)) ->
+  cstubs_tests_7_retrieve_INT_MIN
+| "retrieve_SHRT_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Short)) ->
+  cstubs_tests_6_retrieve_SHRT_MAX
+| "retrieve_SHRT_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Short)) ->
+  cstubs_tests_5_retrieve_SHRT_MIN
+| "retrieve_SCHAR_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Schar)) ->
+  cstubs_tests_4_retrieve_SCHAR_MAX
+| "retrieve_SCHAR_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Schar)) ->
+  cstubs_tests_3_retrieve_SCHAR_MIN
+| "retrieve_CHAR_MAX",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Char)) ->
+  cstubs_tests_2_retrieve_CHAR_MAX
+| "retrieve_CHAR_MIN",
+  CI.Function (CI.Void, CI.Returns (CI.Primitive CI.Char)) ->
+  cstubs_tests_1_retrieve_CHAR_MIN
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/generated_stubs.c ./tests/test-value_printing/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-value_printing/generated_stubs.c	2014-10-07 17:44:52.000000000 +0000
@@ -0,0 +1,174 @@
+#include "clib/test_functions.h"
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_retrieve_CHAR_MIN(value x1)
+{
+   char x2 = retrieve_CHAR_MIN();
+   return Val_int(x2);
+}
+value cstubs_tests_2_retrieve_CHAR_MAX(value x3)
+{
+   char x4 = retrieve_CHAR_MAX();
+   return Val_int(x4);
+}
+value cstubs_tests_3_retrieve_SCHAR_MIN(value x5)
+{
+   signed char x6 = retrieve_SCHAR_MIN();
+   return Val_int(x6);
+}
+value cstubs_tests_4_retrieve_SCHAR_MAX(value x7)
+{
+   signed char x8 = retrieve_SCHAR_MAX();
+   return Val_int(x8);
+}
+value cstubs_tests_5_retrieve_SHRT_MIN(value x9)
+{
+   short x10 = retrieve_SHRT_MIN();
+   return Val_int(x10);
+}
+value cstubs_tests_6_retrieve_SHRT_MAX(value x11)
+{
+   short x12 = retrieve_SHRT_MAX();
+   return Val_int(x12);
+}
+value cstubs_tests_7_retrieve_INT_MIN(value x13)
+{
+   int x14 = retrieve_INT_MIN();
+   return Val_int(x14);
+}
+value cstubs_tests_8_retrieve_INT_MAX(value x15)
+{
+   int x16 = retrieve_INT_MAX();
+   return Val_int(x16);
+}
+value cstubs_tests_9_retrieve_LONG_MAX(value x17)
+{
+   long x18 = retrieve_LONG_MAX();
+   return ctypes_copy_long(x18);
+}
+value cstubs_tests_10_retrieve_LONG_MIN(value x19)
+{
+   long x20 = retrieve_LONG_MIN();
+   return ctypes_copy_long(x20);
+}
+value cstubs_tests_11_retrieve_LLONG_MAX(value x21)
+{
+   long long x22 = retrieve_LLONG_MAX();
+   return ctypes_copy_llong(x22);
+}
+value cstubs_tests_12_retrieve_LLONG_MIN(value x23)
+{
+   long long x24 = retrieve_LLONG_MIN();
+   return ctypes_copy_llong(x24);
+}
+value cstubs_tests_13_retrieve_UCHAR_MAX(value x25)
+{
+   unsigned char x26 = retrieve_UCHAR_MAX();
+   return ctypes_copy_uint8(x26);
+}
+value cstubs_tests_14_retrieve_USHRT_MAX(value x27)
+{
+   unsigned short x28 = retrieve_USHRT_MAX();
+   return ctypes_copy_ushort(x28);
+}
+value cstubs_tests_15_retrieve_UINT_MAX(value x29)
+{
+   unsigned int x30 = retrieve_UINT_MAX();
+   return ctypes_copy_uint(x30);
+}
+value cstubs_tests_16_retrieve_ULONG_MAX(value x31)
+{
+   unsigned long x32 = retrieve_ULONG_MAX();
+   return ctypes_copy_ulong(x32);
+}
+value cstubs_tests_17_retrieve_ULLONG_MAX(value x33)
+{
+   unsigned long long x34 = retrieve_ULLONG_MAX();
+   return ctypes_copy_ullong(x34);
+}
+value cstubs_tests_18_retrieve_INT8_MIN(value x35)
+{
+   int8_t x36 = retrieve_INT8_MIN();
+   return Val_int(x36);
+}
+value cstubs_tests_19_retrieve_INT8_MAX(value x37)
+{
+   int8_t x38 = retrieve_INT8_MAX();
+   return Val_int(x38);
+}
+value cstubs_tests_20_retrieve_INT16_MIN(value x39)
+{
+   int16_t x40 = retrieve_INT16_MIN();
+   return Val_int(x40);
+}
+value cstubs_tests_21_retrieve_INT16_MAX(value x41)
+{
+   int16_t x42 = retrieve_INT16_MAX();
+   return Val_int(x42);
+}
+value cstubs_tests_22_retrieve_INT32_MIN(value x43)
+{
+   int32_t x44 = retrieve_INT32_MIN();
+   return caml_copy_int32(x44);
+}
+value cstubs_tests_23_retrieve_INT32_MAX(value x45)
+{
+   int32_t x46 = retrieve_INT32_MAX();
+   return caml_copy_int32(x46);
+}
+value cstubs_tests_24_retrieve_INT64_MIN(value x47)
+{
+   int64_t x48 = retrieve_INT64_MIN();
+   return caml_copy_int64(x48);
+}
+value cstubs_tests_25_retrieve_INT64_MAX(value x49)
+{
+   int64_t x50 = retrieve_INT64_MAX();
+   return caml_copy_int64(x50);
+}
+value cstubs_tests_26_retrieve_UINT8_MAX(value x51)
+{
+   uint8_t x52 = retrieve_UINT8_MAX();
+   return ctypes_copy_uint8(x52);
+}
+value cstubs_tests_27_retrieve_UINT16_MAX(value x53)
+{
+   uint16_t x54 = retrieve_UINT16_MAX();
+   return ctypes_copy_uint16(x54);
+}
+value cstubs_tests_28_retrieve_UINT32_MAX(value x55)
+{
+   uint32_t x56 = retrieve_UINT32_MAX();
+   return ctypes_copy_uint32(x56);
+}
+value cstubs_tests_29_retrieve_UINT64_MAX(value x57)
+{
+   uint64_t x58 = retrieve_UINT64_MAX();
+   return ctypes_copy_uint64(x58);
+}
+value cstubs_tests_30_retrieve_SIZE_MAX(value x59)
+{
+   size_t x60 = retrieve_SIZE_MAX();
+   return ctypes_copy_size_t(x60);
+}
+value cstubs_tests_31_retrieve_FLT_MIN(value x61)
+{
+   float x62 = retrieve_FLT_MIN();
+   return caml_copy_double(x62);
+}
+value cstubs_tests_32_retrieve_FLT_MAX(value x63)
+{
+   float x64 = retrieve_FLT_MAX();
+   return caml_copy_double(x64);
+}
+value cstubs_tests_33_retrieve_DBL_MIN(value x65)
+{
+   double x66 = retrieve_DBL_MIN();
+   return caml_copy_double(x66);
+}
+value cstubs_tests_34_retrieve_DBL_MAX(value x67)
+{
+   double x68 = retrieve_DBL_MAX();
+   return caml_copy_double(x68);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/stubs/functions.ml ./tests/test-value_printing/stubs/functions.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/stubs/functions.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-value_printing/stubs/functions.ml	2014-10-06 15:23:14.000000000 +0000
@@ -41,12 +41,6 @@
   let retrieve_LONG_MIN = foreign "retrieve_LONG_MIN"
     (void @-> returning long)
 
-  let retrieve_nLONG_MAX = foreign "retrieve_nLONG_MAX"
-    (void @-> returning nativeint)
-
-  let retrieve_nLONG_MIN = foreign "retrieve_nLONG_MIN"
-    (void @-> returning nativeint)
-
   let retrieve_LLONG_MAX = foreign "retrieve_LLONG_MAX"
     (void @-> returning llong)
 
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/test_value_printing.ml ./tests/test-value_printing/test_value_printing.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-value_printing/test_value_printing.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-value_printing/test_value_printing.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -24,7 +24,7 @@
     Test the printing of atomic values: arithmetic types and values of abstract
     types.
   *)
-  let test_atomic_printing () =
+  let test_atomic_printing _ =
     let open Signed in
     let open Unsigned in
 
@@ -201,16 +201,6 @@
     Size_t.(assert_equal (string_of size_t (of_int 5)) (to_string (of_int 5)));
     Size_t.(assert_equal (string_of size_t _SIZE_MAX) (to_string _SIZE_MAX));
 
-    (* nativeint *)
-    let _nINT_MIN = retrieve_nLONG_MIN () in
-    let _nINT_MAX = retrieve_nLONG_MAX () in
-
-    assert_equal (string_of nativeint _nINT_MIN) (Nativeint.to_string _nINT_MIN);
-    assert_equal (string_of nativeint 0n) (Nativeint.to_string 0n);
-    assert_equal (string_of nativeint (-5n)) (Nativeint.to_string (-5n));
-    assert_equal (string_of nativeint 14n) (Nativeint.to_string 14n);
-    assert_equal (string_of nativeint _nINT_MAX) (Nativeint.to_string _nINT_MAX);
-
     (* float *)
     let _FLT_MIN = retrieve_FLT_MIN () in
     let _FLT_MAX = retrieve_FLT_MAX () in
@@ -241,7 +231,7 @@
 (*
   Test the printing of pointers.
 *)
-let test_pointer_printing () =
+let test_pointer_printing _ =
   (* There's not much we can test here, since pointer formatting is
      implementation-dependent.  We can at least run the pointer-formatting
      code, and test that pointers of different types are printed
@@ -257,7 +247,7 @@
 (*
   Test the printing of structs.
 *)
-let test_struct_printing () =
+let test_struct_printing _ =
   let s = structure "s" in
   let (-:) ty label = field s label ty in
   let a = array 3 int -: "arr" in
@@ -292,7 +282,7 @@
 (*
   Test the printing of unions.
 *)
-let test_union_printing () =
+let test_union_printing _ =
   let s = structure "s" in
   let (-:) ty label = field s label ty in
   let i = uint16_t -: "i" in
@@ -313,7 +303,7 @@
 (*
   Test the printing of array types.
 *)
-let test_array_printing () =
+let test_array_printing _ =
   let arr = CArray.of_list int [-1; 0; 1] in
   let arrarr = CArray.of_list (array 3 int) [arr; arr] in
   assert_bool "array printing"
@@ -324,7 +314,7 @@
 (*
   Test the printing of ocaml_string values.
 *)
-let test_ocaml_string_printing () =
+let test_ocaml_string_printing _ =
   let s = "abc@%^&*[\"" in
   begin
     assert_equal
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-variadic/generated_bindings.ml ./tests/test-variadic/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-variadic/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-variadic/generated_bindings.ml	2014-10-07 17:44:41.000000000 +0000
@@ -0,0 +1,76 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_snprintf
+  : _ CI.fatptr -> Unsigned.size_t -> _ CI.fatptr -> int -> int
+  = "cstubs_tests_1_snprintf" 
+
+external cstubs_tests_2_snprintf
+  : _ CI.fatptr -> Unsigned.size_t -> _ CI.fatptr -> char -> Unsigned.uint ->
+    int = "cstubs_tests_2_snprintf" 
+
+external cstubs_tests_3_snprintf
+  : _ CI.fatptr -> Unsigned.size_t -> _ CI.fatptr -> Signed.llong -> 
+    int -> int = "cstubs_tests_3_snprintf" 
+
+external cstubs_tests_4_snprintf
+  : _ CI.fatptr -> Unsigned.size_t -> _ CI.fatptr -> _ CI.fatptr ->
+    Unsigned.ushort -> int = "cstubs_tests_4_snprintf" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "snprintf",
+  CI.Function
+    (CI.Pointer x2,
+     CI.Function
+       (CI.View {CI.ty = CI.Primitive CI.Size_t; write = x4; },
+        CI.Function
+          (CI.View {CI.ty = CI.Pointer x7; write = x6; },
+           CI.Function
+             (CI.View {CI.ty = CI.Pointer x10; write = x9; },
+              CI.Function
+                (CI.Primitive CI.Ushort, CI.Returns (CI.Primitive CI.Int)))))) ->
+  (fun x1 x3 x5 x8 x11 ->
+    cstubs_tests_4_snprintf (CI.cptr x1) (x4 x3) (CI.cptr (x6 x5))
+    (CI.cptr (x9 x8)) x11)
+| "snprintf",
+  CI.Function
+    (CI.Pointer x13,
+     CI.Function
+       (CI.View {CI.ty = CI.Primitive CI.Size_t; write = x15; },
+        CI.Function
+          (CI.View {CI.ty = CI.Pointer x18; write = x17; },
+           CI.Function
+             (CI.Primitive CI.Llong,
+              CI.Function
+                (CI.Primitive CI.Int, CI.Returns (CI.Primitive CI.Int)))))) ->
+  (fun x12 x14 x16 x19 x20 ->
+    cstubs_tests_3_snprintf (CI.cptr x12) (x15 x14) (CI.cptr (x17 x16)) x19
+    x20)
+| "snprintf",
+  CI.Function
+    (CI.Pointer x22,
+     CI.Function
+       (CI.View {CI.ty = CI.Primitive CI.Size_t; write = x24; },
+        CI.Function
+          (CI.View {CI.ty = CI.Pointer x27; write = x26; },
+           CI.Function
+             (CI.Primitive CI.Char,
+              CI.Function
+                (CI.Primitive CI.Uint, CI.Returns (CI.Primitive CI.Int)))))) ->
+  (fun x21 x23 x25 x28 x29 ->
+    cstubs_tests_2_snprintf (CI.cptr x21) (x24 x23) (CI.cptr (x26 x25)) x28
+    x29)
+| "snprintf",
+  CI.Function
+    (CI.Pointer x31,
+     CI.Function
+       (CI.View {CI.ty = CI.Primitive CI.Size_t; write = x33; },
+        CI.Function
+          (CI.View {CI.ty = CI.Pointer x36; write = x35; },
+           CI.Function
+             (CI.Primitive CI.Int, CI.Returns (CI.Primitive CI.Int))))) ->
+  (fun x30 x32 x34 x37 ->
+    cstubs_tests_1_snprintf (CI.cptr x30) (x33 x32) (CI.cptr (x35 x34)) x37)
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-variadic/generated_stubs.c ./tests/test-variadic/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-variadic/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-variadic/generated_stubs.c	2014-10-07 17:44:41.000000000 +0000
@@ -0,0 +1,48 @@
+#include "clib/test_functions.h"
+
+#include <stdio.h>
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_snprintf(value x4, value x3, value x2, value x1)
+{
+   char* x5 = CTYPES_ADDR_OF_FATPTR(x4);
+   size_t x6 = ctypes_size_t_val(x3);
+   char* x9 = CTYPES_ADDR_OF_FATPTR(x2);
+   int x10 = Int_val(x1);
+   int x13 = snprintf(x5, x6, x9, x10);
+   return Val_int(x13);
+}
+value cstubs_tests_2_snprintf(value x18, value x17, value x16, value x15,
+                              value x14)
+{
+   char* x19 = CTYPES_ADDR_OF_FATPTR(x18);
+   size_t x20 = ctypes_size_t_val(x17);
+   char* x23 = CTYPES_ADDR_OF_FATPTR(x16);
+   int x24 = Int_val(x15);
+   unsigned int x27 = ctypes_uint_val(x14);
+   int x30 = snprintf(x19, x20, x23, (char)x24, x27);
+   return Val_int(x30);
+}
+value cstubs_tests_3_snprintf(value x35, value x34, value x33, value x32,
+                              value x31)
+{
+   char* x36 = CTYPES_ADDR_OF_FATPTR(x35);
+   size_t x37 = ctypes_size_t_val(x34);
+   char* x40 = CTYPES_ADDR_OF_FATPTR(x33);
+   long long x41 = ctypes_llong_val(x32);
+   int x44 = Int_val(x31);
+   int x47 = snprintf(x36, x37, x40, x41, x44);
+   return Val_int(x47);
+}
+value cstubs_tests_4_snprintf(value x52, value x51, value x50, value x49,
+                              value x48)
+{
+   char* x53 = CTYPES_ADDR_OF_FATPTR(x52);
+   size_t x54 = ctypes_size_t_val(x51);
+   char* x57 = CTYPES_ADDR_OF_FATPTR(x50);
+   char* x58 = CTYPES_ADDR_OF_FATPTR(x49);
+   unsigned short x59 = ctypes_ushort_val(x48);
+   int x62 = snprintf(x53, x54, x57, x58, x59);
+   return Val_int(x62);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-variadic/test_variadic.ml ./tests/test-variadic/test_variadic.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-variadic/test_variadic.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-variadic/test_variadic.ml	2014-10-06 15:23:14.000000000 +0000
@@ -7,7 +7,7 @@
 
 (* Tests for binding variadic functions. *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -21,7 +21,7 @@
   (*
     Test calling snprintf.
   *)
-  let test_snprintf () =
+  let test_snprintf _ =
     let bufsz = 128 in
     let write snprintf apply =
       let buf = allocate_n char bufsz in
@@ -40,7 +40,7 @@
       assert_equal "a long long 9223372036854775807 and an int -4."
         (write snprintf_longlong_int
            (fun k -> k "a long long %lld and an int %d."
-             (LLong.of_int64 Int64.max_int) (-4)));
+             (LLong.of_nativeint Nativeint.max_int) (-4)));
 
       assert_equal "a string abcde and an unsigned short ffd."
         (write snprintf_string_ushort
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-views/generated_bindings.ml ./tests/test-views/generated_bindings.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-views/generated_bindings.ml	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-views/generated_bindings.ml	2014-10-07 17:44:50.000000000 +0000
@@ -0,0 +1,46 @@
+module CI = Cstubs_internals
+
+external cstubs_tests_1_concat_strings
+  : _ CI.fatptr -> int -> _ CI.fatptr -> unit
+  = "cstubs_tests_1_concat_strings" 
+
+external cstubs_tests_2_toupper : int -> int = "cstubs_tests_2_toupper" 
+
+external cstubs_tests_3_returning_funptr : int -> CI.voidp
+  = "cstubs_tests_3_returning_funptr" 
+
+external cstubs_tests_4_accepting_possibly_null_funptr
+  : _ CI.fatptr -> int -> int -> int
+  = "cstubs_tests_4_accepting_possibly_null_funptr" 
+
+type 'a fn = 'a
+
+let foreign : type a b. string -> (a -> b) Ctypes.fn -> (a -> b) =
+  fun name t -> match name, t with
+| "accepting_possibly_null_funptr",
+  CI.Function
+    (CI.View {CI.ty = CI.Pointer x3; write = x2; },
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Function (CI.Primitive CI.Int, CI.Returns (CI.Primitive CI.Int)))) ->
+  (fun x1 x4 x5 ->
+    cstubs_tests_4_accepting_possibly_null_funptr (CI.cptr (x2 x1)) x4 x5)
+| "returning_funptr",
+  CI.Function
+    (CI.Primitive CI.Int,
+     CI.Returns (CI.View {CI.ty = CI.Pointer x7; read = x8; })) ->
+  (fun x6 -> x8 (CI.make_ptr x7 (cstubs_tests_3_returning_funptr x6)))
+| "toupper",
+  CI.Function
+    (CI.View {CI.ty = CI.Primitive CI.Int; write = x10; },
+     CI.Returns (CI.View {CI.ty = CI.Primitive CI.Int; read = x11; })) ->
+  (fun x9 -> x11 (cstubs_tests_2_toupper (x10 x9)))
+| "concat_strings",
+  CI.Function
+    (CI.Pointer x13,
+     CI.Function
+       (CI.Primitive CI.Int,
+        CI.Function (CI.Pointer x16, CI.Returns CI.Void))) ->
+  (fun x12 x14 x15 ->
+    cstubs_tests_1_concat_strings (CI.cptr x12) x14 (CI.cptr x15))
+| s, _ ->  Printf.fprintf stderr "No match for %s" s; assert false
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-views/generated_stubs.c ./tests/test-views/generated_stubs.c
--- ../ocaml-ctypes-0.3.3.orig/tests/test-views/generated_stubs.c	1970-01-01 00:00:00.000000000 +0000
+++ ./tests/test-views/generated_stubs.c	2014-10-07 17:44:50.000000000 +0000
@@ -0,0 +1,35 @@
+#include "clib/test_functions.h"
+
+#include <ctype.h>
+
+#include "ctypes/cstubs_internals.h"
+
+value cstubs_tests_1_concat_strings(value x3, value x2, value x1)
+{
+   char** x4 = CTYPES_ADDR_OF_FATPTR(x3);
+   int x5 = Int_val(x2);
+   char* x8 = CTYPES_ADDR_OF_FATPTR(x1);
+   concat_strings(x4, x5, x8);
+   return Val_unit;
+}
+value cstubs_tests_2_toupper(value x10)
+{
+   int x11 = Int_val(x10);
+   int x14 = toupper(x11);
+   return Val_int(x14);
+}
+value cstubs_tests_3_returning_funptr(value x15)
+{
+   int x16 = Int_val(x15);
+   void* x19 = returning_funptr(x16);
+   return CTYPES_FROM_PTR(x19);
+}
+value cstubs_tests_4_accepting_possibly_null_funptr(value x22, value x21,
+                                                    value x20)
+{
+   void* x23 = CTYPES_ADDR_OF_FATPTR(x22);
+   int x24 = Int_val(x21);
+   int x27 = Int_val(x20);
+   int x30 = accepting_possibly_null_funptr(x23, x24, x27);
+   return Val_int(x30);
+}
diff -N -u -r ../ocaml-ctypes-0.3.3.orig/tests/test-views/test_views.ml ./tests/test-views/test_views.ml
--- ../ocaml-ctypes-0.3.3.orig/tests/test-views/test_views.ml	2014-08-01 08:23:56.000000000 +0000
+++ ./tests/test-views/test_views.ml	2014-10-06 15:23:14.000000000 +0000
@@ -5,7 +5,7 @@
  * See the file LICENSE for details.
  *)
 
-open OUnit
+open OUnit2
 open Ctypes
 
 
@@ -22,7 +22,7 @@
     using strings for input parameters and a char array for an output
     parameter.  Examine the output buffer using a cast to a string view.
   *)
-  let test_passing_string_array () =
+  let test_passing_string_array _ =
     let l = ["the "; "quick "; "brown "; "fox "; "etc. "; "etc. "; ] in
     let arr = CArray.of_list string l in
 
@@ -44,7 +44,7 @@
 
     using a custom view that treats chars as ints.
   *)
-  let test_passing_chars_as_ints () =
+  let test_passing_chars_as_ints _ =
     assert_equal ~msg:"toupper('x') = 'X'"
       'X' (toupper 'x');
 
@@ -58,7 +58,7 @@
   (*
     Use views to create a nullable function pointer.
   *)
-  let test_nullable_function_pointer_view () =
+  let test_nullable_function_pointer_view _ =
     begin
       let fromSome = function None -> assert false | Some x -> x in
 
@@ -88,7 +88,7 @@
 (*
   Use the nullable pointer view to view nulls as Nones.
 *)
-let test_nullable_pointer_view () =
+let test_nullable_pointer_view _ =
   let p = allocate int 10 in
   let pp = allocate (ptr int) p in
   let npp = from_voidp (ptr_opt int) (to_voidp pp) in
@@ -110,7 +110,7 @@
 (*
   Use a polar form view of complex numbers.
 *)
-let test_polar_form_view () =
+let test_polar_form_view _ =
   let module M =
   struct
     open Complex

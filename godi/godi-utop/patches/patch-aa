--- ../../work-ref/utop-1.12/src/camlp4/uTop_camlp4.ml	2014-04-21 15:04:02.000000000 +0200
+++ ./src/camlp4/uTop_camlp4.ml	2014-05-23 20:44:54.339200000 +0200
@@ -118,8 +118,13 @@
 let () =
   UTop.parse_toplevel_phrase := parse_toplevel_phrase;
   UTop.parse_use_file := parse_use_file;
-  (* Force camlp4 to display its welcome message. *)
+  (* So that camlp4 doesn't display its welcome message. *)
+  let interactive = !Sys.interactive in
+  Sys.interactive := false;
+  let () =
   try
     ignore (!Toploop.parse_toplevel_phrase (Lexing.from_string ""))
   with _ ->
     ()
+  in
+  Sys.interactive := interactive
--- ../../work-ref/utop-1.12/src/lib/uTop.ml	2014-04-21 15:04:02.000000000 +0200
+++ ./src/lib/uTop.ml	2014-05-23 20:44:54.354800000 +0200
@@ -312,12 +312,12 @@
         let env = !Toploop.toplevel_env in
         (* Construct "let _ () = let module _ = struct <items> end in ()" in order to test
            the typing and compilation of [items] without evaluating them. *)
+        let unit = with_loc loc (Longident.Lident "()") in
 #if ocaml_version < (4, 2, 0)
         let structure = {
           pmod_loc = loc;
           pmod_desc = Pmod_structure (item :: items);
         } in
-        let unit = with_loc loc (Longident.Lident "()") in
         let unit_expr = {
           pexp_desc = Pexp_construct (unit, None, false);
           pexp_loc = loc;
@@ -343,13 +343,13 @@
 #else
         let top_def =
           let open Ast_helper in
-          let open Convenience in
           with_default_loc loc
             (fun () ->
                Str.eval
+                 (Exp.fun_ "" None (Pat.construct unit None)
                  (Exp.letmodule (with_loc loc "_")
                     (Mod.structure (item :: items))
-                    (unit ())))
+                      (Exp.construct unit None))))
         in
 #endif
         let check_phrase = Ptop_def [top_def] in
--- ../../work-ref/utop-1.12/src/lib/uTop_complete.ml	2014-04-21 15:04:02.000000000 +0200
+++ ./src/lib/uTop_complete.ml	2014-05-23 20:44:54.354800000 +0200
@@ -302,6 +302,31 @@
        String_set.empty
        (try Sys.readdir (if dir = "" then Filename.current_dir_name else dir) with Sys_error _ -> [||]))
 
+#if ocaml_version >= (4, 02, 0)
+let path () =
+  let path_separator =
+    match Sys.os_type with
+    | "Unix" | "Cygwin" -> ':'
+    | "Win32" -> ';'
+    | _ -> assert false in
+  let split str sep =
+    let rec split_rec pos =
+      if pos >= String.length str then [] else begin
+        match try  Some (String.index_from str pos sep)
+              with Not_found -> None with
+        | Some newpos ->
+          String.sub str pos (newpos - pos) ::
+          split_rec (newpos + 1)
+        | None ->
+          [String.sub str pos (String.length str - pos)]
+      end in
+    split_rec 0
+  in
+  try
+    split (Sys.getenv "PATH") path_separator
+  with Not_found -> []
+#endif
+
 (* +-----------------------------------------------------------------+
    | Names listing                                                   |
    +-----------------------------------------------------------------+ *)
@@ -388,6 +413,10 @@
         List.fold_left (fun acc field -> add (field_name field) acc) acc fields
     | Type_abstract ->
         acc
+#if ocaml_version >= (4, 02, 0)
+    | Type_open ->
+        acc
+#endif
 
 let add_names_of_type decl acc =
   match decl.type_kind with
@@ -397,6 +426,10 @@
         List.fold_left (fun acc field -> add (field_name field) acc) acc fields
     | Type_abstract ->
         acc
+#if ocaml_version >= (4, 02, 0)
+    | Type_open ->
+        acc
+#endif
 
 #if ocaml_version >= (4, 0, 0)
 
@@ -405,7 +438,11 @@
       List.fold_left
         (fun acc decl -> match decl with
            | Sig_value (id, _)
+#if ocaml_version >= (4, 02, 0)
+           | Sig_typext (id, _, _)
+#else
            | Sig_exception (id, _)
+#endif
            | Sig_module (id, _, _)
            | Sig_modtype (id, _)
            | Sig_class (id, _, _)
@@ -433,7 +470,11 @@
       List.fold_left
         (fun acc decl -> match decl with
            | Sig_value (id, _)
+#if ocaml_version >= (4, 02, 0)
+           | Sig_typext (id, _, _)
+#else
            | Sig_exception (id, _)
+#endif
            | Sig_module (id, _, _)
            | Sig_modtype (id, _)
            | Sig_class (id, _, _)
@@ -511,7 +552,7 @@
 let find_module = Env.find_module
 #else
 let lookup_module id env =
-  let path = Env.lookup_module id env in
+  let path = Env.lookup_module id env ~load:true in
   (path, (Env.find_module path env).md_type)
 let find_module path env = (Env.find_module path env).md_type
 #endif
@@ -551,7 +592,11 @@
         loop (add (Ident.name id) acc) summary
     | Env.Env_type(summary, id, decl) ->
         loop (add_names_of_type decl (add (Ident.name id) acc)) summary
+#if ocaml_version >= (4, 02, 0)
+    | Env.Env_extension(summary, id, _) ->
+#else
     | Env.Env_exception(summary, id, _) ->
+#endif
         loop (add (Ident.name id) acc) summary
     | Env.Env_module(summary, id, _) ->
         loop (add (Ident.name id) acc) summary
@@ -612,7 +657,11 @@
         loop (add (Ident.name id) acc) summary
     | Env.Env_type(summary, id, decl) ->
         loop (add_fields_of_type decl (add (Ident.name id) acc)) summary
+#if ocaml_version >= (4, 02, 0)
+    | Env.Env_extension(summary, id, _) ->
+#else
     | Env.Env_exception(summary, id, _) ->
+#endif
         loop (add (Ident.name id) acc) summary
     | Env.Env_module(summary, id, _) ->
         loop (add (Ident.name id) acc) summary
@@ -878,6 +927,37 @@
         (loc.idx2 - Zed_utf8.length name,
          List.map (function (w, Directory) -> (w, "") | (w, File) -> (w, "\"" ^ phrase_terminator)) result)
 
+#if ocaml_version >= (4, 02, 0)
+    (* Completion on #ppx. *)
+    | [(Symbol "#", _); (Lident ("ppx"), _); (String false, loc)] ->
+        let file = String.sub input (loc.ofs1 + 1) (String.length input - loc.ofs1 - 1) in
+        let filter ~dir_ok name =
+          try
+            Unix.access name [Unix.X_OK];
+            let kind     = (Unix.stat name).Unix.st_kind in
+            let basename = Filename.basename name in
+            (kind = Unix.S_REG && String.length basename >= 4 &&
+                String.sub basename 0 4 = "ppx_") ||
+              (dir_ok && kind = Unix.S_DIR)
+          with Unix.Unix_error _ -> false
+        in
+        let map =
+          if Filename.dirname file = "." && not (Filename.is_implicit file) then
+            let dir = Filename.dirname file in
+            add_files (filter ~dir_ok:true) String_map.empty dir
+          else
+            List.fold_left
+              (fun acc dir -> add_files (fun name ->
+                  filter ~dir_ok:false (Filename.concat dir name)) acc dir)
+              String_map.empty (path ())
+        in
+        let list = String_map.bindings map in
+        let name = basename file in
+        let result = lookup_assoc name list in
+        (loc.idx2 - Zed_utf8.length name,
+         List.map (function (w, Directory) -> (w, "") | (w, File) -> (w, "\"" ^ phrase_terminator)) result)
+#endif
+
     (* Completion on #use. *)
     | [(Symbol "#", _); (Lident "use", _); (String false, loc)] ->
         let file = String.sub input (loc.ofs1 + 1) (String.length input - loc.ofs1 - 1) in
--- ../../work-ref/utop-1.12/src/lib/uTop_main.ml	2014-04-21 15:04:02.000000000 +0200
+++ ./src/lib/uTop_main.ml	2014-05-23 20:44:54.354800000 +0200
@@ -87,10 +87,24 @@
 
 let parse_and_check input eos_is_error =
   let buf = Buffer.create 32 in
+  let preprocess input =
+    match input with
+#if ocaml_version >= (4, 02, 0)
+    | UTop.Value (Parsetree.Ptop_def pstr) ->
+        begin try
+          let pstr = Pparse.apply_rewriters Config.ast_impl_magic_number pstr in
+          UTop.Value (Parsetree.Ptop_def pstr)
+        with Pparse.Error error ->
+          Pparse.report_error Format.str_formatter error;
+          UTop.Error ([], Format.flush_str_formatter ())
+        end
+#endif
+    | _ -> input
+  in
   let result =
     UTop.collect_formatters buf [Format.err_formatter]
       (fun () ->
-         match !UTop.parse_toplevel_phrase input eos_is_error with
+         match preprocess (!UTop.parse_toplevel_phrase input eos_is_error) with
            | UTop.Error (locs, msg) ->
                UTop.Error (convert_locs input locs, "Error: " ^ msg ^ "\n")
            | UTop.Value phrase ->
@@ -242,9 +256,17 @@
       | Outcometree.Osig_class (_, name, _, _, rs)
       | Outcometree.Osig_class_type (_, name, _, _, rs)
       | Outcometree.Osig_module (name, _, rs)
+#if ocaml_version >= (4, 02, 0)
+      | Outcometree.Osig_type ({ Outcometree.otype_name = name }, rs) ->
+#else
       | Outcometree.Osig_type ((name, _, _, _, _), rs) ->
+#endif
         (name, rs)
+#if ocaml_version >= (4, 02, 0)
+      | Outcometree.Osig_typext ({ Outcometree.oext_name = name}, _)
+#else
       | Outcometree.Osig_exception (name, _)
+#endif
       | Outcometree.Osig_modtype (name, _)
       | Outcometree.Osig_value (name, _, _) ->
         (name, Outcometree.Orec_not)
@@ -276,12 +298,16 @@
               wrap (Outcometree.Osig_module (name, a, Outcometree.Orec_first)) extra :: items'
             else
               items
-          | Outcometree.Osig_type ((name, a, b, c, d), rs) ->
+          | Outcometree.Osig_type (oty, rs) ->
             if rs = Outcometree.Orec_next then
-              wrap (Outcometree.Osig_type ((name, a, b, c, d), Outcometree.Orec_first)) extra :: items'
+              wrap (Outcometree.Osig_type (oty, Outcometree.Orec_first)) extra :: items'
             else
               items
+#if ocaml_version >= (4, 02, 0)
+          | Outcometree.Osig_typext _
+#else
           | Outcometree.Osig_exception _
+#endif
           | Outcometree.Osig_modtype _
           | Outcometree.Osig_value _ ->
             items
@@ -372,7 +398,6 @@
       ; Parsetree.pexp_loc = loc }
 #else
       let open Ast_helper in
-      let open Convenience in
       with_default_loc loc (fun () ->
         Exp.apply (Exp.ident (with_loc loc longident_lwt_main_run)) [("", e)]
       )
@@ -396,11 +421,11 @@
       ; Parsetree.pexp_loc = loc }
 #else
       let open Ast_helper in
-      let open Convenience in
+      let punit = Pat.construct (with_loc loc (Longident.Lident "()")) None in
       with_default_loc loc (fun () ->
         Exp.apply
           (Exp.ident (with_loc loc longident_async_thread_safe_block_on_async_exn))
-          [("", Exp.fun_ "" None (punit ()) e)]
+          [("", Exp.fun_ "" None punit e)]
       )
 #endif
     );
@@ -514,7 +539,7 @@
         let tstr = str_items_of_typed_structure tstr in
         Parsetree.Ptop_def (List.map2 rewrite_str_item pstr tstr)
       else
-        phrase
+        Parsetree.Ptop_def pstr
     | Parsetree.Ptop_dir _ ->
       phrase
 
@@ -583,6 +608,8 @@
 #if ocaml_version > (4, 00, 1)
            Env.reset_cache_toplevel ();
 #endif
+           if !Clflags.dump_parsetree then Printast.top_phrase pp phrase;
+           if !Clflags.dump_source then Pprintast.top_phrase pp phrase;
            ignore (Toploop.execute_phrase true pp phrase);
            (* Flush everything. *)
            Format.pp_print_flush Format.std_formatter ();
@@ -661,7 +688,11 @@
     else
       Lwt_io.read_char_opt Lwt_io.stdin >>= function
         | Some c ->
+#if ocaml_version >= (4, 02, 0)
+            Bytes.set buffer i c;
+#else
             buffer.[i] <- c;
+#endif
             if c = '\n' then
               return (i + 1, false)
             else
@@ -1003,10 +1034,10 @@
       Some (Printtyp.tree_of_type_declaration id ty_decl Types.Trec_not)
     with Not_found ->
     try
-#if ocaml_version < (4, 2, 0)
+#if ocaml_version < (4, 02, 0)
       let (path, mod_typ) = Env.lookup_module id env in
 #else
-      let path = Env.lookup_module id env in
+      let path = Env.lookup_module id env ~load:true in
       let mod_typ = (Env.find_module path env).Types.md_type in
 #endif
       let id = Ident.create (Path.name path) in
@@ -1020,10 +1051,12 @@
     try
       let cstr_desc = Env.lookup_constructor id env in
       match cstr_desc.Types.cstr_tag with
+#if ocaml_version < (4, 02, 0)
       | Types.Cstr_exception (_path, loc) ->
         let path, exn_decl = Typedecl.transl_exn_rebind env loc id in
         let id = Ident.create (Path.name path) in
         Some (Printtyp.tree_of_exception_declaration id exn_decl)
+#endif
       | _ ->
         let (path, ty_decl) = from_type_desc cstr_desc.Types.cstr_res.Types.desc in
         let id = Ident.create (Path.name path) in
@@ -1119,6 +1152,9 @@
   "-noassert", Arg.Set Clflags.noassert, " Do not compile assertion checks";
   "-nolabels", Arg.Set Clflags.classic, " Ignore non-optional labels in types";
   "-nostdlib", Arg.Set Clflags.no_std_include, " Do not add default directory to the list of include directories";
+#if ocaml_version >= (4, 02, 0)
+  "-ppx", Arg.String (fun ppx -> Clflags.all_ppx := ppx :: !Clflags.all_ppx), "<command> Pipe abstract syntax trees through preprocessor <command>";
+#endif
   "-principal", Arg.Set Clflags.principal, " Check principality of type inference";
 #if ocaml_version >= (4, 01, 0)
   "-short-paths", Arg.Clear Clflags.real_paths, " Shorten paths in types (the default)";
@@ -1156,6 +1192,8 @@
   " Disable autoloading of files in $OCAML_TOPLEVEL_PATH/autoload";
   "-require", Arg.String (fun s -> preload := `Packages (UTop.split_words s) :: !preload),
   "<package> Load this package";
+  "-dparsetree", Arg.Set Clflags.dump_parsetree, " Dump OCaml AST after rewriting";
+  "-dsource", Arg.Set Clflags.dump_source, " Dump OCaml source after rewriting";
 ]
 
 #if ocaml_version >= (4, 01, 0)
--- ../../work-ref/utop-1.12/syntax/pa_optcomp.ml	2014-04-21 15:04:02.000000000 +0200
+++ ./syntax/pa_optcomp.ml	2014-05-23 20:44:54.370400000 +0200
@@ -475,20 +475,27 @@
 let parse_until entry is_stop_token stream =
   (* Lists of opened brackets *)
   let opened_brackets = ref [] in
-
+  let eoi = ref None in
   let end_loc = ref Loc.ghost in
 
   (* Return the next token of [stream] until all opened parentheses
      have been closed and a newline is reached *)
   let rec next_token _ =
+    match !eoi with
+    | Some _ as x -> x
+    | None ->
     Some(match Stream.next stream, !opened_brackets with
            | (tok, loc), [] when is_stop_token tok ->
                end_loc := loc;
-               (EOI, loc)
+               let x = (EOI, loc) in
+               eoi := Some x;
+               x
 
            | (EOI, loc), _ ->
                end_loc := loc;
-               (EOI, loc)
+               let x = (EOI, loc) in
+               eoi := Some x;
+               x
 
            | ((KEYWORD ("(" | "[" | "{" as b) | SYMBOL ("(" | "[" | "{" as b)), _) as x, l ->
                opened_brackets := b :: l;

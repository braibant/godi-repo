--- ../../work-ref/godi-tools-3.0.37/console-src/symlink	2013-04-14 15:03:20.000000000 +0200
+++ ./console-src/symlink	2014-02-11 06:09:26.286800000 +0100
@@ -1,51 +1,39 @@
 #! /bin/sh
 
-# On POSIX create a symlink from one executable to another, e.g.
-# godi_add -> godi_console
-
-# On Win32 emulate that by creating a small wrapper program.
-# Needs env var W32PORT. $symto must be an absolute Win32 path.
-
 set -e
 
+if [ -z "$W32PORT" ]; then
+    echo "Only call me on w32" >&2
+    exit 1
+fi
+
 if [ -z "$CC" ]; then
     echo "Variable CC not set!" >&2
     exit 1
 fi
 
+# sample call
+#./symlink "../sbin/godi_console.exe" "$(prefix)/bin/godi_$$f$(EXE)"; 
 
-symto="$1"
-symfrom="$2"
+symlink_c="$(dirname "$0")/symlink.c"
 
-if [ -z "$W32PORT" ]; then
-    ln -s "$symto" "$symfrom"
-else
-    bfrom=`basename "$symfrom" .exe`
-    bfrom="${bfrom#godi_*}"
-    mkdir -p tmp
-
-    cat >tmp/wrapper.c <<EOF 
-#include <process.h>
-#include <errno.h>
-#include <stdlib.h>
-main(int argc, char **argv) {
-    char **new_argv;
-    int k, code;
-    new_argv = malloc( (argc+2) * sizeof (char *) );
-    new_argv[0] = "$1";
-    new_argv[1] = "$bfrom";
-    for (k=1; k < argc; k++) new_argv[k+1] = argv[k];
-    new_argv[argc+1] = NULL;
-    code = _spawnv(_P_WAIT, "$1", (const char **) new_argv);
-    if (code == -1) {
-        perror("$bfrom: Cannot exec $1");
-        exit(127);
-    }
-    else exit(code);
-}
-EOF
+argv1="$(basename "$2" .exe)"
+argv1="${argv1#godi_*}"
+prog="$(echo "$1" | sed 's|/|\\\\\\\\|g')"
 
-    $CC -o tmp/wrapper tmp/wrapper.c
-    cp tmp/wrapper "$symfrom"
-fi
+cfile="$(mktemp --suffix '.c')"
+exefile="$(mktemp --suffix '.exe')"
+
+clean(){
+    rm -f "$cfile"
+    rm -f "$exefile"
+}
+trap clean EXIT
 
+sed -e "s|@PROG@|$prog|g" \
+    -e "s|@ARGV1@|$argv1|g" \
+    "$symlink_c"  >"$cfile"
+
+$WINDRES dummy.rc dummy.o
+$CC -o "$exefile" dummy.o "$cfile"
+cp "$exefile" "$2"
